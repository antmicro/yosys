diff --git a/hw/ip/aes/rtl/aes_cipher_core.sv b/hw/ip/aes/rtl/aes_cipher_core.sv
index ed35dc5ef..d1b6b560f 100644
--- a/hw/ip/aes/rtl/aes_cipher_core.sv
+++ b/hw/ip/aes/rtl/aes_cipher_core.sv
@@ -40,24 +40,24 @@ module aes_cipher_core #(
   input  logic          [63:0] prng_data_i,
 
   // I/O data & initial key
-  input  logic [3:0][3:0][7:0] state_init_i,
+  input  logic [127:0] state_init_i,
   input  logic     [7:0][31:0] key_init_i,
-  output logic [3:0][3:0][7:0] state_o
+  output logic [127:0] state_o
 );
 
   import aes_pkg::*;
 
   // Signals
-  logic [3:0][3:0][7:0] state_d;
-  logic [3:0][3:0][7:0] state_q;
+  logic [127:0] state_d;
+  logic [127:0] state_q;
   logic                 state_we;
   state_sel_e           state_sel;
 
-  logic [3:0][3:0][7:0] sub_bytes_out;
-  logic [3:0][3:0][7:0] shift_rows_out;
-  logic [3:0][3:0][7:0] mix_columns_out;
-  logic [3:0][3:0][7:0] add_round_key_in;
-  logic [3:0][3:0][7:0] add_round_key_out;
+  logic [127:0] sub_bytes_out;
+  logic [127:0] shift_rows_out;
+  logic [127:0] mix_columns_out;
+  logic [127:0] add_round_key_in;
+  logic [127:0] add_round_key_out;
   add_rk_sel_e          add_round_key_in_sel;
 
   logic     [7:0][31:0] key_full_d;
@@ -75,9 +75,9 @@ module aes_cipher_core #(
   logic           [3:0] key_expand_round;
   key_words_sel_e       key_words_sel;
   logic     [3:0][31:0] key_words;
-  logic [3:0][3:0][7:0] key_bytes;
-  logic [3:0][3:0][7:0] key_mix_columns_out;
-  logic [3:0][3:0][7:0] round_key;
+  logic [127:0] key_bytes;
+  logic [127:0] key_mix_columns_out;
+  logic [127:0] round_key;
   round_key_sel_e       round_key_sel;
 
   //////////
@@ -103,19 +103,19 @@ module aes_cipher_core #(
   // Cipher data path
   aes_sub_bytes #(
     .SBoxImpl ( SBoxImpl )
-  ) aes_sub_bytes (
+  ) u_aes_sub_bytes (
     .op_i   ( op_i          ),
     .data_i ( state_q       ),
     .data_o ( sub_bytes_out )
   );
 
-  aes_shift_rows aes_shift_rows (
+  aes_shift_rows u_aes_shift_rows (
     .op_i   ( op_i           ),
     .data_i ( sub_bytes_out  ),
     .data_o ( shift_rows_out )
   );
 
-  aes_mix_columns aes_mix_columns (
+  aes_mix_columns u_aes_mix_columns (
     .op_i   ( op_i            ),
     .data_i ( shift_rows_out  ),
     .data_o ( mix_columns_out )
@@ -172,7 +172,7 @@ module aes_cipher_core #(
   aes_key_expand #(
     .AES192Enable ( AES192Enable ),
     .SBoxImpl     ( SBoxImpl     )
-  ) aes_key_expand (
+  ) u_aes_key_expand (
     .clk_i     ( clk_i            ),
     .rst_ni    ( rst_ni           ),
     .op_i      ( key_expand_op    ),
@@ -197,7 +197,7 @@ module aes_cipher_core #(
   // Convert words to bytes (every key word contains one column)
   assign key_bytes = aes_transpose(key_words);
 
-  aes_mix_columns aes_key_mix_columns (
+  aes_mix_columns u_aes_key_mix_columns (
     .op_i   ( CIPH_INV            ),
     .data_i ( key_bytes           ),
     .data_o ( key_mix_columns_out )
@@ -216,7 +216,7 @@ module aes_cipher_core #(
   /////////////
 
   // Control
-  aes_cipher_control aes_cipher_control (
+  aes_cipher_control u_aes_cipher_control (
     .clk_i                  ( clk_i                ),
     .rst_ni                 ( rst_ni               ),
 
diff --git a/hw/ip/aes/rtl/aes_key_expand.sv b/hw/ip/aes/rtl/aes_key_expand.sv
index c030089b7..65f0bdc94 100644
--- a/hw/ip/aes/rtl/aes_key_expand.sv
+++ b/hw/ip/aes/rtl/aes_key_expand.sv
@@ -191,7 +191,7 @@ module aes_key_expand #(
 
   // To reduce muxing resources, we re-use existing
   // connections for unused words and default cases.
-  always_comb begin : drive_regular
+  always begin : drive_regular
     unique case (key_len_i)
 
       /////////////
diff --git a/hw/ip/aes/rtl/aes_mix_columns.sv b/hw/ip/aes/rtl/aes_mix_columns.sv
index 3aee014a2..222464474 100644
--- a/hw/ip/aes/rtl/aes_mix_columns.sv
+++ b/hw/ip/aes/rtl/aes_mix_columns.sv
@@ -6,15 +6,15 @@
 
 module aes_mix_columns (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Transpose to operate on columns
-  logic [3:0][3:0][7:0] data_i_transposed;
-  logic [3:0][3:0][7:0] data_o_transposed;
+  logic [127:0] data_i_transposed;
+  logic [127:0] data_o_transposed;
 
   assign data_i_transposed = aes_transpose(data_i);
 
diff --git a/hw/ip/aes/rtl/aes_pkg.sv b/hw/ip/aes/rtl/aes_pkg.sv
index ddc3b7992..6d4e2a759 100644
--- a/hw/ip/aes/rtl/aes_pkg.sv
+++ b/hw/ip/aes/rtl/aes_pkg.sv
@@ -165,12 +165,12 @@ function automatic logic [31:0] aes_circ_byte_shift(logic [31:0] in, logic [1:0]
 endfunction
 
 // Transpose state matrix
-function automatic logic [3:0][3:0][7:0] aes_transpose(logic [3:0][3:0][7:0] in);
-  logic [3:0][3:0][7:0] transpose;
+function automatic logic [127:0] aes_transpose(logic [127:0] in);
+  logic [127:0] transpose;
   transpose = '0;
   for (int j=0; j<4; j++) begin
     for (int i=0; i<4; i++) begin
-      transpose[i][j] = in[j][i];
+      transpose[((i * 4) + j) * 8+:8] = in[((j * 4) + i) * 8+:8];
     end
   end
   return transpose;
diff --git a/hw/ip/aes/rtl/aes_prng.sv b/hw/ip/aes/rtl/aes_prng.sv
index 08e2a94e6..a94dbdd43 100644
--- a/hw/ip/aes/rtl/aes_prng.sv
+++ b/hw/ip/aes/rtl/aes_prng.sv
@@ -23,7 +23,7 @@ module aes_prng (
   input  logic        entropy_ack_i,
   input  logic [63:0] entropy_i
 );
-
+  import prim_cipher_pkg::*;
   localparam int unsigned DATA_WIDTH = 64;
 
   logic                  seed_en;
@@ -58,7 +58,7 @@ module aes_prng (
   );
 
   // "Scramble" the LFSR state.
-  assign scrambled = prim_cipher_pkg::sbox4_64bit(lfsr_state, prim_cipher_pkg::PRINCE_SBOX4);
-  assign data_o    = prim_cipher_pkg::perm_64bit(scrambled, prim_cipher_pkg::PRESENT_PERM64);
+  assign scrambled = sbox4_64bit(lfsr_state, PRINCE_SBOX4);
+  assign data_o    = perm_64bit(scrambled, PRESENT_PERM64);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_shift_rows.sv b/hw/ip/aes/rtl/aes_shift_rows.sv
index b33b570a0..ef9eea32b 100644
--- a/hw/ip/aes/rtl/aes_shift_rows.sv
+++ b/hw/ip/aes/rtl/aes_shift_rows.sv
@@ -6,24 +6,24 @@
 
 module aes_shift_rows (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Row 0 is left untouched
-  assign data_o[0] = data_i[0];
+  assign data_o[0] = data_i[0+:32];
 
   // Row 2 does not depend on op_i
-  assign data_o[2] = aes_circ_byte_shift(data_i[2], 2'h2);
+  assign data_o[2] = aes_circ_byte_shift(data_i[64+:32], 2'h2);
 
   // Row 1
-  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[1], 2'h3)
-                                        : aes_circ_byte_shift(data_i[1], 2'h1);
+  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[32+:32], 2'h3)
+                                        : aes_circ_byte_shift(data_i[32+:32], 2'h1);
 
   // Row 3
-  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[3], 2'h1)
-                                        : aes_circ_byte_shift(data_i[3], 2'h3);
+  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[96+:32], 2'h1)
+                                        : aes_circ_byte_shift(data_i[96+:32], 2'h3);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_sub_bytes.sv b/hw/ip/aes/rtl/aes_sub_bytes.sv
index 1d3e5c3a9..081c718f9 100644
--- a/hw/ip/aes/rtl/aes_sub_bytes.sv
+++ b/hw/ip/aes/rtl/aes_sub_bytes.sv
@@ -8,8 +8,8 @@ module aes_sub_bytes #(
   parameter SBoxImpl = "lut"
 ) (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   // Individually substitute bytes
@@ -19,8 +19,8 @@ module aes_sub_bytes #(
         .SBoxImpl ( SBoxImpl )
       ) aes_sbox_ij (
         .op_i   ( op_i         ),
-        .data_i ( data_i[i][j] ),
-        .data_o ( data_o[i][j] )
+        .data_i ( data_i[((i * 4) + j) * 8+:8] ),
+        .data_o ( data_o[((i * 4) + j) * 8+:8] )
       );
     end
   end
diff --git a/hw/ip/alert_handler/rtl/alert_pkg.sv b/hw/ip/alert_handler/rtl/alert_pkg.sv
index 5324b4978..fb9e8de6c 100644
--- a/hw/ip/alert_handler/rtl/alert_pkg.sv
+++ b/hw/ip/alert_handler/rtl/alert_pkg.sv
@@ -5,24 +5,20 @@
 
 package alert_pkg;
 
-  // these localparams are generated based on the system top-level configuration
-  localparam int unsigned      NAlerts   = alert_handler_reg_pkg::NAlerts;   // maximum 252
-  localparam int unsigned      EscCntDw  = alert_handler_reg_pkg::EscCntDw;  // maximum 32
-  localparam int unsigned      AccuCntDw = alert_handler_reg_pkg::AccuCntDw; // maximum 32
-  // seed for the ping timer (must be nonzero!)
-  localparam logic [31:0]      LfsrSeed  = alert_handler_reg_pkg::LfsrSeed;
-  // enable async transitions for specific RX/TX pairs
-  localparam bit [NAlerts-1:0] AsyncOn   = alert_handler_reg_pkg::AsyncOn;
-
-  // common constants, do not change
-  localparam int unsigned N_CLASSES   = alert_handler_reg_pkg::N_CLASSES;
-  localparam int unsigned N_ESC_SEV   = alert_handler_reg_pkg::N_ESC_SEV;
-  localparam int unsigned N_PHASES    = alert_handler_reg_pkg::N_PHASES;
-  localparam int unsigned N_LOC_ALERT = alert_handler_reg_pkg::N_LOC_ALERT;
-
-  localparam int unsigned PING_CNT_DW = alert_handler_reg_pkg::PING_CNT_DW;
-  localparam int unsigned PHASE_DW    = alert_handler_reg_pkg::PHASE_DW;
-  localparam int unsigned CLASS_DW    = alert_handler_reg_pkg::CLASS_DW;
+  // copied from alert_handler_reg_pkg as it is currently unparsable by
+  // yosys/surelog
+  parameter int NAlerts = 5;
+  parameter int EscCntDw = 32;
+  parameter int AccuCntDw = 16;
+  parameter int LfsrSeed = 2147483647;
+  parameter logic [NAlerts-1:0] AsyncOn = 5'b00000;
+  parameter int N_CLASSES = 4;
+  parameter int N_ESC_SEV = 4;
+  parameter int N_PHASES = 4;
+  parameter int N_LOC_ALERT = 4;
+  parameter int PING_CNT_DW = 24;
+  parameter int PHASE_DW = 2;
+  parameter int CLASS_DW = 2;
 
   // do not change the phase encoding
   typedef enum logic [2:0] {Idle = 3'b000, Timeout = 3'b001, Terminal = 3'b011,
@@ -68,9 +64,9 @@ package alert_pkg;
     logic [N_CLASSES-1:0]                              class_clr;          // clears esc/accu
     logic [N_CLASSES-1:0][AccuCntDw-1:0]               class_accum_thresh; // accum esc threshold
     logic [N_CLASSES-1:0][EscCntDw-1:0]                class_timeout_cyc;  // interrupt timeout
-    logic [N_CLASSES-1:0][N_PHASES-1:0][EscCntDw-1:0]  class_phase_cyc;    // length of phases 0..3
+    logic [511:0]  class_phase_cyc;    // length of phases 0..3
     logic [N_CLASSES-1:0][N_ESC_SEV-1:0]               class_esc_en;       // esc signal enables
-    logic [N_CLASSES-1:0][N_ESC_SEV-1:0][PHASE_DW-1:0] class_esc_map;      // esc signal/phase map
+    logic [31:0] class_esc_map;      // esc signal/phase map
   } reg2hw_wrap_t;
 
 endpackage : alert_pkg
diff --git a/hw/ip/flash_ctrl/rtl/flash_phy.sv b/hw/ip/flash_ctrl/rtl/flash_phy.sv
index 28ad2a12a..af2b735dd 100644
--- a/hw/ip/flash_ctrl/rtl/flash_phy.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_phy.sv
@@ -21,7 +21,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   input flash_req_t flash_ctrl_i,
   output flash_rsp_t flash_ctrl_o
 );
-
+  import flash_phy_pkg::*;
   // Flash macro outstanding refers to how many reads we allow a macro to move ahead of an
   // in order blocking read. Since the data cannot be returned out of order, this simply
   // does the reads in advance and store them in a FIFO
@@ -46,7 +46,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  host_rsp_avail;
   logic [NumBanks-1:0]  host_rsp_vld;
   logic [NumBanks-1:0]  host_rsp_ack;
-  logic [BusWidth-1:0]  host_rsp_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0]  host_rsp_data;
   logic                 seq_fifo_rdy;
   logic                 seq_fifo_pending;
 
@@ -59,7 +59,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  init_busy;
 
   // common interface
-  logic [BusWidth-1:0] rd_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0] rd_data;
 
   // select which bank each is operating on
   assign host_bank_sel = host_req_i ? host_addr_i[BusAddrW-1 -: BankW] : '0;
diff --git a/hw/ip/hmac/rtl/sha2_pad.sv b/hw/ip/hmac/rtl/sha2_pad.sv
index 5ee90881c..2667008be 100644
--- a/hw/ip/hmac/rtl/sha2_pad.sv
+++ b/hw/ip/hmac/rtl/sha2_pad.sv
@@ -89,7 +89,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       Pad00: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
 
       LenHi: begin
@@ -101,7 +101,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       default: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
     endcase
   end
@@ -298,9 +298,9 @@ module sha2_pad import hmac_pkg::*; (
   // tx_count
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (hash_start) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (inc_txcount) begin
       tx_count[63:5] <= tx_count[63:5] + 1'b1;
     end
diff --git a/hw/ip/otbn/rtl/otbn_core.sv b/hw/ip/otbn/rtl/otbn_core.sv
index 8b13db4f5..312277b5f 100644
--- a/hw/ip/otbn/rtl/otbn_core.sv
+++ b/hw/ip/otbn/rtl/otbn_core.sv
@@ -10,7 +10,6 @@
  * This module is the top-level of the OTBN processing core.
  */
 module otbn_core
-  import otbn_pkg::*;
 #(
   // Size of the instruction memory, in bytes
   parameter int ImemSizeByte = 4096,
@@ -40,9 +39,9 @@ module otbn_core
   output logic                     dmem_req_o,
   output logic                     dmem_write_o,
   output logic [DmemAddrWidth-1:0] dmem_addr_o,
-  output logic [WLEN-1:0]          dmem_wdata_o,
-  output logic [WLEN-1:0]          dmem_wmask_o,
-  input  logic [WLEN-1:0]          dmem_rdata_i,
+  output logic [256-1:0]          dmem_wdata_o,
+  output logic [256-1:0]          dmem_wmask_o,
+  input  logic [256-1:0]          dmem_rdata_i,
   input  logic                     dmem_rvalid_i,
   input  logic [1:0]               dmem_rerror_i
 );
diff --git a/hw/ip/otbn/rtl/otbn_reg_top.sv b/hw/ip/otbn/rtl/otbn_reg_top.sv
index 052cb2f5a..b62227975 100644
--- a/hw/ip/otbn/rtl/otbn_reg_top.sv
+++ b/hw/ip/otbn/rtl/otbn_reg_top.sv
@@ -54,13 +54,13 @@ module otbn_reg_top (
   logic [1:0] reg_steer;
 
   // socket_1n connection
-  assign tl_reg_h2d = tl_socket_h2d[2];
-  assign tl_socket_d2h[2] = tl_reg_d2h;
+  assign tl_reg_h2d = tl_socket_h2d[0];
 
-  assign tl_win_o[0] = tl_socket_h2d[0];
-  assign tl_socket_d2h[0] = tl_win_i[0];
-  assign tl_win_o[1] = tl_socket_h2d[1];
-  assign tl_socket_d2h[1] = tl_win_i[1];
+  assign tl_win_o[0] = tl_socket_h2d[1];
+  assign tl_win_o[1] = tl_socket_h2d[2];
+  assign tl_socket_d2h[0] = tl_reg_d2h;
+  assign tl_socket_d2h[1] = tl_win_i[0];
+  assign tl_socket_d2h[2] = tl_win_i[1];
 
   // Create Socket_1n
   tlul_socket_1n #(
diff --git a/hw/ip/prim/prim.core b/hw/ip/prim/prim.core
index 5c83f063c..cb822ede5 100644
--- a/hw/ip/prim/prim.core
+++ b/hw/ip/prim/prim.core
@@ -23,6 +23,7 @@ filesets:
       - rtl/prim_alert_receiver.sv
       - rtl/prim_alert_sender.sv
       - rtl/prim_arbiter_ppc.sv
+      - rtl/prim_arbiter_ppc_surelog.sv
       - rtl/prim_arbiter_tree.sv
       - rtl/prim_dom_and_2share.sv
       - rtl/prim_arbiter_fixed.sv
@@ -31,6 +32,7 @@ filesets:
       - rtl/prim_esc_sender.sv
       - rtl/prim_sram_arbiter.sv
       - rtl/prim_fifo_async.sv
+      - rtl/prim_fifo_async_surelog.sv
       - rtl/prim_fifo_sync.sv
       - rtl/prim_sync_reqack.sv
       - rtl/prim_keccak.sv
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc.sv b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
index 9ec473f85..86bef1e9d 100644
--- a/hw/ip/prim/rtl/prim_arbiter_ppc.sv
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
@@ -113,12 +113,14 @@ module prim_arbiter_ppc #(
       end
     end else begin: gen_nodatapath
       assign data_o = '1;
-      // TODO: waive data_i from NOT_READ error
+      // The following signal is used to avoid possible lint errors.
+      logic [DW-1:0] unused_data [N];
+      assign unused_data = data_i;
     end
 
     always_comb begin
       idx_o = '0;
-      for (int i = 0 ; i < N ; i++) begin
+      for (int unsigned i = 0 ; i < N ; i++) begin
         if (winner[i]) begin
           idx_o = i[IdxW-1:0];
         end
@@ -222,4 +224,3 @@ end
 `endif
 
 endmodule : prim_arbiter_ppc
-
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc_n2.sv b/hw/ip/prim/rtl/prim_arbiter_ppc_n2.sv
new file mode 100644
index 000000000..d5542b139
--- /dev/null
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc_n2.sv
@@ -0,0 +1,225 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// N:1 arbiter module
+//
+// Verilog parameter
+//   N:           Number of request ports
+//   DW:          Data width
+//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
+//   EnReqStabA:  Checks whether requests remain asserted until granted
+//
+// This is the original implementation of the arbiter which relies on parallel prefix computing
+// optimization to optimize the request / arbiter tree. Not all synthesis tools may support this.
+//
+// Note that the currently winning request is held if the data sink is not ready. This behavior is
+// required by some interconnect protocols (AXI, TL). The module contains an assertion that checks
+// this behavior.
+//
+// Also, this module contains a request stability assertion that checks that requests stay asserted
+// until they have been served. This assertion can be optionally disabled by setting EnReqStabA to
+// zero. This is a non-functional parameter and does not affect the designs behavior.
+//
+// See also: prim_arbiter_tree
+
+`include "prim_assert.sv"
+
+module prim_arbiter_ppc_n2 #(
+  parameter int unsigned N  = 2,
+  parameter int unsigned DW = 102,
+
+  // Configurations
+  // EnDataPort: {0, 1}, if 0, input data will be ignored
+  parameter bit EnDataPort = 1,
+
+  // Non-functional parameter to switch on the request stability assertion
+  parameter bit EnReqStabA = 1,
+
+  // Derived parameters
+  localparam int IdxW = $clog2(N)
+) (
+  input clk_i,
+  input rst_ni,
+
+  input        [ N-1:0]    req_i,
+  input        [(0 >= (N - 1) ? ((2 - N) * DW) + (((N - 1) * DW) - 1) : (N * DW) - 1):(0 >= (N - 1) ?(N - 1) * DW : 0)]    data_i,
+  output logic [ N-1:0]    gnt_o,
+  output logic [IdxW-1:0]  idx_o,
+
+  output logic             valid_o,
+  output logic [DW-1:0]    data_o,
+  input                    ready_i
+);
+
+  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
+
+  // this case is basically just a bypass
+  if (N == 1) begin : gen_degenerate_case
+
+    assign valid_o  = req_i[0];
+    assign data_o   = data_i[0];
+    assign gnt_o[0] = valid_o & ready_i;
+    assign idx_o    = '0;
+
+  end else begin : gen_normal_case
+
+    logic [N-1:0] masked_req;
+    logic [N-1:0] ppc_out;
+    logic [N-1:0] arb_req;
+    logic [N-1:0] mask, mask_next;
+    logic [N-1:0] winner;
+
+    assign masked_req = mask & req_i;
+    assign arb_req = (|masked_req) ? masked_req : req_i;
+
+    // PPC
+    //   Even below code looks O(n) but DC optimizes it to O(log(N))
+    //   Using Parallel Prefix Computation
+    always_comb begin
+      ppc_out[0] = arb_req[0];
+      for (int i = 1 ; i < N ; i++) begin
+        ppc_out[i] = ppc_out[i-1] | arb_req[i];
+      end
+    end
+
+    // Grant Generation: Leading-One detector
+    assign winner = ppc_out ^ {ppc_out[N-2:0], 1'b0};
+    assign gnt_o    = (ready_i) ? winner : '0;
+
+    assign valid_o = |req_i;
+    // Mask Generation
+    assign mask_next = {ppc_out[N-2:0], 1'b0};
+    always_ff @(posedge clk_i or negedge rst_ni) begin
+      if (!rst_ni) begin
+        mask <= '0;
+      end else if (valid_o && ready_i) begin
+        // Latch only when requests accepted
+        mask <= mask_next;
+      end else if (valid_o && !ready_i) begin
+        // Downstream isn't yet ready so, keep current request alive. (First come first serve)
+        mask <= ppc_out;
+      end
+    end
+
+    if (EnDataPort == 1) begin: gen_datapath
+      always_comb begin
+        data_o = '0;
+        for (int i = 0 ; i < N ; i++) begin
+          if (winner[i]) begin
+            data_o = data_i[(0 >= (N - 1) ? i : (N - 1) - i) * DW+:DW];
+          end
+        end
+      end
+    end else begin: gen_nodatapath
+      assign data_o = '1;
+      // TODO: waive data_i from NOT_READ error
+    end
+
+    always_comb begin
+      idx_o = '0;
+      for (int i = 0 ; i < N ; i++) begin
+        if (winner[i]) begin
+          idx_o = i[IdxW-1:0];
+        end
+      end
+    end
+  end
+
+  ////////////////
+  // assertions //
+  ////////////////
+
+  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
+  // e.g. when used on a BUS
+  `ASSERT_KNOWN(ValidKnown_A, valid_o)
+  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
+  `ASSERT_KNOWN(IdxKnown_A, idx_o)
+
+  // grant index shall be higher index than previous index, unless no higher requests exist.
+  `ASSERT(RoundRobin_A,
+      ##1 valid_o && ready_i && $past(ready_i) && $past(valid_o) &&
+      |(req_i & ~((N'(1) << $past(idx_o)+1) - 1)) |->
+      idx_o > $past(idx_o))
+  // we can only grant one requestor at a time
+  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
+  // A grant implies that the sink is ready
+  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
+  // A grant implies that the arbiter asserts valid as well
+  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
+  // Both conditions above combined and reversed
+  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
+  // Both conditions above combined and reversed
+  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
+  // check index / grant correspond
+  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
+
+if (EnDataPort) begin: gen_data_port_assertion
+  // data flow
+  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
+end
+
+if (EnReqStabA) begin : gen_lock_assertion
+  // requests must stay asserted until they have been granted
+  `ASSUME(ReqStaysHighUntilGranted0_M, (|req_i) && !ready_i |=>
+      (req_i & $past(req_i)) == $past(req_i))
+  // check that the arbitration decision is held if the sink is not ready
+  `ASSERT(LockArbDecision_A, |req_i && !ready_i |=> idx_o == $past(idx_o))
+end
+
+// FPV-only assertions with symbolic variables
+`ifdef FPV_ON
+  // symbolic variables
+  int unsigned k;
+  bit ReadyIsStable;
+  bit ReqsAreStable;
+
+  // constraints for symbolic variables
+  `ASSUME(KStable_M, ##1 $stable(k))
+  `ASSUME(KRange_M, k < N)
+  // this is used enable checking for stable and unstable ready_i and req_i signals in the same run.
+  // the symbolic variables act like a switch that the solver can trun on and off.
+  `ASSUME(ReadyIsStable_M, ##1 $stable(ReadyIsStable))
+  `ASSUME(ReqsAreStable_M, ##1 $stable(ReqsAreStable))
+  `ASSUME(ReadyStable_M, ##1 !ReadyIsStable || $stable(ready_i))
+  `ASSUME(ReqsStable_M, ##1 !ReqsAreStable || $stable(req_i))
+
+  // A grant implies a request
+  `ASSERT(GntImpliesReq_A, gnt_o[k] |-> req_i[k])
+
+  // if request and ready are constantly held at 1, we should eventually get a grant
+  `ASSERT(NoStarvation_A,
+      ReqsAreStable && ReadyIsStable && ready_i && req_i[k] |->
+      strong(##[0:$] gnt_o[k]))
+
+  // if N requests are constantly asserted and ready is constant 1, each request must
+  // be granted exactly once over a time window of N cycles for the arbiter to be fair.
+  for (genvar n = 1; n <= N; n++) begin : gen_fairness
+    integer gnt_cnt;
+    `ASSERT(Fairness_A,
+        ReqsAreStable && ReadyIsStable && ready_i && req_i[k] &&
+        $countones(req_i) == n |->
+        ##n gnt_cnt == $past(gnt_cnt, n) + 1)
+
+    always_ff @(posedge clk_i or negedge rst_ni) begin : p_cnt
+      if (!rst_ni) begin
+        gnt_cnt <= 0;
+      end else begin
+        gnt_cnt <= gnt_cnt + gnt_o[k];
+      end
+    end
+  end
+
+  if (EnReqStabA) begin : gen_lock_assertion_fpv
+    // requests must stay asserted until they have been granted
+    `ASSUME(ReqStaysHighUntilGranted1_M, req_i[k] & !gnt_o[k] |=>
+        req_i[k], clk_i, !rst_ni)
+  end
+`endif
+
+endmodule : prim_arbiter_ppc
+
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc_n3.sv b/hw/ip/prim/rtl/prim_arbiter_ppc_n3.sv
new file mode 100644
index 000000000..26b4c0908
--- /dev/null
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc_n3.sv
@@ -0,0 +1,225 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// N:1 arbiter module
+//
+// Verilog parameter
+//   N:           Number of request ports
+//   DW:          Data width
+//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
+//   EnReqStabA:  Checks whether requests remain asserted until granted
+//
+// This is the original implementation of the arbiter which relies on parallel prefix computing
+// optimization to optimize the request / arbiter tree. Not all synthesis tools may support this.
+//
+// Note that the currently winning request is held if the data sink is not ready. This behavior is
+// required by some interconnect protocols (AXI, TL). The module contains an assertion that checks
+// this behavior.
+//
+// Also, this module contains a request stability assertion that checks that requests stay asserted
+// until they have been served. This assertion can be optionally disabled by setting EnReqStabA to
+// zero. This is a non-functional parameter and does not affect the designs behavior.
+//
+// See also: prim_arbiter_tree
+
+`include "prim_assert.sv"
+
+module prim_arbiter_ppc_n3 #(
+  parameter int unsigned N  = 3,
+  parameter int unsigned DW = 102,
+
+  // Configurations
+  // EnDataPort: {0, 1}, if 0, input data will be ignored
+  parameter bit EnDataPort = 1,
+
+  // Non-functional parameter to switch on the request stability assertion
+  parameter bit EnReqStabA = 1,
+
+  // Derived parameters
+  localparam int IdxW = $clog2(N)
+) (
+  input clk_i,
+  input rst_ni,
+
+  input        [ N-1:0]    req_i,
+  input        [(0 >= (N - 1) ? ((2 - N) * DW) + (((N - 1) * DW) - 1) : (N * DW) - 1):(0 >= (N - 1) ?(N - 1) * DW : 0)]    data_i,
+  output logic [ N-1:0]    gnt_o,
+  output logic [IdxW-1:0]  idx_o,
+
+  output logic             valid_o,
+  output logic [DW-1:0]    data_o,
+  input                    ready_i
+);
+
+  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
+
+  // this case is basically just a bypass
+  if (N == 1) begin : gen_degenerate_case
+
+    assign valid_o  = req_i[0];
+    assign data_o   = data_i[0];
+    assign gnt_o[0] = valid_o & ready_i;
+    assign idx_o    = '0;
+
+  end else begin : gen_normal_case
+
+    logic [N-1:0] masked_req;
+    logic [N-1:0] ppc_out;
+    logic [N-1:0] arb_req;
+    logic [N-1:0] mask, mask_next;
+    logic [N-1:0] winner;
+
+    assign masked_req = mask & req_i;
+    assign arb_req = (|masked_req) ? masked_req : req_i;
+
+    // PPC
+    //   Even below code looks O(n) but DC optimizes it to O(log(N))
+    //   Using Parallel Prefix Computation
+    always_comb begin
+      ppc_out[0] = arb_req[0];
+      for (int i = 1 ; i < N ; i++) begin
+        ppc_out[i] = ppc_out[i-1] | arb_req[i];
+      end
+    end
+
+    // Grant Generation: Leading-One detector
+    assign winner = ppc_out ^ {ppc_out[N-2:0], 1'b0};
+    assign gnt_o    = (ready_i) ? winner : '0;
+
+    assign valid_o = |req_i;
+    // Mask Generation
+    assign mask_next = {ppc_out[N-2:0], 1'b0};
+    always_ff @(posedge clk_i or negedge rst_ni) begin
+      if (!rst_ni) begin
+        mask <= '0;
+      end else if (valid_o && ready_i) begin
+        // Latch only when requests accepted
+        mask <= mask_next;
+      end else if (valid_o && !ready_i) begin
+        // Downstream isn't yet ready so, keep current request alive. (First come first serve)
+        mask <= ppc_out;
+      end
+    end
+
+    if (EnDataPort == 1) begin: gen_datapath
+      always_comb begin
+        data_o = '0;
+        for (int i = 0 ; i < N ; i++) begin
+          if (winner[i]) begin
+            data_o = data_i[(0 >= (N - 1) ? i : (N - 1) - i) * DW+:DW];
+          end
+        end
+      end
+    end else begin: gen_nodatapath
+      assign data_o = '1;
+      // TODO: waive data_i from NOT_READ error
+    end
+
+    always_comb begin
+      idx_o = '0;
+      for (int i = 0 ; i < N ; i++) begin
+        if (winner[i]) begin
+          idx_o = i[IdxW-1:0];
+        end
+      end
+    end
+  end
+
+  ////////////////
+  // assertions //
+  ////////////////
+
+  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
+  // e.g. when used on a BUS
+  `ASSERT_KNOWN(ValidKnown_A, valid_o)
+  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
+  `ASSERT_KNOWN(IdxKnown_A, idx_o)
+
+  // grant index shall be higher index than previous index, unless no higher requests exist.
+  `ASSERT(RoundRobin_A,
+      ##1 valid_o && ready_i && $past(ready_i) && $past(valid_o) &&
+      |(req_i & ~((N'(1) << $past(idx_o)+1) - 1)) |->
+      idx_o > $past(idx_o))
+  // we can only grant one requestor at a time
+  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
+  // A grant implies that the sink is ready
+  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
+  // A grant implies that the arbiter asserts valid as well
+  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
+  // Both conditions above combined and reversed
+  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
+  // Both conditions above combined and reversed
+  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
+  // check index / grant correspond
+  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
+
+if (EnDataPort) begin: gen_data_port_assertion
+  // data flow
+  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
+end
+
+if (EnReqStabA) begin : gen_lock_assertion
+  // requests must stay asserted until they have been granted
+  `ASSUME(ReqStaysHighUntilGranted0_M, (|req_i) && !ready_i |=>
+      (req_i & $past(req_i)) == $past(req_i))
+  // check that the arbitration decision is held if the sink is not ready
+  `ASSERT(LockArbDecision_A, |req_i && !ready_i |=> idx_o == $past(idx_o))
+end
+
+// FPV-only assertions with symbolic variables
+`ifdef FPV_ON
+  // symbolic variables
+  int unsigned k;
+  bit ReadyIsStable;
+  bit ReqsAreStable;
+
+  // constraints for symbolic variables
+  `ASSUME(KStable_M, ##1 $stable(k))
+  `ASSUME(KRange_M, k < N)
+  // this is used enable checking for stable and unstable ready_i and req_i signals in the same run.
+  // the symbolic variables act like a switch that the solver can trun on and off.
+  `ASSUME(ReadyIsStable_M, ##1 $stable(ReadyIsStable))
+  `ASSUME(ReqsAreStable_M, ##1 $stable(ReqsAreStable))
+  `ASSUME(ReadyStable_M, ##1 !ReadyIsStable || $stable(ready_i))
+  `ASSUME(ReqsStable_M, ##1 !ReqsAreStable || $stable(req_i))
+
+  // A grant implies a request
+  `ASSERT(GntImpliesReq_A, gnt_o[k] |-> req_i[k])
+
+  // if request and ready are constantly held at 1, we should eventually get a grant
+  `ASSERT(NoStarvation_A,
+      ReqsAreStable && ReadyIsStable && ready_i && req_i[k] |->
+      strong(##[0:$] gnt_o[k]))
+
+  // if N requests are constantly asserted and ready is constant 1, each request must
+  // be granted exactly once over a time window of N cycles for the arbiter to be fair.
+  for (genvar n = 1; n <= N; n++) begin : gen_fairness
+    integer gnt_cnt;
+    `ASSERT(Fairness_A,
+        ReqsAreStable && ReadyIsStable && ready_i && req_i[k] &&
+        $countones(req_i) == n |->
+        ##n gnt_cnt == $past(gnt_cnt, n) + 1)
+
+    always_ff @(posedge clk_i or negedge rst_ni) begin : p_cnt
+      if (!rst_ni) begin
+        gnt_cnt <= 0;
+      end else begin
+        gnt_cnt <= gnt_cnt + gnt_o[k];
+      end
+    end
+  end
+
+  if (EnReqStabA) begin : gen_lock_assertion_fpv
+    // requests must stay asserted until they have been granted
+    `ASSUME(ReqStaysHighUntilGranted1_M, req_i[k] & !gnt_o[k] |=>
+        req_i[k], clk_i, !rst_ni)
+  end
+`endif
+
+endmodule : prim_arbiter_ppc
+
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc_surelog.sv b/hw/ip/prim/rtl/prim_arbiter_ppc_surelog.sv
new file mode 100644
index 000000000..af3ca8939
--- /dev/null
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc_surelog.sv
@@ -0,0 +1,226 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// N:1 arbiter module
+//
+// Verilog parameter
+//   N:           Number of request ports
+//   DW:          Data width
+//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
+//   EnReqStabA:  Checks whether requests remain asserted until granted
+//
+// This is the original implementation of the arbiter which relies on parallel prefix computing
+// optimization to optimize the request / arbiter tree. Not all synthesis tools may support this.
+//
+// Note that the currently winning request is held if the data sink is not ready. This behavior is
+// required by some interconnect protocols (AXI, TL). The module contains an assertion that checks
+// this behavior.
+//
+// Also, this module contains a request stability assertion that checks that requests stay asserted
+// until they have been served. This assertion can be optionally disabled by setting EnReqStabA to
+// zero. This is a non-functional parameter and does not affect the designs behavior.
+//
+// See also: prim_arbiter_tree
+
+`include "prim_assert.sv"
+
+module prim_arbiter_ppc_surelog #(
+  parameter int unsigned N  = 8,
+  parameter int unsigned DW = 32,
+
+  // Configurations
+  // EnDataPort: {0, 1}, if 0, input data will be ignored
+  parameter bit EnDataPort = 1,
+
+  // Non-functional parameter to switch on the request stability assertion
+  parameter bit EnReqStabA = 1,
+
+  // Derived parameters
+  localparam int IdxW = $clog2(N)
+) (
+  input clk_i,
+  input rst_ni,
+
+  input        [ N-1:0]    req_i,
+  input        [DW-1:0]    data_i [N],
+  output logic [ N-1:0]    gnt_o,
+  output logic [IdxW-1:0]  idx_o,
+
+  output logic             valid_o,
+  output logic [DW-1:0]    data_o,
+  input                    ready_i
+);
+
+  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
+
+  // this case is basically just a bypass
+  if (N == 1) begin : gen_degenerate_case
+
+    assign valid_o  = req_i[0];
+    assign data_o   = data_i[0];
+    assign gnt_o[0] = valid_o & ready_i;
+    assign idx_o    = '0;
+
+  end else begin : gen_normal_case
+
+    logic [N-1:0] masked_req;
+    logic [N-1:0] ppc_out;
+    logic [N-1:0] arb_req;
+    logic [N-1:0] mask, mask_next;
+    logic [N-1:0] winner;
+
+    assign masked_req = mask & req_i;
+    assign arb_req = (|masked_req) ? masked_req : req_i;
+
+    // PPC
+    //   Even below code looks O(n) but DC optimizes it to O(log(N))
+    //   Using Parallel Prefix Computation
+    always_comb begin
+      ppc_out[0] = arb_req[0];
+      for (int i = 1 ; i < N ; i++) begin
+        ppc_out[i] = ppc_out[i-1] | arb_req[i];
+      end
+    end
+
+    // Grant Generation: Leading-One detector
+    assign winner = ppc_out ^ {ppc_out[N-2:0], 1'b0};
+    assign gnt_o    = (ready_i) ? winner : '0;
+
+    assign valid_o = |req_i;
+    // Mask Generation
+    assign mask_next = {ppc_out[N-2:0], 1'b0};
+    always_ff @(posedge clk_i or negedge rst_ni) begin
+      if (!rst_ni) begin
+        mask <= '0;
+      end else if (valid_o && ready_i) begin
+        // Latch only when requests accepted
+        mask <= mask_next;
+      end else if (valid_o && !ready_i) begin
+        // Downstream isn't yet ready so, keep current request alive. (First come first serve)
+        mask <= ppc_out;
+      end
+    end
+
+    if (EnDataPort == 1) begin: gen_datapath
+      always_comb begin
+        data_o = '0;
+        for (int i = 0 ; i < N ; i++) begin
+          if (winner[i]) begin
+            data_o = data_i[i];
+          end
+        end
+      end
+    end else begin: gen_nodatapath
+      assign data_o = '1;
+      // The following signal is used to avoid possible lint errors.
+      logic [DW-1:0] unused_data [N];
+      assign unused_data = data_i;
+    end
+
+    always_comb begin
+      idx_o = '0;
+      for (int unsigned i = 0 ; i < N ; i++) begin
+        if (winner[i]) begin
+          idx_o = i[IdxW-1:0];
+        end
+      end
+    end
+  end
+
+  ////////////////
+  // assertions //
+  ////////////////
+
+  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
+  // e.g. when used on a BUS
+  `ASSERT_KNOWN(ValidKnown_A, valid_o)
+  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
+  `ASSERT_KNOWN(IdxKnown_A, idx_o)
+
+  // grant index shall be higher index than previous index, unless no higher requests exist.
+  `ASSERT(RoundRobin_A,
+      ##1 valid_o && ready_i && $past(ready_i) && $past(valid_o) &&
+      |(req_i & ~((N'(1) << $past(idx_o)+1) - 1)) |->
+      idx_o > $past(idx_o))
+  // we can only grant one requestor at a time
+  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
+  // A grant implies that the sink is ready
+  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
+  // A grant implies that the arbiter asserts valid as well
+  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
+  // A request and a sink that is ready imply a grant
+  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
+  // Both conditions above combined and reversed
+  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
+  // Both conditions above combined and reversed
+  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
+  // check index / grant correspond
+  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
+
+if (EnDataPort) begin: gen_data_port_assertion
+  // data flow
+  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
+end
+
+if (EnReqStabA) begin : gen_lock_assertion
+  // requests must stay asserted until they have been granted
+  `ASSUME(ReqStaysHighUntilGranted0_M, (|req_i) && !ready_i |=>
+      (req_i & $past(req_i)) == $past(req_i))
+  // check that the arbitration decision is held if the sink is not ready
+  `ASSERT(LockArbDecision_A, |req_i && !ready_i |=> idx_o == $past(idx_o))
+end
+
+// FPV-only assertions with symbolic variables
+`ifdef FPV_ON
+  // symbolic variables
+  int unsigned k;
+  bit ReadyIsStable;
+  bit ReqsAreStable;
+
+  // constraints for symbolic variables
+  `ASSUME(KStable_M, ##1 $stable(k))
+  `ASSUME(KRange_M, k < N)
+  // this is used enable checking for stable and unstable ready_i and req_i signals in the same run.
+  // the symbolic variables act like a switch that the solver can trun on and off.
+  `ASSUME(ReadyIsStable_M, ##1 $stable(ReadyIsStable))
+  `ASSUME(ReqsAreStable_M, ##1 $stable(ReqsAreStable))
+  `ASSUME(ReadyStable_M, ##1 !ReadyIsStable || $stable(ready_i))
+  `ASSUME(ReqsStable_M, ##1 !ReqsAreStable || $stable(req_i))
+
+  // A grant implies a request
+  `ASSERT(GntImpliesReq_A, gnt_o[k] |-> req_i[k])
+
+  // if request and ready are constantly held at 1, we should eventually get a grant
+  `ASSERT(NoStarvation_A,
+      ReqsAreStable && ReadyIsStable && ready_i && req_i[k] |->
+      strong(##[0:$] gnt_o[k]))
+
+  // if N requests are constantly asserted and ready is constant 1, each request must
+  // be granted exactly once over a time window of N cycles for the arbiter to be fair.
+  for (genvar n = 1; n <= N; n++) begin : gen_fairness
+    integer gnt_cnt;
+    `ASSERT(Fairness_A,
+        ReqsAreStable && ReadyIsStable && ready_i && req_i[k] &&
+        $countones(req_i) == n |->
+        ##n gnt_cnt == $past(gnt_cnt, n) + 1)
+
+    always_ff @(posedge clk_i or negedge rst_ni) begin : p_cnt
+      if (!rst_ni) begin
+        gnt_cnt <= 0;
+      end else begin
+        gnt_cnt <= gnt_cnt + gnt_o[k];
+      end
+    end
+  end
+
+  if (EnReqStabA) begin : gen_lock_assertion_fpv
+    // requests must stay asserted until they have been granted
+    `ASSUME(ReqStaysHighUntilGranted1_M, req_i[k] & !gnt_o[k] |=>
+        req_i[k], clk_i, !rst_ni)
+  end
+`endif
+
+endmodule : prim_arbiter_ppc
diff --git a/hw/ip/prim/rtl/prim_diff_decode.sv b/hw/ip/prim/rtl/prim_diff_decode.sv
index c06a77d77..8c9db0c61 100644
--- a/hw/ip/prim/rtl/prim_diff_decode.sv
+++ b/hw/ip/prim/rtl/prim_diff_decode.sv
@@ -42,9 +42,9 @@ module prim_diff_decode #(
   ///////////////////////////////////////////////////////////////
   // synchronization regs for incoming diff pair (if required) //
   ///////////////////////////////////////////////////////////////
+  typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
   if (AsyncOn) begin : gen_async
 
-    typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
     state_e state_d, state_q;
     logic diff_p_edge, diff_n_edge, diff_check_ok, level;
 
diff --git a/hw/ip/prim/rtl/prim_fifo_async_surelog.sv b/hw/ip/prim/rtl/prim_fifo_async_surelog.sv
new file mode 100644
index 000000000..e6a1ebf50
--- /dev/null
+++ b/hw/ip/prim/rtl/prim_fifo_async_surelog.sv
@@ -0,0 +1,158 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// Generic asynchronous fifo for use in a variety of devices.
+
+`include "prim_assert.sv"
+
+module prim_fifo_async_surelog #(
+  parameter  int unsigned Width  = 16,
+  parameter  int unsigned Depth  = 3,
+  localparam int unsigned DepthW = $clog2(Depth+1) // derived parameter representing [0..Depth]
+) (
+	input clk_wr_i,
+	input rst_wr_ni,
+	input wvalid_i,
+	output wready_o,
+	input [Width - 1:0] wdata_i,
+	output [DepthW - 1:0] wdepth_o,
+	input clk_rd_i,
+	input rst_rd_ni,
+	output rvalid_o,
+	input rready_i,
+	output [Width - 1:0] rdata_o,
+	output [DepthW - 1:0] rdepth_o
+);
+	localparam [31:0] PTRV_W = $clog2(Depth);
+	function automatic [PTRV_W - 1:0] sv2v_cast_E27C2;
+		input reg [PTRV_W - 1:0] inp;
+		sv2v_cast_E27C2 = inp;
+	endfunction
+	function automatic [PTR_WIDTH - 1:0] dec2gray(input reg [PTR_WIDTH - 1:0] decval);
+		reg [PTR_WIDTH - 1:0] decval_sub;
+		reg [PTR_WIDTH - 2:0] decval_in;
+		reg unused_decval_msb;
+		begin
+			decval_sub = (Depth - {1'b0, decval[PTR_WIDTH - 2:0]}) - 1'b1;
+			{unused_decval_msb, decval_in} = (decval[PTR_WIDTH - 1] ? decval_sub : decval);
+			dec2gray = {decval[PTR_WIDTH - 1], {1'b0, decval_in[PTR_WIDTH - 2:1]} ^ decval_in[PTR_WIDTH - 2:0]};
+		end
+	endfunction
+	function automatic [PTR_WIDTH - 1:0] gray2dec(input reg [PTR_WIDTH - 1:0] grayval);
+		reg [PTR_WIDTH - 2:0] dec_tmp;
+		reg [PTR_WIDTH - 2:0] dec_tmp_sub;
+		reg unused_decsub_msb;
+		begin
+			dec_tmp[PTR_WIDTH - 2] = grayval[PTR_WIDTH - 2];
+			begin : sv2v_autoblock_1
+				reg signed [31:0] i;
+				for (i = PTR_WIDTH - 3; i >= 0; i = i - 1)
+					dec_tmp[i] = dec_tmp[i + 1] ^ grayval[i];
+			end
+			{unused_decsub_msb, dec_tmp_sub} = (Depth - {1'b0, dec_tmp}) - 1'b1;
+			if (grayval[PTR_WIDTH - 1])
+				gray2dec = {1'b1, dec_tmp_sub};
+			else
+				gray2dec = {1'b0, dec_tmp};
+		end
+	endfunction
+	function automatic [DepthW - 1:0] sv2v_cast_703F8(input reg [DepthW - 1:0] inp);
+		sv2v_cast_703F8 = inp;
+	endfunction
+	localparam [PTRV_W - 1:0] DepthMinus1 = sv2v_cast_E27C2(Depth - 1);
+	localparam [31:0] PTR_WIDTH = PTRV_W + 1;
+	reg [PTR_WIDTH - 1:0] fifo_wptr;
+	reg [PTR_WIDTH - 1:0] fifo_rptr;
+	wire [PTR_WIDTH - 1:0] fifo_wptr_sync_combi;
+	reg [PTR_WIDTH - 1:0] fifo_rptr_sync;
+	wire [PTR_WIDTH - 1:0] fifo_wptr_gray_sync;
+	wire [PTR_WIDTH - 1:0] fifo_rptr_gray_sync;
+	reg [PTR_WIDTH - 1:0] fifo_wptr_gray;
+	reg [PTR_WIDTH - 1:0] fifo_rptr_gray;
+	wire fifo_incr_wptr;
+	wire fifo_incr_rptr;
+	wire empty;
+	wire full_wclk;
+	wire full_rclk;
+	assign wready_o = !full_wclk;
+	assign rvalid_o = !empty;
+	assign fifo_incr_wptr = wvalid_i & wready_o;
+	assign fifo_incr_rptr = rvalid_o & rready_i;
+	always @(posedge clk_wr_i or negedge rst_wr_ni)
+		if (!rst_wr_ni)
+			fifo_wptr <= {PTR_WIDTH {1'b0}};
+		else if (fifo_incr_wptr)
+			if (fifo_wptr[PTR_WIDTH - 2:0] == DepthMinus1)
+				fifo_wptr <= {~fifo_wptr[PTR_WIDTH - 1], {PTR_WIDTH - 1 {1'b0}}};
+			else
+				fifo_wptr <= fifo_wptr + {{PTR_WIDTH - 1 {1'b0}}, 1'b1};
+	always @(posedge clk_wr_i or negedge rst_wr_ni)
+		if (!rst_wr_ni)
+			fifo_wptr_gray <= {PTR_WIDTH {1'b0}};
+		else if (fifo_incr_wptr)
+			if (fifo_wptr[PTR_WIDTH - 2:0] == DepthMinus1)
+				fifo_wptr_gray <= dec2gray({~fifo_wptr[PTR_WIDTH - 1], {PTR_WIDTH - 1 {1'b0}}});
+			else
+				fifo_wptr_gray <= dec2gray(fifo_wptr + {{PTR_WIDTH - 1 {1'b0}}, 1'b1});
+	prim_flop_2sync #(.Width(PTR_WIDTH)) sync_wptr(
+		.clk_i(clk_rd_i),
+		.rst_ni(rst_rd_ni),
+		.d_i(fifo_wptr_gray),
+		.q_o(fifo_wptr_gray_sync)
+	);
+	assign fifo_wptr_sync_combi = gray2dec(fifo_wptr_gray_sync);
+	always @(posedge clk_rd_i or negedge rst_rd_ni)
+		if (!rst_rd_ni)
+			fifo_rptr <= {PTR_WIDTH {1'b0}};
+		else if (fifo_incr_rptr)
+			if (fifo_rptr[PTR_WIDTH - 2:0] == DepthMinus1)
+				fifo_rptr <= {~fifo_rptr[PTR_WIDTH - 1], {PTR_WIDTH - 1 {1'b0}}};
+			else
+				fifo_rptr <= fifo_rptr + {{PTR_WIDTH - 1 {1'b0}}, 1'b1};
+	always @(posedge clk_rd_i or negedge rst_rd_ni)
+		if (!rst_rd_ni)
+			fifo_rptr_gray <= {PTR_WIDTH {1'b0}};
+		else if (fifo_incr_rptr)
+			if (fifo_rptr[PTR_WIDTH - 2:0] == DepthMinus1)
+				fifo_rptr_gray <= dec2gray({~fifo_rptr[PTR_WIDTH - 1], {PTR_WIDTH - 1 {1'b0}}});
+			else
+				fifo_rptr_gray <= dec2gray(fifo_rptr + {{PTR_WIDTH - 1 {1'b0}}, 1'b1});
+	prim_flop_2sync #(.Width(PTR_WIDTH)) sync_rptr(
+		.clk_i(clk_wr_i),
+		.rst_ni(rst_wr_ni),
+		.d_i(fifo_rptr_gray),
+		.q_o(fifo_rptr_gray_sync)
+	);
+	always @(posedge clk_wr_i or negedge rst_wr_ni)
+		if (!rst_wr_ni)
+			fifo_rptr_sync <= {PTR_WIDTH {1'b0}};
+		else
+			fifo_rptr_sync <= gray2dec(fifo_rptr_gray_sync);
+	assign full_wclk = fifo_wptr == (fifo_rptr_sync ^ {1'b1, {PTR_WIDTH - 1 {1'b0}}});
+	assign full_rclk = fifo_wptr_sync_combi == (fifo_rptr ^ {1'b1, {PTR_WIDTH - 1 {1'b0}}});
+	wire wptr_msb;
+	wire rptr_sync_msb;
+	wire [PTRV_W - 1:0] wptr_value;
+	wire [PTRV_W - 1:0] rptr_sync_value;
+	assign wptr_msb = fifo_wptr[PTR_WIDTH - 1];
+	assign rptr_sync_msb = fifo_rptr_sync[PTR_WIDTH - 1];
+	assign wptr_value = fifo_wptr[0+:PTRV_W];
+	assign rptr_sync_value = fifo_rptr_sync[0+:PTRV_W];
+	assign wdepth_o = (full_wclk ? sv2v_cast_703F8(Depth) : (wptr_msb == rptr_sync_msb ? sv2v_cast_703F8(wptr_value) - sv2v_cast_703F8(rptr_sync_value) : (sv2v_cast_703F8(Depth) - sv2v_cast_703F8(rptr_sync_value)) + sv2v_cast_703F8(wptr_value)));
+	assign empty = fifo_wptr_sync_combi == fifo_rptr;
+	wire rptr_msb;
+	wire wptr_sync_msb;
+	wire [PTRV_W - 1:0] rptr_value;
+	wire [PTRV_W - 1:0] wptr_sync_value;
+	assign wptr_sync_msb = fifo_wptr_sync_combi[PTR_WIDTH - 1];
+	assign rptr_msb = fifo_rptr[PTR_WIDTH - 1];
+	assign wptr_sync_value = fifo_wptr_sync_combi[0+:PTRV_W];
+	assign rptr_value = fifo_rptr[0+:PTRV_W];
+	assign rdepth_o = (full_rclk ? sv2v_cast_703F8(Depth) : (wptr_sync_msb == rptr_msb ? sv2v_cast_703F8(wptr_sync_value) - sv2v_cast_703F8(rptr_value) : (sv2v_cast_703F8(Depth) - sv2v_cast_703F8(rptr_value)) + sv2v_cast_703F8(wptr_sync_value)));
+	reg [Width - 1:0] storage [0:Depth - 1];
+	always @(posedge clk_wr_i)
+		if (fifo_incr_wptr)
+			storage[fifo_wptr[PTR_WIDTH - 2:0]] <= wdata_i;
+	assign rdata_o = storage[fifo_rptr[PTR_WIDTH - 2:0]];
+endmodule
diff --git a/hw/ip/prim/rtl/prim_prince.sv b/hw/ip/prim/rtl/prim_prince.sv
index 423a7ca21..cb790a861 100644
--- a/hw/ip/prim/rtl/prim_prince.sv
+++ b/hw/ip/prim/rtl/prim_prince.sv
@@ -48,7 +48,7 @@ module prim_prince #(
   output logic                 valid_o,
   output logic [DataWidth-1:0] data_o
 );
-
+  import prim_cipher_pkg::*;
   ///////////////////
   // key expansion //
   ///////////////////
@@ -63,7 +63,7 @@ module prim_prince #(
     if (dec_i) begin
       k0          = k0_prime_d;
       k0_prime_d  = key_i[DataWidth-1:0];
-      k1_d       ^= prim_cipher_pkg::PRINCE_ALPHA_CONST[DataWidth-1:0];
+      k1_d       ^= PRINCE_ALPHA_CONST[DataWidth-1:0];
     end
   end
 
@@ -106,7 +106,7 @@ module prim_prince #(
   always_comb begin : p_pre_round_xor
     data_state[0] = data_i ^ k0;
     data_state[0] ^= k1_d;
-    data_state[0] ^= prim_cipher_pkg::PRINCE_ROUND_CONST[0][DataWidth-1:0];
+    data_state[0] ^= PRINCE_ROUND_CONST[0][DataWidth-1:0];
   end
 
   // forward pass
@@ -114,24 +114,24 @@ module prim_prince #(
     logic [DataWidth-1:0] data_state_round;
     if (DataWidth == 64) begin : gen_fwd_d64
       always_comb begin : p_fwd_d64
-        data_state_round = prim_cipher_pkg::sbox4_64bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_64bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_64bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_64bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_64bit(data_state_round);
+        data_state_round = prince_shiftrows_64bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end else begin : gen_fwd_d32
       always_comb begin : p_fwd_d32
-        data_state_round = prim_cipher_pkg::sbox4_32bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_32bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_32bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_32bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_32bit(data_state_round);
+        data_state_round = prince_shiftrows_32bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end
     logic [DataWidth-1:0] data_state_xor;
     assign data_state_xor = data_state_round ^
-                            prim_cipher_pkg::PRINCE_ROUND_CONST[k][DataWidth-1:0];
+                            PRINCE_ROUND_CONST[k][DataWidth-1:0];
     // improved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
     if (k % 2 == 1) assign data_state[k]  = data_state_xor ^ k0_new_d;
     else            assign data_state[k]  = data_state_xor ^ k1_d;
@@ -141,19 +141,19 @@ module prim_prince #(
   logic [DataWidth-1:0] data_state_middle_d, data_state_middle_q, data_state_middle;
   if (DataWidth == 64) begin : gen_middle_d64
     always_comb begin : p_middle_d64
-      data_state_middle_d = prim_cipher_pkg::sbox4_64bit(data_state[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_64bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_64bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_64bit(data_state[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_64bit(data_state_middle_q);
+      data_state_middle = sbox4_64bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end else begin : gen_middle_d32
     always_comb begin : p_middle_d32
-      data_state_middle_d = prim_cipher_pkg::sbox4_32bit(data_state_middle[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_32bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_32bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_32bit(data_state_middle[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_32bit(data_state_middle_q);
+      data_state_middle = sbox4_32bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end
 
@@ -187,24 +187,24 @@ module prim_prince #(
     else            assign data_state_xor0 = data_state[NumRoundsHalf+k] ^ k1_q;
     // the construction is reflective, hence the subtraction with NumRoundsHalf
     assign data_state_xor1 = data_state_xor0 ^
-                             prim_cipher_pkg::PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
+                             PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
 
     logic [DataWidth-1:0] data_state_bwd;
     if (DataWidth == 64) begin : gen_bwd_d64
       always_comb begin : p_bwd_d64
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_64bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_64bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_64bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_64bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_64bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_64bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end else begin : gen_bwd_d32
       always_comb begin : p_bwd_d32
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_32bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_32bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_32bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_32bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_32bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_32bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end
   end
@@ -212,7 +212,7 @@ module prim_prince #(
   // post-rounds
   always_comb begin : p_post_round_xor
     data_o  = data_state[2*NumRoundsHalf+1] ^
-              prim_cipher_pkg::PRINCE_ROUND_CONST[11][DataWidth-1:0];
+              PRINCE_ROUND_CONST[11][DataWidth-1:0];
     data_o ^= k1_q;
     data_o ^= k0_prime_q;
   end
diff --git a/hw/ip/prim/rtl/prim_ram_2p_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
index c6b466982..d34b942cd 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input                    clk_i,
   input                    rst_ni,
@@ -36,18 +36,18 @@ module prim_ram_2p_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -55,8 +55,8 @@ module prim_ram_2p_adv #(
 );
 
   prim_ram_2p_async_adv #(
-    .Depth               (Depth),
-    .Width               (Width),
+    .RamDepth               (RamDepth),
+    .RamWidth               (RamWidth),
     .DataBitsPerMask     (DataBitsPerMask),
     .CfgW                (CfgW),
     .MemInitFile         (MemInitFile),
diff --git a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
index 8436345d7..06efc7aca 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_async_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_async_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input clk_a_i,
   input clk_b_i,
@@ -38,18 +38,18 @@ module prim_ram_2p_async_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -67,14 +67,14 @@ module prim_ram_2p_async_adv #(
   localparam int LocalDataBitsPerMask = (EnableParity) ? 1 : DataBitsPerMask;
 
   // Calculate ECC width
-  localparam int ParWidth  = (EnableParity) ? Width/8 :
+  localparam int ParRamWidth  = (EnableParity) ? RamWidth/8 :
                              (!EnableECC)   ? 0 :
-                             (Width <=   4) ? 4 :
-                             (Width <=  11) ? 5 :
-                             (Width <=  26) ? 6 :
-                             (Width <=  57) ? 7 :
-                             (Width <= 120) ? 8 : 8 ;
-  localparam int TotalWidth = Width + ParWidth;
+                             (RamWidth <=   4) ? 4 :
+                             (RamWidth <=  11) ? 5 :
+                             (RamWidth <=  26) ? 6 :
+                             (RamWidth <=  57) ? 7 :
+                             (RamWidth <= 120) ? 8 : 8 ;
+  localparam int TotalRamWidth = RamWidth + ParRamWidth;
 
   ////////////////////////////
   // RAM Primitive Instance //
@@ -83,28 +83,28 @@ module prim_ram_2p_async_adv #(
   logic                    a_req_q,    a_req_d ;
   logic                    a_write_q,  a_write_d ;
   logic [Aw-1:0]           a_addr_q,   a_addr_d ;
-  logic [TotalWidth-1:0]   a_wdata_q,  a_wdata_d ;
-  logic [TotalWidth-1:0]   a_wmask_q,  a_wmask_d ;
+  logic [TotalRamWidth-1:0]   a_wdata_q,  a_wdata_d ;
+  logic [TotalRamWidth-1:0]   a_wmask_q,  a_wmask_d ;
   logic                    a_rvalid_q, a_rvalid_d, a_rvalid_sram ;
-  logic [Width-1:0]        a_rdata_q,  a_rdata_d ;
-  logic [TotalWidth-1:0]   a_rdata_sram ;
+  logic [RamWidth-1:0]        a_rdata_q,  a_rdata_d ;
+  logic [TotalRamWidth-1:0]   a_rdata_sram ;
   logic [1:0]              a_rerror_q, a_rerror_d ;
 
   logic                    b_req_q,    b_req_d ;
   logic                    b_write_q,  b_write_d ;
   logic [Aw-1:0]           b_addr_q,   b_addr_d ;
-  logic [TotalWidth-1:0]   b_wdata_q,  b_wdata_d ;
-  logic [TotalWidth-1:0]   b_wmask_q,  b_wmask_d ;
+  logic [TotalRamWidth-1:0]   b_wdata_q,  b_wdata_d ;
+  logic [TotalRamWidth-1:0]   b_wmask_q,  b_wmask_d ;
   logic                    b_rvalid_q, b_rvalid_d, b_rvalid_sram ;
-  logic [Width-1:0]        b_rdata_q,  b_rdata_d ;
-  logic [TotalWidth-1:0]   b_rdata_sram ;
+  logic [RamWidth-1:0]        b_rdata_q,  b_rdata_d ;
+  logic [TotalRamWidth-1:0]   b_rdata_sram ;
   logic [1:0]              b_rerror_q, b_rerror_d ;
 
   prim_ram_2p #(
     .MemInitFile     (MemInitFile),
 
-    .Width           (TotalWidth),
-    .Depth           (Depth),
+    .Width           (TotalRamWidth),
+    .Depth           (RamDepth),
     .DataBitsPerMask (LocalDataBitsPerMask)
   ) u_mem (
     .clk_a_i    (clk_a_i),
@@ -161,29 +161,29 @@ module prim_ram_2p_async_adv #(
   if (EnableParity == 0 && EnableECC) begin : gen_secded
 
     // check supported widths
-    `ASSERT_INIT(SecDecWidth_A, Width inside {32})
+    `ASSERT_INIT(SecDecRamWidth_A, RamWidth inside {32})
 
     // the wmask is constantly set to 1 in this case
     `ASSERT(OnlyWordWritePossibleWithEccPortA_A, a_req_i |->
-        a_wmask_i == {TotalWidth{1'b1}}, clk_a_i, rst_a_ni)
+        a_wmask_i == {TotalRamWidth{1'b1}}, clk_a_i, rst_a_ni)
     `ASSERT(OnlyWordWritePossibleWithEccPortB_A, b_req_i |->
-        b_wmask_i == {TotalWidth{1'b1}}, clk_b_i, rst_b_ni)
+        b_wmask_i == {TotalRamWidth{1'b1}}, clk_b_i, rst_b_ni)
 
-    assign a_wmask_d = {TotalWidth{1'b1}};
-    assign b_wmask_d = {TotalWidth{1'b1}};
+    assign a_wmask_d = {TotalRamWidth{1'b1}};
+    assign b_wmask_d = {TotalRamWidth{1'b1}};
 
-    if (Width == 32) begin : gen_secded_39_32
+    if (RamWidth == 32) begin : gen_secded_39_32
       prim_secded_39_32_enc u_enc_a (.in(a_wdata_i), .out(a_wdata_d));
       prim_secded_39_32_dec u_dec_a (
         .in         (a_rdata_sram),
-        .d_o        (a_rdata_d[0+:Width]),
+        .d_o        (a_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (a_rerror_d)
       );
       prim_secded_39_32_enc u_enc_b (.in(b_wdata_i), .out(b_wdata_d));
       prim_secded_39_32_dec u_dec_b (
         .in         (b_rdata_sram),
-        .d_o        (b_rdata_d[0+:Width]),
+        .d_o        (b_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (b_rerror_d)
       );
@@ -191,40 +191,40 @@ module prim_ram_2p_async_adv #(
   end else if (EnableParity) begin : gen_byte_parity
 
     `ASSERT_INIT(ParityNeedsByteWriteMask_A, DataBitsPerMask == 8)
-    `ASSERT_INIT(WidthNeedsToBeByteAligned_A, Width % 8 == 0)
+    `ASSERT_INIT(RamWidthNeedsToBeByteAligned_A, RamWidth % 8 == 0)
 
     always_comb begin : p_parity
       a_rerror_d = '0;
       b_rerror_d = '0;
-      a_wmask_d[0+:Width] = a_wmask_i;
-      b_wmask_d[0+:Width] = b_wmask_i;
-      a_wdata_d[0+:Width] = a_wdata_i;
-      b_wdata_d[0+:Width] = b_wdata_i;
+      a_wmask_d[0+:RamWidth] = a_wmask_i;
+      b_wmask_d[0+:RamWidth] = b_wmask_i;
+      a_wdata_d[0+:RamWidth] = a_wdata_i;
+      b_wdata_d[0+:RamWidth] = b_wdata_i;
 
-      for (int i = 0; i < Width/8; i ++) begin
+      for (int i = 0; i < RamWidth/8; i ++) begin
         // parity generation (odd parity)
-        a_wdata_d[Width + i] = ~(^a_wdata_i[i*8 +: 8]);
-        b_wdata_d[Width + i] = ~(^b_wdata_i[i*8 +: 8]);
-        a_wmask_d[Width + i] = &a_wmask_i[i*8 +: 8];
-        b_wmask_d[Width + i] = &b_wmask_i[i*8 +: 8];
+        a_wdata_d[RamWidth + i] = ~(^a_wdata_i[i*8 +: 8]);
+        b_wdata_d[RamWidth + i] = ~(^b_wdata_i[i*8 +: 8]);
+        a_wmask_d[RamWidth + i] = &a_wmask_i[i*8 +: 8];
+        b_wmask_d[RamWidth + i] = &b_wmask_i[i*8 +: 8];
         // parity decoding (errors are always uncorrectable)
-        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[Width + i]});
-        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[Width + i]});
+        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[RamWidth + i]});
+        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[RamWidth + i]});
       end
       // tie to zero if the read data is not valid
       a_rerror_d &= {2{a_rvalid_sram}};
       b_rerror_d &= {2{b_rvalid_sram}};
     end
 
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
   end else begin : gen_nosecded_noparity
     assign a_wmask_d  = a_wmask_i;
     assign b_wmask_d  = b_wmask_i;
     assign a_wdata_d  = a_wdata_i;
     assign b_wdata_d  = b_wdata_i;
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
     assign a_rerror_d = '0;
     assign b_rerror_d = '0;
   end
diff --git a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
index 962d3b559..d6430bc5a 100644
--- a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
+++ b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
@@ -70,10 +70,10 @@ module prim_generic_pad_wrapper #(
     assign oe       = oe_i & ((od & ~out) | ~od);
 
   // driving strength attributes are not supported by verilator
-`ifdef VERILATOR
-    assign inout_io = (oe)   ? out : 1'bz;
+`ifdef SYNTHESIS
+    assign inout_io = out;
     // received data driver
-    assign in_o     = (ie_i) ? in  : 1'bz;
+    assign in_o     = in;
 `else
     // different driver types
     assign (strong0, strong1) inout_io = (oe && drv != DRIVE_00) ? out : 1'bz;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
index c4ccd9b2d..5229b6a82 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
@@ -54,6 +54,8 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
 
 );
 
+  import pwrmgr_pkg::*;
+
   ////////////////////////////////
   // Sync from clk_i to clk_slow_i
   ////////////////////////////////
@@ -137,11 +139,11 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
   // only register configurations can be sync'd using slow_cdc_sync
   always_ff @(posedge clk_slow_i or negedge rst_slow_ni) begin
     if (!rst_slow_ni) begin
-      slow_wakeup_en_o <= '0;
-      slow_reset_en_o <= '0;
-      slow_main_pd_no <= '0;
-      slow_io_clk_en_o <= '0;
-      slow_core_clk_en_o <= '0;
+      slow_wakeup_en_o <= 16'h0000;
+      slow_reset_en_o <= 2'b00;
+      slow_main_pd_no <= 1'b0;
+      slow_io_clk_en_o <= 1'b0;
+      slow_core_clk_en_o <= 1'b0;
     end else if (slow_cdc_sync) begin
       slow_wakeup_en_o <= wakeup_en_i;
       slow_reset_en_o <= reset_en_i;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
index ef4712bf5..336e2ff7d 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
@@ -131,7 +131,7 @@ module pwrmgr_fsm import pwrmgr_pkg::*; (
     end
   end
 
-  always_comb begin
+  always begin
     otp_init = 1'b0;
     lc_init = 1'b0;
     wkup_o = 1'b0;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
index a5669d597..4f39a8b53 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
@@ -35,19 +35,9 @@ package pwrmgr_pkg;
   } pwr_ast_rsp_t;
 
   // default value of pwr_ast_rsp (for dangling ports)
-  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = '{
-    slow_clk_val: 2'b10,
-    core_clk_val: 2'b10,
-    io_clk_val: 2'b10,
-    main_pok: 1'b1
-  };
-
-  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = '{
-    slow_clk_val: 2'b01,
-    core_clk_val: 2'b01,
-    io_clk_val: 2'b10,
-    main_pok: 1'b0
-  };
+  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = 7'b1010101;
+
+  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = 7'b0101100;
 
   // reasons for pwrmgr reset reset
   typedef enum logic [1:0] {
@@ -71,10 +61,7 @@ package pwrmgr_pkg;
   } pwr_rst_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = '{
-    rst_lc_src_n: {PowerDomains{1'b1}},
-    rst_sys_src_n: {PowerDomains{1'b1}}
-  };
+  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = 4'b1111;
 
   // pwrmgr to clkmgr
   typedef struct packed {
@@ -98,10 +85,7 @@ package pwrmgr_pkg;
   } pwr_otp_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = '{
-    otp_done: 1'b1,
-    otp_idle: 1'b1
-  };
+  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = 2'b11;
 
   // pwrmgr to lifecycle
   typedef struct packed {
@@ -115,10 +99,7 @@ package pwrmgr_pkg;
   } pwr_lc_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = '{
-    lc_done: 1'b1,
-    lc_idle: 1'b1
-  };
+  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = 2'b11;
 
   // flash to pwrmgr
   typedef struct packed {
@@ -126,9 +107,7 @@ package pwrmgr_pkg;
   } pwr_flash_t;
 
   // default value (for dangling ports)
-  parameter pwr_flash_t PWR_FLASH_DEFAULT = '{
-    flash_idle: 1'b1
-  };
+  parameter pwr_flash_t PWR_FLASH_DEFAULT = 1'b1;
 
   // processor to pwrmgr
   typedef struct packed {
@@ -136,13 +115,11 @@ package pwrmgr_pkg;
   } pwr_cpu_t;
 
   // default value (for dangling ports)
-  parameter pwr_cpu_t PWR_CPU_DEFAULT = '{
-    core_sleeping: 1'b0
-  };
+  parameter pwr_cpu_t PWR_CPU_DEFAULT = 1'b0;
 
   // default value (for dangling ports)
-  parameter int WAKEUPS_DEFAULT = '0;
-  parameter int RSTREQS_DEFAULT = '0;
+  parameter int WAKEUPS_DEFAULT = 0;
+  parameter int RSTREQS_DEFAULT = 0;
 
   // peripherals to pwrmgr
   typedef struct packed {
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
index 4a6a9d709..3c755c66f 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
@@ -116,7 +116,7 @@ package pwrmgr_reg_pkg;
     pwrmgr_reg2hw_intr_test_reg_t intr_test; // [47:46]
     pwrmgr_reg2hw_control_reg_t control; // [45:42]
     pwrmgr_reg2hw_cfg_cdc_sync_reg_t cfg_cdc_sync; // [41:40]
-    pwrmgr_reg2hw_wakeup_en_mreg_t [15:0] wakeup_en; // [39:24]
+    logic [15:0] wakeup_en; // [39:24]
     pwrmgr_reg2hw_reset_en_reg_t reset_en; // [23:22]
     pwrmgr_reg2hw_wake_info_capture_dis_reg_t wake_info_capture_dis; // [21:21]
     pwrmgr_reg2hw_wake_info_reg_t wake_info; // [20:0]
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
index 6080cf464..31418f345 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
@@ -456,7 +456,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[0].q ),
+    .q      (reg2hw.wakeup_en[0] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en0_qs)
@@ -482,7 +482,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[1].q ),
+    .q      (reg2hw.wakeup_en[1] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en1_qs)
@@ -508,7 +508,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[2].q ),
+    .q      (reg2hw.wakeup_en[2] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en2_qs)
@@ -534,7 +534,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[3].q ),
+    .q      (reg2hw.wakeup_en[3] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en3_qs)
@@ -560,7 +560,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[4].q ),
+    .q      (reg2hw.wakeup_en[4] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en4_qs)
@@ -586,7 +586,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[5].q ),
+    .q      (reg2hw.wakeup_en[5] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en5_qs)
@@ -612,7 +612,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[6].q ),
+    .q      (reg2hw.wakeup_en[6] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en6_qs)
@@ -638,7 +638,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[7].q ),
+    .q      (reg2hw.wakeup_en[7] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en7_qs)
@@ -664,7 +664,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[8].q ),
+    .q      (reg2hw.wakeup_en[8] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en8_qs)
@@ -690,7 +690,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[9].q ),
+    .q      (reg2hw.wakeup_en[9] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en9_qs)
@@ -716,7 +716,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[10].q ),
+    .q      (reg2hw.wakeup_en[10] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en10_qs)
@@ -742,7 +742,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[11].q ),
+    .q      (reg2hw.wakeup_en[11] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en11_qs)
@@ -768,7 +768,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[12].q ),
+    .q      (reg2hw.wakeup_en[12] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en12_qs)
@@ -794,7 +794,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[13].q ),
+    .q      (reg2hw.wakeup_en[13] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en13_qs)
@@ -820,7 +820,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[14].q ),
+    .q      (reg2hw.wakeup_en[14] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en14_qs)
@@ -846,7 +846,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[15].q ),
+    .q      (reg2hw.wakeup_en[15] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en15_qs)
diff --git a/hw/ip/spi_device/rtl/spi_device.sv b/hw/ip/spi_device/rtl/spi_device.sv
index f7f9ed1bf..0b0fd2f7e 100644
--- a/hw/ip/spi_device/rtl/spi_device.sv
+++ b/hw/ip/spi_device/rtl/spi_device.sv
@@ -519,8 +519,8 @@ module spi_device #(
 
   // SRAM Wrapper
   prim_ram_2p_adv #(
-    .Depth (512),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (512),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .DataBitsPerMask (1),
     .CfgW  (8),
 
diff --git a/hw/ip/tlul/common.core b/hw/ip/tlul/common.core
index 7667a16ec..5d6e3647f 100644
--- a/hw/ip/tlul/common.core
+++ b/hw/ip/tlul/common.core
@@ -14,6 +14,7 @@ filesets:
     files:
       - rtl/tlul_fifo_sync.sv
       - rtl/tlul_fifo_async.sv
+      - rtl/tlul_fifo_async_surelog.sv
       - rtl/tlul_assert.sv
       - rtl/tlul_err.sv
       - rtl/tlul_assert_multiple.sv
diff --git a/hw/ip/tlul/rtl/tlul_adapter_sram.sv b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
index 6e2f33191..cb3e9088c 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_sram.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
@@ -174,7 +174,7 @@ module tlul_adapter_sram #(
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wmask_int;
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wdata_int;
 
-  always_comb begin
+  always begin
     wmask_int = '0;
     wdata_int = '0;
 
diff --git a/hw/ip/tlul/rtl/tlul_fifo_async_surelog.sv b/hw/ip/tlul/rtl/tlul_fifo_async_surelog.sv
new file mode 100644
index 000000000..ca3e3c653
--- /dev/null
+++ b/hw/ip/tlul/rtl/tlul_fifo_async_surelog.sv
@@ -0,0 +1,95 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// TL-UL fifo, used to add elasticity or an asynchronous clock crossing
+// to an TL-UL bus.  This instantiates two FIFOs, one for the request side,
+// and one for the response side.
+
+`include "prim_assert.sv"
+
+module tlul_fifo_async_surelog #(
+  parameter int unsigned ReqDepth = 3,
+  parameter int unsigned RspDepth = 3
+) (
+  input                      clk_h_i,
+  input                      rst_h_ni,
+  input                      clk_d_i,
+  input                      rst_d_ni,
+  input  tlul_pkg::tl_h2d_t  tl_h_i,
+  output tlul_pkg::tl_d2h_t  tl_h_o,
+  output tlul_pkg::tl_h2d_t  tl_d_o,
+  input  tlul_pkg::tl_d2h_t  tl_d_i
+);
+
+  // Put everything on the request side into one FIFO
+  localparam int unsigned REQFIFO_WIDTH = $bits(tlul_pkg::tl_h2d_t)-2;
+
+  prim_fifo_async_surelog #(.Width(REQFIFO_WIDTH), .Depth(ReqDepth)) reqfifo (
+    .clk_wr_i      (clk_h_i),
+    .rst_wr_ni     (rst_h_ni),
+    .clk_rd_i      (clk_d_i),
+    .rst_rd_ni     (rst_d_ni),
+    .wvalid_i      (tl_h_i.a_valid),
+    .wready_o      (tl_h_o.a_ready),
+    .wdata_i       ({tl_h_i.a_opcode ,
+                     tl_h_i.a_param  ,
+                     tl_h_i.a_size   ,
+                     tl_h_i.a_source ,
+                     tl_h_i.a_address,
+                     tl_h_i.a_mask   ,
+                     tl_h_i.a_data   ,
+                     tl_h_i.a_user   }),
+    .rvalid_o      (tl_d_o.a_valid),
+    .rready_i      (tl_d_i.a_ready),
+    .rdata_o       ({tl_d_o.a_opcode ,
+                     tl_d_o.a_param  ,
+                     tl_d_o.a_size   ,
+                     tl_d_o.a_source ,
+                     tl_d_o.a_address,
+                     tl_d_o.a_mask   ,
+                     tl_d_o.a_data   ,
+                     tl_d_o.a_user   }),
+    .wdepth_o      (),
+    .rdepth_o      ()
+  );
+
+  // Put everything on the response side into the other FIFO
+
+  localparam int unsigned RSPFIFO_WIDTH = $bits(tlul_pkg::tl_d2h_t) -2;
+
+  prim_fifo_async_surelog #(.Width(RSPFIFO_WIDTH), .Depth(RspDepth)) rspfifo (
+    .clk_wr_i      (clk_d_i),
+    .rst_wr_ni     (rst_d_ni),
+    .clk_rd_i      (clk_h_i),
+    .rst_rd_ni     (rst_h_ni),
+    .wvalid_i      (tl_d_i.d_valid),
+    .wready_o      (tl_d_o.d_ready),
+    .wdata_i       ({tl_d_i.d_opcode,
+                     tl_d_i.d_param ,
+                     tl_d_i.d_size  ,
+                     tl_d_i.d_source,
+                     tl_d_i.d_sink  ,
+                     tl_d_i.d_data  ,
+                     tl_d_i.d_user  ,
+                     tl_d_i.d_error }),
+    .rvalid_o      (tl_h_o.d_valid),
+    .rready_i      (tl_h_i.d_ready),
+    .rdata_o       ({tl_h_o.d_opcode,
+                     tl_h_o.d_param ,
+                     tl_h_o.d_size  ,
+                     tl_h_o.d_source,
+                     tl_h_o.d_sink  ,
+                     tl_h_o.d_data  ,
+                     tl_h_o.d_user  ,
+                     tl_h_o.d_error }),
+    .wdepth_o      (),
+    .rdepth_o      ()
+  );
+
+  ////////////////
+  // Assertions //
+  ////////////////
+  `ASSERT_INIT(DepthGTE3_A, ReqDepth >= 3 && RspDepth >= 3)
+
+endmodule
diff --git a/hw/ip/tlul/rtl/tlul_fifo_sync.sv b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
index 59fe3ffd4..071a30b94 100644
--- a/hw/ip/tlul/rtl/tlul_fifo_sync.sv
+++ b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
@@ -7,8 +7,8 @@
 // and one for the response side.
 
 module tlul_fifo_sync #(
-  parameter int unsigned ReqPass  = 1'b1,
-  parameter int unsigned RspPass  = 1'b1,
+  parameter int unsigned ReqPass  = 0,
+  parameter int unsigned RspPass  = 0,
   parameter int unsigned ReqDepth = 2,
   parameter int unsigned RspDepth = 2,
   parameter int unsigned SpareReqW = 1,
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1_n2.sv b/hw/ip/tlul/rtl/tlul_socket_m1_n2.sv
new file mode 100644
index 000000000..683066c27
--- /dev/null
+++ b/hw/ip/tlul/rtl/tlul_socket_m1_n2.sv
@@ -0,0 +1,192 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// TL-UL socket M:1 module
+//
+// Verilog parameters
+//   M:             Number of host ports.
+//   HReqPass:      M bit array to allow requests to pass through the host i
+//                  FIFO with no clock delay if the request FIFO is empty. If
+//                  1'b0, at least one clock cycle of latency is created.
+//                  Default is 1'b1.
+//   HRspPass:      Same as HReqPass but for host response FIFO.
+//   HReqDepth:     Mx4 bit array. bit[i*4+:4] is depth of host i request FIFO.
+//                  Depth of zero is allowed if ReqPass is true. A maximum value
+//                  of 16 is allowed, default is 2.
+//   HRspDepth:     Same as HReqDepth but for host response FIFO.
+//   DReqPass:      Same as HReqPass but for device request FIFO.
+//   DRspPass:      Same as HReqPass but for device response FIFO.
+//   DReqDepth:     Same as HReqDepth but for device request FIFO.
+//   DRspDepth:     Same as HReqDepth but for device response FIFO.
+
+`include "prim_assert.sv"
+
+module tlul_socket_m1_n2 #(
+  parameter int unsigned  M         = 2,
+  parameter bit [M-1:0]   HReqPass  = {M{1'b1}},
+  parameter bit [M-1:0]   HRspPass  = {M{1'b1}},
+  parameter bit [M*4-1:0] HReqDepth = {M{4'h0}},
+  parameter bit [M*4-1:0] HRspDepth = {M{4'h0}},
+  parameter bit           DReqPass  = 1'b0,
+  parameter bit           DRspPass  = 1'b0,
+  parameter bit [3:0]     DReqDepth = 4'h2,
+  parameter bit [3:0]     DRspDepth = 4'h2
+) (
+	input clk_i,
+	input rst_ni,
+	input wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] tl_h_i,
+	output wire [(0 >= (M - 1) ? ((2 - M) * 68) + (((M - 1) * 68) - 1) : (M * 68) - 1):(0 >= (M - 1) ? (M - 1) * 68 : 0)] tl_h_o,
+	output wire [101:0] tl_d_o,
+	input wire [67:0] tl_d_i
+);
+	localparam signed [31:0] top_pkg_TL_AIW = 8;
+	localparam signed [31:0] top_pkg_TL_AW = 32;
+	localparam signed [31:0] top_pkg_TL_DW = 32;
+	localparam signed [31:0] top_pkg_TL_DBW = 4;
+	localparam signed [31:0] top_pkg_TL_SZW = 2;
+	localparam signed [31:0] top_pkg_TL_DIW = 1;
+	localparam signed [31:0] top_pkg_TL_DUW = 16;
+	localparam [31:0] IDW = top_pkg_TL_AIW;
+	localparam [31:0] STIDW = $clog2(M);
+	wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] hreq_fifo_o;
+	wire [67:0] hrsp_fifo_i [0:M - 1];
+	wire [M - 1:0] hrequest;
+	wire [M - 1:0] hgrant;
+	wire [101:0] dreq_fifo_i;
+	wire [67:0] drsp_fifo_o;
+	wire arb_valid;
+	wire arb_ready;
+	wire [101:0] arb_data;
+	generate
+		genvar i;
+		for (i = 0; i < M; i = i + 1) begin : gen_host_fifo
+			wire [101:0] hreq_fifo_i;
+			wire [STIDW - 1:0] reqid_sub;
+			wire [7:0] shifted_id;
+			assign reqid_sub = i;
+			assign shifted_id = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 85+:IDW - STIDW], reqid_sub};
+			wire [7:IDW - STIDW] unused_tl_h_source;
+			assign unused_tl_h_source = tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 92-:STIDW];
+			assign hreq_fifo_i = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101],
+			                      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94-2+1],
+					      shifted_id,
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84-32+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52-4+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48-top_pkg_TL_DW+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16-16+1],
+					      tl_h_i[(0 >= (M - 1) ? i : (M - 1) - i) * 102]};
+			tlul_fifo_sync #(
+				.ReqPass(HReqPass[i]),
+				.RspPass(HRspPass[i]),
+				.ReqDepth(HReqDepth[i * 4+:4]),
+				.RspDepth(HRspDepth[i * 4+:4]),
+				.SpareReqW(1)
+			) u_hostfifo(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.tl_h_i(hreq_fifo_i),
+				.tl_h_o(tl_h_o[(0 >= (M - 1) ? i : (M - 1) - i) * 68+:68]),
+				.tl_d_o(hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102+:102]),
+				.tl_d_i(hrsp_fifo_i[i]),
+				.spare_req_i(1'b0),
+				.spare_req_o(),
+				.spare_rsp_i(1'b0),
+				.spare_rsp_o()
+			);
+		end
+	endgenerate
+	tlul_fifo_sync #(
+		.ReqPass(DReqPass),
+		.RspPass(DRspPass),
+		.ReqDepth(DReqDepth),
+		.RspDepth(DRspDepth),
+		.SpareReqW(1)
+	) u_devicefifo(
+		.clk_i(clk_i),
+		.rst_ni(rst_ni),
+		.tl_h_i(dreq_fifo_i),
+		.tl_h_o(drsp_fifo_o),
+		.tl_d_o(tl_d_o),
+		.tl_d_i(tl_d_i),
+		.spare_req_i(1'b0),
+		.spare_req_o(),
+		.spare_rsp_i(1'b0),
+		.spare_rsp_o()
+	);
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_arbreqgnt
+			assign hrequest[i] = hreq_fifo_o[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101];
+		end
+	endgenerate
+	assign arb_ready = drsp_fifo_o[0];
+	localparam tlul_pkg_ArbiterImpl = "PPC";
+	generate
+		if (tlul_pkg_ArbiterImpl == "PPC") begin : gen_arb_ppc
+			prim_arbiter_ppc_surelog #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+		else if (tlul_pkg_ArbiterImpl == "BINTREE") begin : gen_tree_arb
+			prim_arbiter_tree #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+	endgenerate
+	wire [M - 1:0] hfifo_rspvalid;
+	wire [M - 1:0] dfifo_rspready;
+	wire [7:0] hfifo_rspid;
+	wire dfifo_rspready_merged;
+	assign dfifo_rspready_merged = |dfifo_rspready;
+	assign dreq_fifo_i = {arb_valid,
+	                      arb_data[100:100-3+1],
+			      arb_data[97:97-3+1],
+			      arb_data[94:94-2+1],
+			      arb_data[92:92-8+1],
+			      arb_data[84:84-32+1],
+			      arb_data[52:52-4+1],
+			      arb_data[48:48-top_pkg_TL_DW+1],
+			      arb_data[16:16-16+1],
+			      dfifo_rspready_merged};
+	assign hfifo_rspid = {{STIDW {1'b0}}, drsp_fifo_o[58:51 + STIDW]};
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_idrouting
+			assign hfifo_rspvalid[i] = drsp_fifo_o[67] & (drsp_fifo_o[51+:STIDW] == i);
+			assign dfifo_rspready[i] = (hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102] & (drsp_fifo_o[51+:STIDW] == i)) & drsp_fifo_o[67];
+			assign hrsp_fifo_i[i] = {hfifo_rspvalid[i],
+			                         drsp_fifo_o[66:66-3+1],
+						 drsp_fifo_o[63:63-3+1],
+						 drsp_fifo_o[60:60-2+1],
+						 hfifo_rspid,
+						 drsp_fifo_o[50:50-1+1],
+						 drsp_fifo_o[49:49-32+1],
+						 drsp_fifo_o[17:17-top_pkg_TL_DUW+1],
+						 drsp_fifo_o[1],
+						 hgrant[i]};
+		end
+	endgenerate
+endmodule
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1_n2_depth.sv b/hw/ip/tlul/rtl/tlul_socket_m1_n2_depth.sv
new file mode 100644
index 000000000..57f6f4410
--- /dev/null
+++ b/hw/ip/tlul/rtl/tlul_socket_m1_n2_depth.sv
@@ -0,0 +1,192 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// TL-UL socket M:1 module
+//
+// Verilog parameters
+//   M:             Number of host ports.
+//   HReqPass:      M bit array to allow requests to pass through the host i
+//                  FIFO with no clock delay if the request FIFO is empty. If
+//                  1'b0, at least one clock cycle of latency is created.
+//                  Default is 1'b1.
+//   HRspPass:      Same as HReqPass but for host response FIFO.
+//   HReqDepth:     Mx4 bit array. bit[i*4+:4] is depth of host i request FIFO.
+//                  Depth of zero is allowed if ReqPass is true. A maximum value
+//                  of 16 is allowed, default is 2.
+//   HRspDepth:     Same as HReqDepth but for host response FIFO.
+//   DReqPass:      Same as HReqPass but for device request FIFO.
+//   DRspPass:      Same as HReqPass but for device response FIFO.
+//   DReqDepth:     Same as HReqDepth but for device request FIFO.
+//   DRspDepth:     Same as HReqDepth but for device response FIFO.
+
+`include "prim_assert.sv"
+
+module tlul_socket_m1_n2_depth #(
+  parameter int unsigned  M         = 2,
+  parameter bit [M-1:0]   HReqPass  = {M{1'b1}},
+  parameter bit [M-1:0]   HRspPass  = {M{1'b1}},
+  parameter bit [M*4-1:0] HReqDepth = {M{4'h0}},
+  parameter bit [M*4-1:0] HRspDepth = {M{4'h0}},
+  parameter bit           DReqPass  = 1'b1,
+  parameter bit           DRspPass  = 1'b1,
+  parameter bit [3:0]     DReqDepth = 4'h0,
+  parameter bit [3:0]     DRspDepth = 4'h0
+) (
+	input clk_i,
+	input rst_ni,
+	input wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] tl_h_i,
+	output wire [(0 >= (M - 1) ? ((2 - M) * 68) + (((M - 1) * 68) - 1) : (M * 68) - 1):(0 >= (M - 1) ? (M - 1) * 68 : 0)] tl_h_o,
+	output wire [101:0] tl_d_o,
+	input wire [67:0] tl_d_i
+);
+	localparam signed [31:0] top_pkg_TL_AIW = 8;
+	localparam signed [31:0] top_pkg_TL_AW = 32;
+	localparam signed [31:0] top_pkg_TL_DW = 32;
+	localparam signed [31:0] top_pkg_TL_DBW = 4;
+	localparam signed [31:0] top_pkg_TL_SZW = 2;
+	localparam signed [31:0] top_pkg_TL_DIW = 1;
+	localparam signed [31:0] top_pkg_TL_DUW = 16;
+	localparam [31:0] IDW = top_pkg_TL_AIW;
+	localparam [31:0] STIDW = $clog2(M);
+	wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] hreq_fifo_o;
+	wire [67:0] hrsp_fifo_i [0:M - 1];
+	wire [M - 1:0] hrequest;
+	wire [M - 1:0] hgrant;
+	wire [101:0] dreq_fifo_i;
+	wire [67:0] drsp_fifo_o;
+	wire arb_valid;
+	wire arb_ready;
+	wire [101:0] arb_data;
+	generate
+		genvar i;
+		for (i = 0; i < M; i = i + 1) begin : gen_host_fifo
+			wire [101:0] hreq_fifo_i;
+			wire [STIDW - 1:0] reqid_sub;
+			wire [7:0] shifted_id;
+			assign reqid_sub = i;
+			assign shifted_id = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 85+:IDW - STIDW], reqid_sub};
+			wire [7:IDW - STIDW] unused_tl_h_source;
+			assign unused_tl_h_source = tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 92-:STIDW];
+			assign hreq_fifo_i = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101],
+			                      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94-2+1],
+					      shifted_id,
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84-32+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52-4+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48-top_pkg_TL_DW+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16-16+1],
+					      tl_h_i[(0 >= (M - 1) ? i : (M - 1) - i) * 102]};
+			tlul_fifo_sync #(
+				.ReqPass(HReqPass[i]),
+				.RspPass(HRspPass[i]),
+				.ReqDepth(HReqDepth[i * 4+:4]),
+				.RspDepth(HRspDepth[i * 4+:4]),
+				.SpareReqW(1)
+			) u_hostfifo(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.tl_h_i(hreq_fifo_i),
+				.tl_h_o(tl_h_o[(0 >= (M - 1) ? i : (M - 1) - i) * 68+:68]),
+				.tl_d_o(hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102+:102]),
+				.tl_d_i(hrsp_fifo_i[i]),
+				.spare_req_i(1'b0),
+				.spare_req_o(),
+				.spare_rsp_i(1'b0),
+				.spare_rsp_o()
+			);
+		end
+	endgenerate
+	tlul_fifo_sync #(
+		.ReqPass(DReqPass),
+		.RspPass(DRspPass),
+		.ReqDepth(DReqDepth),
+		.RspDepth(DRspDepth),
+		.SpareReqW(1)
+	) u_devicefifo(
+		.clk_i(clk_i),
+		.rst_ni(rst_ni),
+		.tl_h_i(dreq_fifo_i),
+		.tl_h_o(drsp_fifo_o),
+		.tl_d_o(tl_d_o),
+		.tl_d_i(tl_d_i),
+		.spare_req_i(1'b0),
+		.spare_req_o(),
+		.spare_rsp_i(1'b0),
+		.spare_rsp_o()
+	);
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_arbreqgnt
+			assign hrequest[i] = hreq_fifo_o[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101];
+		end
+	endgenerate
+	assign arb_ready = drsp_fifo_o[0];
+	localparam tlul_pkg_ArbiterImpl = "PPC";
+	generate
+		if (tlul_pkg_ArbiterImpl == "PPC") begin : gen_arb_ppc
+			prim_arbiter_ppc_surelog #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+		else if (tlul_pkg_ArbiterImpl == "BINTREE") begin : gen_tree_arb
+			prim_arbiter_tree #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+	endgenerate
+	wire [M - 1:0] hfifo_rspvalid;
+	wire [M - 1:0] dfifo_rspready;
+	wire [7:0] hfifo_rspid;
+	wire dfifo_rspready_merged;
+	assign dfifo_rspready_merged = |dfifo_rspready;
+	assign dreq_fifo_i = {arb_valid,
+	                      arb_data[100:100-3+1],
+			      arb_data[97:97-3+1],
+			      arb_data[94:94-2+1],
+			      arb_data[92:92-8+1],
+			      arb_data[84:84-32+1],
+			      arb_data[52:52-4+1],
+			      arb_data[48:48-top_pkg_TL_DW+1],
+			      arb_data[16:16-16+1],
+			      dfifo_rspready_merged};
+	assign hfifo_rspid = {{STIDW {1'b0}}, drsp_fifo_o[58:51 + STIDW]};
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_idrouting
+			assign hfifo_rspvalid[i] = drsp_fifo_o[67] & (drsp_fifo_o[51+:STIDW] == i);
+			assign dfifo_rspready[i] = (hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102] & (drsp_fifo_o[51+:STIDW] == i)) & drsp_fifo_o[67];
+			assign hrsp_fifo_i[i] = {hfifo_rspvalid[i],
+			                         drsp_fifo_o[66:66-3+1],
+						 drsp_fifo_o[63:63-3+1],
+						 drsp_fifo_o[60:60-2+1],
+						 hfifo_rspid,
+						 drsp_fifo_o[50:50-1+1],
+						 drsp_fifo_o[49:49-32+1],
+						 drsp_fifo_o[17:17-top_pkg_TL_DUW+1],
+						 drsp_fifo_o[1],
+						 hgrant[i]};
+		end
+	endgenerate
+endmodule
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1_n3.sv b/hw/ip/tlul/rtl/tlul_socket_m1_n3.sv
new file mode 100644
index 000000000..df2f80214
--- /dev/null
+++ b/hw/ip/tlul/rtl/tlul_socket_m1_n3.sv
@@ -0,0 +1,192 @@
+// Copyright lowRISC contributors.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+//
+// TL-UL socket M:1 module
+//
+// Verilog parameters
+//   M:             Number of host ports.
+//   HReqPass:      M bit array to allow requests to pass through the host i
+//                  FIFO with no clock delay if the request FIFO is empty. If
+//                  1'b0, at least one clock cycle of latency is created.
+//                  Default is 1'b1.
+//   HRspPass:      Same as HReqPass but for host response FIFO.
+//   HReqDepth:     Mx4 bit array. bit[i*4+:4] is depth of host i request FIFO.
+//                  Depth of zero is allowed if ReqPass is true. A maximum value
+//                  of 16 is allowed, default is 2.
+//   HRspDepth:     Same as HReqDepth but for host response FIFO.
+//   DReqPass:      Same as HReqPass but for device request FIFO.
+//   DRspPass:      Same as HReqPass but for device response FIFO.
+//   DReqDepth:     Same as HReqDepth but for device request FIFO.
+//   DRspDepth:     Same as HReqDepth but for device response FIFO.
+
+`include "prim_assert.sv"
+
+module tlul_socket_m1_n3 #(
+  parameter int unsigned  M         = 3,
+  parameter bit [M-1:0]   HReqPass  = {M{1'b1}},
+  parameter bit [M-1:0]   HRspPass  = {M{1'b1}},
+  parameter bit [M*4-1:0] HReqDepth = {M{4'h0}},
+  parameter bit [M*4-1:0] HRspDepth = {M{4'h0}},
+  parameter bit           DReqPass  = 1'b1,
+  parameter bit           DRspPass  = 1'b1,
+  parameter bit [3:0]     DReqDepth = 4'h0,
+  parameter bit [3:0]     DRspDepth = 4'h0
+) (
+	input clk_i,
+	input rst_ni,
+	input wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] tl_h_i,
+	output wire [(0 >= (M - 1) ? ((2 - M) * 68) + (((M - 1) * 68) - 1) : (M * 68) - 1):(0 >= (M - 1) ? (M - 1) * 68 : 0)] tl_h_o,
+	output wire [101:0] tl_d_o,
+	input wire [67:0] tl_d_i
+);
+	localparam signed [31:0] top_pkg_TL_AIW = 8;
+	localparam signed [31:0] top_pkg_TL_AW = 32;
+	localparam signed [31:0] top_pkg_TL_DW = 32;
+	localparam signed [31:0] top_pkg_TL_DBW = 4;
+	localparam signed [31:0] top_pkg_TL_SZW = 2;
+	localparam signed [31:0] top_pkg_TL_DIW = 1;
+	localparam signed [31:0] top_pkg_TL_DUW = 16;
+	localparam [31:0] IDW = top_pkg_TL_AIW;
+	localparam [31:0] STIDW = $clog2(M);
+	wire [(0 >= (M - 1) ? ((2 - M) * 102) + (((M - 1) * 102) - 1) : (M * 102) - 1):(0 >= (M - 1) ? (M - 1) * 102 : 0)] hreq_fifo_o;
+	wire [67:0] hrsp_fifo_i [0:M - 1];
+	wire [M - 1:0] hrequest;
+	wire [M - 1:0] hgrant;
+	wire [101:0] dreq_fifo_i;
+	wire [67:0] drsp_fifo_o;
+	wire arb_valid;
+	wire arb_ready;
+	wire [101:0] arb_data;
+	generate
+		genvar i;
+		for (i = 0; i < M; i = i + 1) begin : gen_host_fifo
+			wire [101:0] hreq_fifo_i;
+			wire [STIDW - 1:0] reqid_sub;
+			wire [7:0] shifted_id;
+			assign reqid_sub = i;
+			assign shifted_id = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 85+:IDW - STIDW], reqid_sub};
+			wire [7:IDW - STIDW] unused_tl_h_source;
+			assign unused_tl_h_source = tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 92:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 92 - STIDW + 1];
+			assign hreq_fifo_i = {tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101],
+			                      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 100-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 97-3+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 94-2+1],
+					      shifted_id,
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 84-32+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 52-4+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 48-top_pkg_TL_DW+1],
+					      tl_h_i[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16:((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 16-16+1],
+					      tl_h_i[(0 >= (M - 1) ? i : (M - 1) - i) * 102]};
+			tlul_fifo_sync #(
+				.ReqPass(HReqPass[i]),
+				.RspPass(HRspPass[i]),
+				.ReqDepth(HReqDepth[i * 4+:4]),
+				.RspDepth(HRspDepth[i * 4+:4]),
+				.SpareReqW(1)
+			) u_hostfifo(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.tl_h_i(hreq_fifo_i),
+				.tl_h_o(tl_h_o[(0 >= (M - 1) ? i : (M - 1) - i) * 68+:68]),
+				.tl_d_o(hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102+:102]),
+				.tl_d_i(hrsp_fifo_i[i]),
+				.spare_req_i(1'b0),
+				.spare_req_o(),
+				.spare_rsp_i(1'b0),
+				.spare_rsp_o()
+			);
+		end
+	endgenerate
+	tlul_fifo_sync #(
+		.ReqPass(DReqPass),
+		.RspPass(DRspPass),
+		.ReqDepth(DReqDepth),
+		.RspDepth(DRspDepth),
+		.SpareReqW(1)
+	) u_devicefifo(
+		.clk_i(clk_i),
+		.rst_ni(rst_ni),
+		.tl_h_i(dreq_fifo_i),
+		.tl_h_o(drsp_fifo_o),
+		.tl_d_o(tl_d_o),
+		.tl_d_i(tl_d_i),
+		.spare_req_i(1'b0),
+		.spare_req_o(),
+		.spare_rsp_i(1'b0),
+		.spare_rsp_o()
+	);
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_arbreqgnt
+			assign hrequest[i] = hreq_fifo_o[((0 >= (M - 1) ? i : (M - 1) - i) * 102) + 101];
+		end
+	endgenerate
+	assign arb_ready = drsp_fifo_o[0];
+	localparam tlul_pkg_ArbiterImpl = "PPC";
+	generate
+		if (tlul_pkg_ArbiterImpl == "PPC") begin : gen_arb_ppc
+			prim_arbiter_ppc_surelog #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+		else if (tlul_pkg_ArbiterImpl == "BINTREE") begin : gen_tree_arb
+			prim_arbiter_tree #(
+				.N(M),
+				.DW(102)
+			) u_reqarb(
+				.clk_i(clk_i),
+				.rst_ni(rst_ni),
+				.req_i(hrequest),
+				.data_i(hreq_fifo_o),
+				.gnt_o(hgrant),
+				.idx_o(),
+				.valid_o(arb_valid),
+				.data_o(arb_data),
+				.ready_i(arb_ready)
+			);
+		end
+	endgenerate
+	wire [M - 1:0] hfifo_rspvalid;
+	wire [M - 1:0] dfifo_rspready;
+	wire [7:0] hfifo_rspid;
+	wire dfifo_rspready_merged;
+	assign dfifo_rspready_merged = |dfifo_rspready;
+	assign dreq_fifo_i = {arb_valid,
+	                      arb_data[100:100-3+1],
+			      arb_data[97:97-3+1],
+			      arb_data[94:94-2+1],
+			      arb_data[92:92-8+1],
+			      arb_data[84:84-32+1],
+			      arb_data[52:52-4+1],
+			      arb_data[48:48-top_pkg_TL_DW+1],
+			      arb_data[16:16-16+1],
+			      dfifo_rspready_merged};
+	assign hfifo_rspid = {{STIDW {1'b0}}, drsp_fifo_o[58:51 + STIDW]};
+	generate
+		for (i = 0; i < M; i = i + 1) begin : gen_idrouting
+			assign hfifo_rspvalid[i] = drsp_fifo_o[67] & (drsp_fifo_o[51+:STIDW] == i);
+			assign dfifo_rspready[i] = (hreq_fifo_o[(0 >= (M - 1) ? i : (M - 1) - i) * 102] & (drsp_fifo_o[51+:STIDW] == i)) & drsp_fifo_o[67];
+			assign hrsp_fifo_i[i] = {hfifo_rspvalid[i],
+			                         drsp_fifo_o[66:66-3+1],
+						 drsp_fifo_o[63:63-3+1],
+						 drsp_fifo_o[60:60-2+1],
+						 hfifo_rspid,
+						 drsp_fifo_o[50:50-1+1],
+						 drsp_fifo_o[49:49-32+1],
+						 drsp_fifo_o[17:17-top_pkg_TL_DUW+1],
+						 drsp_fifo_o[1],
+						 hgrant[i]};
+		end
+	endgenerate
+endmodule
diff --git a/hw/ip/tlul/socket_m1.core b/hw/ip/tlul/socket_m1.core
index 1dba035f5..b08354864 100644
--- a/hw/ip/tlul/socket_m1.core
+++ b/hw/ip/tlul/socket_m1.core
@@ -13,6 +13,9 @@ filesets:
       - lowrisc:tlul:headers
     files:
       - rtl/tlul_socket_m1.sv
+      - rtl/tlul_socket_m1_n2.sv
+      - rtl/tlul_socket_m1_n3.sv
+      - rtl/tlul_socket_m1_n2_depth.sv
     file_type: systemVerilogSource
 
   files_verilator_waiver:
diff --git a/hw/ip/usbdev/rtl/usbdev.sv b/hw/ip/usbdev/rtl/usbdev.sv
index cbdadd624..42a4d1b7a 100644
--- a/hw/ip/usbdev/rtl/usbdev.sv
+++ b/hw/ip/usbdev/rtl/usbdev.sv
@@ -563,7 +563,7 @@ module usbdev (
 
   // CDC for event signals (arguably they are there for a long time so would be ok)
   // Just want a pulse to ensure only one interrupt for an event
-  usbdev_flop_2syncpulse #(.Width(5)) syncevent (
+  usbdev_flop_2syncpulse #(.UsbWidth(5)) syncevent (
     .clk_i  (clk_i),
     .rst_ni (rst_ni),
     .d_i    ({usb_event_disconnect, usb_event_link_reset, usb_event_link_suspend,
@@ -654,8 +654,8 @@ module usbdev (
 
   // SRAM Wrapper
   prim_ram_2p_async_adv #(
-    .Depth (SramDepth),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (SramDepth),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .CfgW  (8),
 
     .EnableECC           (0), // No Protection
diff --git a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
index 9889b0a1f..9b297e67f 100644
--- a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
+++ b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
@@ -5,17 +5,17 @@
 // Generic double-synchronizer flop followed by pulse generation
 
 module usbdev_flop_2syncpulse #(
-  parameter int unsigned Width = 16
+  parameter int unsigned UsbWidth = 16
 ) (
   input  logic             clk_i,    // receive clock
   input  logic             rst_ni,
-  input  logic [Width-1:0] d_i,
-  output logic [Width-1:0] q_o
+  input  logic [UsbWidth-1:0] d_i,
+  output logic [UsbWidth-1:0] q_o
 );
 
   // double-flop synchronizer cell
-  logic [Width-1:0] d_sync;
-  prim_flop_2sync #(.Width (Width)) prim_flop_2sync (
+  logic [UsbWidth-1:0] d_sync;
+  prim_flop_2sync #(.Width (UsbWidth)) prim_flop_2sync (
     .clk_i,
     .rst_ni,
     .d_i,
@@ -23,7 +23,7 @@ module usbdev_flop_2syncpulse #(
   );
 
   // delay d_sync by 1 cycle
-  logic [Width-1:0] d_sync_q;
+  logic [UsbWidth-1:0] d_sync_q;
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
       d_sync_q <= '0;
diff --git a/hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv b/hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv
index ff5251ee5..eba568103 100644
--- a/hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv
+++ b/hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv
@@ -559,7 +559,7 @@ end
     .tl_d_i       (tl_s1n_17_ds_d2h),
     .dev_select_i (dev_sel_s1n_17)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n3 #(
     .HReqDepth (12'h0),
     .HRspDepth (12'h0),
     .DReqDepth (4'h0),
@@ -573,7 +573,7 @@ end
     .tl_d_o       (tl_sm1_18_ds_h2d),
     .tl_d_i       (tl_sm1_18_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -587,7 +587,7 @@ end
     .tl_d_o       (tl_sm1_19_ds_h2d),
     .tl_d_i       (tl_sm1_19_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n3 #(
     .HReqDepth (12'h0),
     .HRspDepth (12'h0),
     .DReqDepth (4'h0),
@@ -601,7 +601,7 @@ end
     .tl_d_o       (tl_sm1_20_ds_h2d),
     .tl_d_i       (tl_sm1_20_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n3 #(
     .HReqDepth (12'h0),
     .HRspDepth (12'h0),
     .DReqDepth (4'h0),
@@ -630,7 +630,7 @@ end
     .tl_d_i       (tl_s1n_22_ds_d2h),
     .dev_select_i (dev_sel_s1n_22)
   );
-  tlul_fifo_async #(
+  tlul_fifo_async_surelog #(
     .ReqDepth        (3),// At least 3 to make async work
     .RspDepth        (3) // At least 3 to make async work
   ) u_asf_23 (
@@ -643,7 +643,7 @@ end
     .tl_d_o       (tl_asf_23_ds_h2d),
     .tl_d_i       (tl_asf_23_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2_depth #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqDepth (4'h0),
@@ -657,7 +657,7 @@ end
     .tl_d_o       (tl_sm1_24_ds_h2d),
     .tl_d_i       (tl_sm1_24_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -671,7 +671,7 @@ end
     .tl_d_o       (tl_sm1_25_ds_h2d),
     .tl_d_i       (tl_sm1_25_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -685,7 +685,7 @@ end
     .tl_d_o       (tl_sm1_26_ds_h2d),
     .tl_d_i       (tl_sm1_26_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -699,7 +699,7 @@ end
     .tl_d_o       (tl_sm1_27_ds_h2d),
     .tl_d_i       (tl_sm1_27_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -713,7 +713,7 @@ end
     .tl_d_o       (tl_sm1_28_ds_h2d),
     .tl_d_i       (tl_sm1_28_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -727,7 +727,7 @@ end
     .tl_d_o       (tl_sm1_29_ds_h2d),
     .tl_d_i       (tl_sm1_29_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -741,7 +741,7 @@ end
     .tl_d_o       (tl_sm1_30_ds_h2d),
     .tl_d_i       (tl_sm1_30_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -755,7 +755,7 @@ end
     .tl_d_o       (tl_sm1_31_ds_h2d),
     .tl_d_i       (tl_sm1_31_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
@@ -769,7 +769,7 @@ end
     .tl_d_o       (tl_sm1_32_ds_h2d),
     .tl_d_i       (tl_sm1_32_ds_d2h)
   );
-  tlul_socket_m1 #(
+  tlul_socket_m1_n2 #(
     .HReqDepth (8'h0),
     .HRspDepth (8'h0),
     .DReqPass  (1'b0),
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
index 61469937f..12f0a2bcd 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
@@ -133,8 +133,8 @@ module ibex_core #(
   logic [31:0] pc_if;                          // Program counter in IF stage
   logic [31:0] pc_id;                          // Program counter in ID stage
   logic [31:0] pc_wb;                          // Program counter in WB stage
-  logic [33:0] imd_val_d_ex[2];                // Intermediate register for multicycle Ops
-  logic [33:0] imd_val_q_ex[2];                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_d_ex;                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_q_ex;                // Intermediate register for multicycle Ops
   logic [1:0]  imd_val_we_ex;
 
   logic        data_ind_timing;
@@ -254,7 +254,7 @@ module ibex_core #(
   logic [31:0] csr_mepc, csr_depc;
 
   // PMP signals
-  logic [33:0] csr_pmp_addr [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0] csr_pmp_addr;
   pmp_cfg_t    csr_pmp_cfg  [PMPNumRegions];
   logic        pmp_req_err  [PMP_NUM_CHAN];
   logic        instr_req_out;
@@ -932,16 +932,16 @@ module ibex_core #(
   `ASSERT_KNOWN_IF(IbexCsrWdataIntKnown, cs_registers_i.csr_wdata_int, csr_op_en)
 
   if (PMPEnable) begin : g_pmp
-    logic [33:0] pmp_req_addr [PMP_NUM_CHAN];
-    pmp_req_e    pmp_req_type [PMP_NUM_CHAN];
-    priv_lvl_e   pmp_priv_lvl [PMP_NUM_CHAN];
-
-    assign pmp_req_addr[PMP_I] = {2'b00,instr_addr_o[31:0]};
-    assign pmp_req_type[PMP_I] = PMP_ACC_EXEC;
-    assign pmp_priv_lvl[PMP_I] = priv_mode_if;
-    assign pmp_req_addr[PMP_D] = {2'b00,data_addr_o[31:0]};
-    assign pmp_req_type[PMP_D] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
-    assign pmp_priv_lvl[PMP_D] = priv_mode_lsu;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_req_type;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_priv_lvl;
+    logic [PMP_NUM_CHAN-1:0][33:0] pmp_req_addr;
+
+    assign pmp_req_addr[PMP_D] = {2'b00,instr_addr_o[31:0]};
+    assign pmp_req_type[PMP_D] = PMP_ACC_EXEC;
+    assign pmp_priv_lvl[PMP_D] = priv_mode_if;
+    assign pmp_req_addr[PMP_I] = {2'b00,data_addr_o[31:0]};
+    assign pmp_req_type[PMP_I] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
+    assign pmp_priv_lvl[PMP_I] = priv_mode_lsu;
 
     ibex_pmp #(
         .PMPGranularity        ( PMPGranularity ),
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
index 6e5eaf4dc..d99e087d6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
@@ -64,7 +64,7 @@ module ibex_cs_registers #(
 
     // PMP
     output ibex_pkg::pmp_cfg_t   csr_pmp_cfg_o  [PMPNumRegions],
-    output logic [33:0]          csr_pmp_addr_o [PMPNumRegions],
+    output logic [PMPNumRegions-1:0][33:0]          csr_pmp_addr_o,
 
     // debug
     input  logic                 debug_mode_i,
@@ -196,8 +196,8 @@ module ibex_cs_registers #(
   logic  [5:0] mstack_cause_q, mstack_cause_d;
 
   // PMP Signals
-  logic [31:0]                 pmp_addr_rdata  [PMP_MAX_REGIONS];
-  logic [PMP_CFG_W-1:0]        pmp_cfg_rdata   [PMP_MAX_REGIONS];
+  logic [PMP_MAX_REGIONS-1:0][31:0]                 pmp_addr_rdata;
+  logic [PMP_MAX_REGIONS-1:0][PMP_CFG_W-1:0]        pmp_cfg_rdata;
 
   // Hardware performance monitor signals
   logic [31:0]                 mcountinhibit;
@@ -208,11 +208,11 @@ module ibex_cs_registers #(
   // mhpmcounter flops are elaborated below providing only the precise number that is required based
   // on MHPMCounterNum/MHPMCounterWidth. This signal connects to the Q output of these flops
   // where they exist and is otherwise 0.
-  logic [63:0] mhpmcounter [32];
+  logic [31:0][63:0] mhpmcounter;
   logic [31:0] mhpmcounter_we;
   logic [31:0] mhpmcounterh_we;
   logic [31:0] mhpmcounter_incr;
-  logic [31:0] mhpmevent [32];
+  logic [31:0][31:0] mhpmevent;
   logic  [4:0] mhpmcounter_idx;
 
   // Debug / trigger registers
@@ -736,12 +736,12 @@ module ibex_cs_registers #(
   // PMP registers
   // -----------------
 
+  pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
+  pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
+  logic [PMPNumRegions-1:0][31:0]                 pmp_addr;
+  logic [PMPNumRegions-1:0]    pmp_cfg_we;
+  logic [PMPNumRegions-1:0]    pmp_addr_we;
   if (PMPEnable) begin : g_pmp_registers
-    pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
-    pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
-    logic [31:0]                 pmp_addr        [PMPNumRegions];
-    logic [PMPNumRegions-1:0]    pmp_cfg_we;
-    logic [PMPNumRegions-1:0]    pmp_addr_we;
 
     // Expanded / qualified register read data
     for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
index eccc68e95..06a672e88 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
@@ -42,8 +42,8 @@ module ibex_ex_block #(
 
     // intermediate val reg
     output logic [1:0]            imd_val_we_o,
-    output logic [33:0]           imd_val_d_o[2],
-    input  logic [33:0]           imd_val_q_i[2],
+    output logic [1:0][33:0]           imd_val_d_o,
+    input  logic [1:0][33:0]           imd_val_q_i,
 
     // Outputs
     output logic [31:0]           alu_adder_result_ex_o, // to LSU
@@ -63,10 +63,10 @@ module ibex_ex_block #(
   logic        alu_cmp_result, alu_is_equal_result;
   logic        multdiv_valid;
   logic        multdiv_sel;
-  logic [31:0] alu_imd_val_q[2];
-  logic [31:0] alu_imd_val_d[2];
+  logic [1:0][31:0] alu_imd_val_q;
+  logic [1:0][31:0] alu_imd_val_d;
   logic [ 1:0] alu_imd_val_we;
-  logic [33:0] multdiv_imd_val_d[2];
+  logic [1:0][33:0] multdiv_imd_val_d;
   logic [ 1:0] multdiv_imd_val_we;
 
   /*
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
index bba4c2af8..a4fbb8da6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
@@ -21,9 +21,9 @@ module ibex_id_stage #(
     parameter bit               RV32M           = 1,
     parameter ibex_pkg::rv32b_e RV32B           = ibex_pkg::RV32BNone,
     parameter bit               DataIndTiming   = 1'b0,
-    parameter bit               BranchTargetALU = 0,
-    parameter bit               SpecBranch      = 0,
-    parameter bit               WritebackStage  = 0
+    parameter bit               BranchTargetALU = 1,
+    parameter bit               SpecBranch      = 1,
+    parameter bit               WritebackStage  = 1
 ) (
     input  logic                      clk_i,
     input  logic                      rst_ni,
@@ -69,8 +69,8 @@ module ibex_id_stage #(
 
     // Multicycle Operation Stage Register
     input  logic [1:0]                imd_val_we_ex_i,
-    input  logic [33:0]               imd_val_d_ex_i[2],
-    output logic [33:0]               imd_val_q_ex_o[2],
+    input  logic [1:0][33:0]               imd_val_d_ex_i,
+    output logic [1:0][33:0]               imd_val_q_ex_o,
 
     // Branch target ALU
     output logic [31:0]               bt_a_operand_o,
@@ -247,7 +247,7 @@ module ibex_id_stage #(
   logic        alu_multicycle_dec;
   logic        stall_alu;
 
-  logic [33:0] imd_val_q[2];
+  logic [1:0][33:0] imd_val_q;
 
   op_a_sel_e   bt_a_mux_sel;
   imm_b_sel_e  bt_b_mux_sel;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
index 617bb5162..e1890da38 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
@@ -35,8 +35,8 @@ module ibex_multdiv_fast #(
     output logic [32:0]      alu_operand_a_o,
     output logic [32:0]      alu_operand_b_o,
 
-    input  logic [33:0]      imd_val_q_i[2],
-    output logic [33:0]      imd_val_d_o[2],
+    input  logic [1:0][33:0]      imd_val_q_i,
+    output logic [1:0][33:0]      imd_val_d_o,
     output logic [1:0]       imd_val_we_o,
 
     input  logic             multdiv_ready_id_i,
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
index 1b48693a0..4621be034 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
@@ -30,8 +30,8 @@ module ibex_pmp #(
   import ibex_pkg::*;
 
   // Access Checking Signals
-  logic [33:0]                                region_start_addr [PMPNumRegions];
-  logic [33:PMPGranularity+2]                 region_addr_mask  [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0]                                region_start_addr;
+  logic [PMPNumRegions-1:0][33:0]                 region_addr_mask;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_gt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_lt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_eq;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
index 4dd429df8..8c95e2492 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
@@ -42,8 +42,8 @@ module ibex_register_file #(
   localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;
 
   logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg;
-  logic [NUM_WORDS-1:1][DataWidth-1:0] rf_reg_q;
-  logic [NUM_WORDS-1:1]                we_a_dec;
+  logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg_q;
+  logic [NUM_WORDS-1:0]                we_a_dec;
 
   always_comb begin : we_a_decoder
     for (int unsigned i = 1; i < NUM_WORDS; i++) begin
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
index ffe380ff4..6f518796f 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
@@ -51,7 +51,7 @@ module ibex_wb_stage #(
 
   // 0 == RF write from ID
   // 1 == RF write from LSU
-  logic [31:0] rf_wdata_wb_mux    [2];
+  logic [1:0][31:0] rf_wdata_wb_mux;
   logic [1:0]  rf_wdata_wb_mux_we;
 
   if(WritebackStage) begin : g_writeback_stage
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
index 550b7cc36..c65fe30c4 100755
--- a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
@@ -216,7 +216,7 @@ module dm_mem #(
   // read/write logic
   logic [63:0] data_bits;
   logic [7:0][7:0] rdata;
-  always_comb begin : p_rw_logic
+  always begin : p_rw_logic
 
     halted_d_aligned   = NrHartsAligned'(halted_q);
     resuming_d_aligned = NrHartsAligned'(resuming_q);
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
index c97f9565a..4aa3646f4 100644
--- a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
@@ -98,16 +98,16 @@ module dm_sba #(
         // generate byte enable mask
         unique case (sbaccess_i)
           3'b000: begin
-            be[be_idx] = '1;
+            be[be_idx] = 4'b1111;
           end
           3'b001: begin
-            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = '1;
+            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = 2'b11;
           end
           3'b010: begin
-            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = '1;
-            else                    be = '1;
+            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = 2'b11;
+            else                    be = 4'b1111;
           end
-          3'b011: be = '1;
+          3'b011: be = 4'b1111;
           default: ;
         endcase
         if (gnt) state_d = WaitWrite;
