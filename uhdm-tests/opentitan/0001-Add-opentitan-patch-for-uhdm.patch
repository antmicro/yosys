diff --git a/hw/ip/aes/rtl/aes_cipher_core.sv b/hw/ip/aes/rtl/aes_cipher_core.sv
index ed35dc5ef..d1b6b560f 100644
--- a/hw/ip/aes/rtl/aes_cipher_core.sv
+++ b/hw/ip/aes/rtl/aes_cipher_core.sv
@@ -40,24 +40,24 @@ module aes_cipher_core #(
   input  logic          [63:0] prng_data_i,
 
   // I/O data & initial key
-  input  logic [3:0][3:0][7:0] state_init_i,
+  input  logic [127:0] state_init_i,
   input  logic     [7:0][31:0] key_init_i,
-  output logic [3:0][3:0][7:0] state_o
+  output logic [127:0] state_o
 );
 
   import aes_pkg::*;
 
   // Signals
-  logic [3:0][3:0][7:0] state_d;
-  logic [3:0][3:0][7:0] state_q;
+  logic [127:0] state_d;
+  logic [127:0] state_q;
   logic                 state_we;
   state_sel_e           state_sel;
 
-  logic [3:0][3:0][7:0] sub_bytes_out;
-  logic [3:0][3:0][7:0] shift_rows_out;
-  logic [3:0][3:0][7:0] mix_columns_out;
-  logic [3:0][3:0][7:0] add_round_key_in;
-  logic [3:0][3:0][7:0] add_round_key_out;
+  logic [127:0] sub_bytes_out;
+  logic [127:0] shift_rows_out;
+  logic [127:0] mix_columns_out;
+  logic [127:0] add_round_key_in;
+  logic [127:0] add_round_key_out;
   add_rk_sel_e          add_round_key_in_sel;
 
   logic     [7:0][31:0] key_full_d;
@@ -75,9 +75,9 @@ module aes_cipher_core #(
   logic           [3:0] key_expand_round;
   key_words_sel_e       key_words_sel;
   logic     [3:0][31:0] key_words;
-  logic [3:0][3:0][7:0] key_bytes;
-  logic [3:0][3:0][7:0] key_mix_columns_out;
-  logic [3:0][3:0][7:0] round_key;
+  logic [127:0] key_bytes;
+  logic [127:0] key_mix_columns_out;
+  logic [127:0] round_key;
   round_key_sel_e       round_key_sel;
 
   //////////
@@ -103,19 +103,19 @@ module aes_cipher_core #(
   // Cipher data path
   aes_sub_bytes #(
     .SBoxImpl ( SBoxImpl )
-  ) aes_sub_bytes (
+  ) u_aes_sub_bytes (
     .op_i   ( op_i          ),
     .data_i ( state_q       ),
     .data_o ( sub_bytes_out )
   );
 
-  aes_shift_rows aes_shift_rows (
+  aes_shift_rows u_aes_shift_rows (
     .op_i   ( op_i           ),
     .data_i ( sub_bytes_out  ),
     .data_o ( shift_rows_out )
   );
 
-  aes_mix_columns aes_mix_columns (
+  aes_mix_columns u_aes_mix_columns (
     .op_i   ( op_i            ),
     .data_i ( shift_rows_out  ),
     .data_o ( mix_columns_out )
@@ -172,7 +172,7 @@ module aes_cipher_core #(
   aes_key_expand #(
     .AES192Enable ( AES192Enable ),
     .SBoxImpl     ( SBoxImpl     )
-  ) aes_key_expand (
+  ) u_aes_key_expand (
     .clk_i     ( clk_i            ),
     .rst_ni    ( rst_ni           ),
     .op_i      ( key_expand_op    ),
@@ -197,7 +197,7 @@ module aes_cipher_core #(
   // Convert words to bytes (every key word contains one column)
   assign key_bytes = aes_transpose(key_words);
 
-  aes_mix_columns aes_key_mix_columns (
+  aes_mix_columns u_aes_key_mix_columns (
     .op_i   ( CIPH_INV            ),
     .data_i ( key_bytes           ),
     .data_o ( key_mix_columns_out )
@@ -216,7 +216,7 @@ module aes_cipher_core #(
   /////////////
 
   // Control
-  aes_cipher_control aes_cipher_control (
+  aes_cipher_control u_aes_cipher_control (
     .clk_i                  ( clk_i                ),
     .rst_ni                 ( rst_ni               ),
 
diff --git a/hw/ip/aes/rtl/aes_key_expand.sv b/hw/ip/aes/rtl/aes_key_expand.sv
index c030089b7..65f0bdc94 100644
--- a/hw/ip/aes/rtl/aes_key_expand.sv
+++ b/hw/ip/aes/rtl/aes_key_expand.sv
@@ -191,7 +191,7 @@ module aes_key_expand #(
 
   // To reduce muxing resources, we re-use existing
   // connections for unused words and default cases.
-  always_comb begin : drive_regular
+  always begin : drive_regular
     unique case (key_len_i)
 
       /////////////
diff --git a/hw/ip/aes/rtl/aes_mix_columns.sv b/hw/ip/aes/rtl/aes_mix_columns.sv
index 3aee014a2..222464474 100644
--- a/hw/ip/aes/rtl/aes_mix_columns.sv
+++ b/hw/ip/aes/rtl/aes_mix_columns.sv
@@ -6,15 +6,15 @@
 
 module aes_mix_columns (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Transpose to operate on columns
-  logic [3:0][3:0][7:0] data_i_transposed;
-  logic [3:0][3:0][7:0] data_o_transposed;
+  logic [127:0] data_i_transposed;
+  logic [127:0] data_o_transposed;
 
   assign data_i_transposed = aes_transpose(data_i);
 
diff --git a/hw/ip/aes/rtl/aes_pkg.sv b/hw/ip/aes/rtl/aes_pkg.sv
index ddc3b7992..6d4e2a759 100644
--- a/hw/ip/aes/rtl/aes_pkg.sv
+++ b/hw/ip/aes/rtl/aes_pkg.sv
@@ -165,12 +165,12 @@ function automatic logic [31:0] aes_circ_byte_shift(logic [31:0] in, logic [1:0]
 endfunction
 
 // Transpose state matrix
-function automatic logic [3:0][3:0][7:0] aes_transpose(logic [3:0][3:0][7:0] in);
-  logic [3:0][3:0][7:0] transpose;
+function automatic logic [127:0] aes_transpose(logic [127:0] in);
+  logic [127:0] transpose;
   transpose = '0;
   for (int j=0; j<4; j++) begin
     for (int i=0; i<4; i++) begin
-      transpose[i][j] = in[j][i];
+      transpose[((i * 4) + j) * 8+:8] = in[((j * 4) + i) * 8+:8];
     end
   end
   return transpose;
diff --git a/hw/ip/aes/rtl/aes_prng.sv b/hw/ip/aes/rtl/aes_prng.sv
index 08e2a94e6..a94dbdd43 100644
--- a/hw/ip/aes/rtl/aes_prng.sv
+++ b/hw/ip/aes/rtl/aes_prng.sv
@@ -23,7 +23,7 @@ module aes_prng (
   input  logic        entropy_ack_i,
   input  logic [63:0] entropy_i
 );
-
+  import prim_cipher_pkg::*;
   localparam int unsigned DATA_WIDTH = 64;
 
   logic                  seed_en;
@@ -58,7 +58,7 @@ module aes_prng (
   );
 
   // "Scramble" the LFSR state.
-  assign scrambled = prim_cipher_pkg::sbox4_64bit(lfsr_state, prim_cipher_pkg::PRINCE_SBOX4);
-  assign data_o    = prim_cipher_pkg::perm_64bit(scrambled, prim_cipher_pkg::PRESENT_PERM64);
+  assign scrambled = sbox4_64bit(lfsr_state, PRINCE_SBOX4);
+  assign data_o    = perm_64bit(scrambled, PRESENT_PERM64);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_shift_rows.sv b/hw/ip/aes/rtl/aes_shift_rows.sv
index b33b570a0..ef9eea32b 100644
--- a/hw/ip/aes/rtl/aes_shift_rows.sv
+++ b/hw/ip/aes/rtl/aes_shift_rows.sv
@@ -6,24 +6,24 @@
 
 module aes_shift_rows (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Row 0 is left untouched
-  assign data_o[0] = data_i[0];
+  assign data_o[0] = data_i[0+:32];
 
   // Row 2 does not depend on op_i
-  assign data_o[2] = aes_circ_byte_shift(data_i[2], 2'h2);
+  assign data_o[2] = aes_circ_byte_shift(data_i[64+:32], 2'h2);
 
   // Row 1
-  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[1], 2'h3)
-                                        : aes_circ_byte_shift(data_i[1], 2'h1);
+  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[32+:32], 2'h3)
+                                        : aes_circ_byte_shift(data_i[32+:32], 2'h1);
 
   // Row 3
-  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[3], 2'h1)
-                                        : aes_circ_byte_shift(data_i[3], 2'h3);
+  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[96+:32], 2'h1)
+                                        : aes_circ_byte_shift(data_i[96+:32], 2'h3);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_sub_bytes.sv b/hw/ip/aes/rtl/aes_sub_bytes.sv
index 1d3e5c3a9..081c718f9 100644
--- a/hw/ip/aes/rtl/aes_sub_bytes.sv
+++ b/hw/ip/aes/rtl/aes_sub_bytes.sv
@@ -8,8 +8,8 @@ module aes_sub_bytes #(
   parameter SBoxImpl = "lut"
 ) (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   // Individually substitute bytes
@@ -19,8 +19,8 @@ module aes_sub_bytes #(
         .SBoxImpl ( SBoxImpl )
       ) aes_sbox_ij (
         .op_i   ( op_i         ),
-        .data_i ( data_i[i][j] ),
-        .data_o ( data_o[i][j] )
+        .data_i ( data_i[((i * 4) + j) * 8+:8] ),
+        .data_o ( data_o[((i * 4) + j) * 8+:8] )
       );
     end
   end
diff --git a/hw/ip/alert_handler/rtl/alert_pkg.sv b/hw/ip/alert_handler/rtl/alert_pkg.sv
index 5324b4978..fb9e8de6c 100644
--- a/hw/ip/alert_handler/rtl/alert_pkg.sv
+++ b/hw/ip/alert_handler/rtl/alert_pkg.sv
@@ -5,24 +5,20 @@
 
 package alert_pkg;
 
-  // these localparams are generated based on the system top-level configuration
-  localparam int unsigned      NAlerts   = alert_handler_reg_pkg::NAlerts;   // maximum 252
-  localparam int unsigned      EscCntDw  = alert_handler_reg_pkg::EscCntDw;  // maximum 32
-  localparam int unsigned      AccuCntDw = alert_handler_reg_pkg::AccuCntDw; // maximum 32
-  // seed for the ping timer (must be nonzero!)
-  localparam logic [31:0]      LfsrSeed  = alert_handler_reg_pkg::LfsrSeed;
-  // enable async transitions for specific RX/TX pairs
-  localparam bit [NAlerts-1:0] AsyncOn   = alert_handler_reg_pkg::AsyncOn;
-
-  // common constants, do not change
-  localparam int unsigned N_CLASSES   = alert_handler_reg_pkg::N_CLASSES;
-  localparam int unsigned N_ESC_SEV   = alert_handler_reg_pkg::N_ESC_SEV;
-  localparam int unsigned N_PHASES    = alert_handler_reg_pkg::N_PHASES;
-  localparam int unsigned N_LOC_ALERT = alert_handler_reg_pkg::N_LOC_ALERT;
-
-  localparam int unsigned PING_CNT_DW = alert_handler_reg_pkg::PING_CNT_DW;
-  localparam int unsigned PHASE_DW    = alert_handler_reg_pkg::PHASE_DW;
-  localparam int unsigned CLASS_DW    = alert_handler_reg_pkg::CLASS_DW;
+  // copied from alert_handler_reg_pkg as it is currently unparsable by
+  // yosys/surelog
+  parameter int NAlerts = 5;
+  parameter int EscCntDw = 32;
+  parameter int AccuCntDw = 16;
+  parameter int LfsrSeed = 2147483647;
+  parameter logic [NAlerts-1:0] AsyncOn = 5'b00000;
+  parameter int N_CLASSES = 4;
+  parameter int N_ESC_SEV = 4;
+  parameter int N_PHASES = 4;
+  parameter int N_LOC_ALERT = 4;
+  parameter int PING_CNT_DW = 24;
+  parameter int PHASE_DW = 2;
+  parameter int CLASS_DW = 2;
 
   // do not change the phase encoding
   typedef enum logic [2:0] {Idle = 3'b000, Timeout = 3'b001, Terminal = 3'b011,
@@ -68,9 +64,9 @@ package alert_pkg;
     logic [N_CLASSES-1:0]                              class_clr;          // clears esc/accu
     logic [N_CLASSES-1:0][AccuCntDw-1:0]               class_accum_thresh; // accum esc threshold
     logic [N_CLASSES-1:0][EscCntDw-1:0]                class_timeout_cyc;  // interrupt timeout
-    logic [N_CLASSES-1:0][N_PHASES-1:0][EscCntDw-1:0]  class_phase_cyc;    // length of phases 0..3
+    logic [511:0]  class_phase_cyc;    // length of phases 0..3
     logic [N_CLASSES-1:0][N_ESC_SEV-1:0]               class_esc_en;       // esc signal enables
-    logic [N_CLASSES-1:0][N_ESC_SEV-1:0][PHASE_DW-1:0] class_esc_map;      // esc signal/phase map
+    logic [31:0] class_esc_map;      // esc signal/phase map
   } reg2hw_wrap_t;
 
 endpackage : alert_pkg
diff --git a/hw/ip/flash_ctrl/rtl/flash_phy.sv b/hw/ip/flash_ctrl/rtl/flash_phy.sv
index 28ad2a12a..af2b735dd 100644
--- a/hw/ip/flash_ctrl/rtl/flash_phy.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_phy.sv
@@ -21,7 +21,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   input flash_req_t flash_ctrl_i,
   output flash_rsp_t flash_ctrl_o
 );
-
+  import flash_phy_pkg::*;
   // Flash macro outstanding refers to how many reads we allow a macro to move ahead of an
   // in order blocking read. Since the data cannot be returned out of order, this simply
   // does the reads in advance and store them in a FIFO
@@ -46,7 +46,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  host_rsp_avail;
   logic [NumBanks-1:0]  host_rsp_vld;
   logic [NumBanks-1:0]  host_rsp_ack;
-  logic [BusWidth-1:0]  host_rsp_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0]  host_rsp_data;
   logic                 seq_fifo_rdy;
   logic                 seq_fifo_pending;
 
@@ -59,7 +59,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  init_busy;
 
   // common interface
-  logic [BusWidth-1:0] rd_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0] rd_data;
 
   // select which bank each is operating on
   assign host_bank_sel = host_req_i ? host_addr_i[BusAddrW-1 -: BankW] : '0;
diff --git a/hw/ip/hmac/rtl/sha2_pad.sv b/hw/ip/hmac/rtl/sha2_pad.sv
index 5ee90881c..2667008be 100644
--- a/hw/ip/hmac/rtl/sha2_pad.sv
+++ b/hw/ip/hmac/rtl/sha2_pad.sv
@@ -89,7 +89,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       Pad00: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
 
       LenHi: begin
@@ -101,7 +101,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       default: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
     endcase
   end
@@ -298,9 +298,9 @@ module sha2_pad import hmac_pkg::*; (
   // tx_count
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (hash_start) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (inc_txcount) begin
       tx_count[63:5] <= tx_count[63:5] + 1'b1;
     end
diff --git a/hw/ip/otbn/rtl/otbn_core.sv b/hw/ip/otbn/rtl/otbn_core.sv
index 8b13db4f5..312277b5f 100644
--- a/hw/ip/otbn/rtl/otbn_core.sv
+++ b/hw/ip/otbn/rtl/otbn_core.sv
@@ -10,7 +10,6 @@
  * This module is the top-level of the OTBN processing core.
  */
 module otbn_core
-  import otbn_pkg::*;
 #(
   // Size of the instruction memory, in bytes
   parameter int ImemSizeByte = 4096,
@@ -40,9 +39,9 @@ module otbn_core
   output logic                     dmem_req_o,
   output logic                     dmem_write_o,
   output logic [DmemAddrWidth-1:0] dmem_addr_o,
-  output logic [WLEN-1:0]          dmem_wdata_o,
-  output logic [WLEN-1:0]          dmem_wmask_o,
-  input  logic [WLEN-1:0]          dmem_rdata_i,
+  output logic [256-1:0]          dmem_wdata_o,
+  output logic [256-1:0]          dmem_wmask_o,
+  input  logic [256-1:0]          dmem_rdata_i,
   input  logic                     dmem_rvalid_i,
   input  logic [1:0]               dmem_rerror_i
 );
diff --git a/hw/ip/otbn/rtl/otbn_reg_top.sv b/hw/ip/otbn/rtl/otbn_reg_top.sv
index 052cb2f5a..b62227975 100644
--- a/hw/ip/otbn/rtl/otbn_reg_top.sv
+++ b/hw/ip/otbn/rtl/otbn_reg_top.sv
@@ -54,13 +54,13 @@ module otbn_reg_top (
   logic [1:0] reg_steer;
 
   // socket_1n connection
-  assign tl_reg_h2d = tl_socket_h2d[2];
-  assign tl_socket_d2h[2] = tl_reg_d2h;
+  assign tl_reg_h2d = tl_socket_h2d[0];
 
-  assign tl_win_o[0] = tl_socket_h2d[0];
-  assign tl_socket_d2h[0] = tl_win_i[0];
-  assign tl_win_o[1] = tl_socket_h2d[1];
-  assign tl_socket_d2h[1] = tl_win_i[1];
+  assign tl_win_o[0] = tl_socket_h2d[1];
+  assign tl_win_o[1] = tl_socket_h2d[2];
+  assign tl_socket_d2h[0] = tl_reg_d2h;
+  assign tl_socket_d2h[1] = tl_win_i[0];
+  assign tl_socket_d2h[2] = tl_win_i[1];
 
   // Create Socket_1n
   tlul_socket_1n #(
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc.sv b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
index 9ec473f85..86bef1e9d 100644
--- a/hw/ip/prim/rtl/prim_arbiter_ppc.sv
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
@@ -113,12 +113,14 @@ module prim_arbiter_ppc #(
       end
     end else begin: gen_nodatapath
       assign data_o = '1;
-      // TODO: waive data_i from NOT_READ error
+      // The following signal is used to avoid possible lint errors.
+      logic [DW-1:0] unused_data [N];
+      assign unused_data = data_i;
     end
 
     always_comb begin
       idx_o = '0;
-      for (int i = 0 ; i < N ; i++) begin
+      for (int unsigned i = 0 ; i < N ; i++) begin
         if (winner[i]) begin
           idx_o = i[IdxW-1:0];
         end
@@ -222,4 +224,3 @@ end
 `endif
 
 endmodule : prim_arbiter_ppc
-
diff --git a/hw/ip/prim/rtl/prim_diff_decode.sv b/hw/ip/prim/rtl/prim_diff_decode.sv
index c06a77d77..8c9db0c61 100644
--- a/hw/ip/prim/rtl/prim_diff_decode.sv
+++ b/hw/ip/prim/rtl/prim_diff_decode.sv
@@ -42,9 +42,9 @@ module prim_diff_decode #(
   ///////////////////////////////////////////////////////////////
   // synchronization regs for incoming diff pair (if required) //
   ///////////////////////////////////////////////////////////////
+  typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
   if (AsyncOn) begin : gen_async
 
-    typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
     state_e state_d, state_q;
     logic diff_p_edge, diff_n_edge, diff_check_ok, level;
 
diff --git a/hw/ip/prim/rtl/prim_prince.sv b/hw/ip/prim/rtl/prim_prince.sv
index 423a7ca21..cb790a861 100644
--- a/hw/ip/prim/rtl/prim_prince.sv
+++ b/hw/ip/prim/rtl/prim_prince.sv
@@ -48,7 +48,7 @@ module prim_prince #(
   output logic                 valid_o,
   output logic [DataWidth-1:0] data_o
 );
-
+  import prim_cipher_pkg::*;
   ///////////////////
   // key expansion //
   ///////////////////
@@ -63,7 +63,7 @@ module prim_prince #(
     if (dec_i) begin
       k0          = k0_prime_d;
       k0_prime_d  = key_i[DataWidth-1:0];
-      k1_d       ^= prim_cipher_pkg::PRINCE_ALPHA_CONST[DataWidth-1:0];
+      k1_d       ^= PRINCE_ALPHA_CONST[DataWidth-1:0];
     end
   end
 
@@ -106,7 +106,7 @@ module prim_prince #(
   always_comb begin : p_pre_round_xor
     data_state[0] = data_i ^ k0;
     data_state[0] ^= k1_d;
-    data_state[0] ^= prim_cipher_pkg::PRINCE_ROUND_CONST[0][DataWidth-1:0];
+    data_state[0] ^= PRINCE_ROUND_CONST[0][DataWidth-1:0];
   end
 
   // forward pass
@@ -114,24 +114,24 @@ module prim_prince #(
     logic [DataWidth-1:0] data_state_round;
     if (DataWidth == 64) begin : gen_fwd_d64
       always_comb begin : p_fwd_d64
-        data_state_round = prim_cipher_pkg::sbox4_64bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_64bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_64bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_64bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_64bit(data_state_round);
+        data_state_round = prince_shiftrows_64bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end else begin : gen_fwd_d32
       always_comb begin : p_fwd_d32
-        data_state_round = prim_cipher_pkg::sbox4_32bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_32bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_32bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_32bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_32bit(data_state_round);
+        data_state_round = prince_shiftrows_32bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end
     logic [DataWidth-1:0] data_state_xor;
     assign data_state_xor = data_state_round ^
-                            prim_cipher_pkg::PRINCE_ROUND_CONST[k][DataWidth-1:0];
+                            PRINCE_ROUND_CONST[k][DataWidth-1:0];
     // improved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
     if (k % 2 == 1) assign data_state[k]  = data_state_xor ^ k0_new_d;
     else            assign data_state[k]  = data_state_xor ^ k1_d;
@@ -141,19 +141,19 @@ module prim_prince #(
   logic [DataWidth-1:0] data_state_middle_d, data_state_middle_q, data_state_middle;
   if (DataWidth == 64) begin : gen_middle_d64
     always_comb begin : p_middle_d64
-      data_state_middle_d = prim_cipher_pkg::sbox4_64bit(data_state[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_64bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_64bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_64bit(data_state[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_64bit(data_state_middle_q);
+      data_state_middle = sbox4_64bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end else begin : gen_middle_d32
     always_comb begin : p_middle_d32
-      data_state_middle_d = prim_cipher_pkg::sbox4_32bit(data_state_middle[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_32bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_32bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_32bit(data_state_middle[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_32bit(data_state_middle_q);
+      data_state_middle = sbox4_32bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end
 
@@ -187,24 +187,24 @@ module prim_prince #(
     else            assign data_state_xor0 = data_state[NumRoundsHalf+k] ^ k1_q;
     // the construction is reflective, hence the subtraction with NumRoundsHalf
     assign data_state_xor1 = data_state_xor0 ^
-                             prim_cipher_pkg::PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
+                             PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
 
     logic [DataWidth-1:0] data_state_bwd;
     if (DataWidth == 64) begin : gen_bwd_d64
       always_comb begin : p_bwd_d64
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_64bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_64bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_64bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_64bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_64bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_64bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end else begin : gen_bwd_d32
       always_comb begin : p_bwd_d32
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_32bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_32bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_32bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_32bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_32bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_32bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end
   end
@@ -212,7 +212,7 @@ module prim_prince #(
   // post-rounds
   always_comb begin : p_post_round_xor
     data_o  = data_state[2*NumRoundsHalf+1] ^
-              prim_cipher_pkg::PRINCE_ROUND_CONST[11][DataWidth-1:0];
+              PRINCE_ROUND_CONST[11][DataWidth-1:0];
     data_o ^= k1_q;
     data_o ^= k0_prime_q;
   end
diff --git a/hw/ip/prim/rtl/prim_ram_2p_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
index c6b466982..d34b942cd 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input                    clk_i,
   input                    rst_ni,
@@ -36,18 +36,18 @@ module prim_ram_2p_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -55,8 +55,8 @@ module prim_ram_2p_adv #(
 );
 
   prim_ram_2p_async_adv #(
-    .Depth               (Depth),
-    .Width               (Width),
+    .RamDepth               (RamDepth),
+    .RamWidth               (RamWidth),
     .DataBitsPerMask     (DataBitsPerMask),
     .CfgW                (CfgW),
     .MemInitFile         (MemInitFile),
diff --git a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
index 8436345d7..06efc7aca 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_async_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_async_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input clk_a_i,
   input clk_b_i,
@@ -38,18 +38,18 @@ module prim_ram_2p_async_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -67,14 +67,14 @@ module prim_ram_2p_async_adv #(
   localparam int LocalDataBitsPerMask = (EnableParity) ? 1 : DataBitsPerMask;
 
   // Calculate ECC width
-  localparam int ParWidth  = (EnableParity) ? Width/8 :
+  localparam int ParRamWidth  = (EnableParity) ? RamWidth/8 :
                              (!EnableECC)   ? 0 :
-                             (Width <=   4) ? 4 :
-                             (Width <=  11) ? 5 :
-                             (Width <=  26) ? 6 :
-                             (Width <=  57) ? 7 :
-                             (Width <= 120) ? 8 : 8 ;
-  localparam int TotalWidth = Width + ParWidth;
+                             (RamWidth <=   4) ? 4 :
+                             (RamWidth <=  11) ? 5 :
+                             (RamWidth <=  26) ? 6 :
+                             (RamWidth <=  57) ? 7 :
+                             (RamWidth <= 120) ? 8 : 8 ;
+  localparam int TotalRamWidth = RamWidth + ParRamWidth;
 
   ////////////////////////////
   // RAM Primitive Instance //
@@ -83,28 +83,28 @@ module prim_ram_2p_async_adv #(
   logic                    a_req_q,    a_req_d ;
   logic                    a_write_q,  a_write_d ;
   logic [Aw-1:0]           a_addr_q,   a_addr_d ;
-  logic [TotalWidth-1:0]   a_wdata_q,  a_wdata_d ;
-  logic [TotalWidth-1:0]   a_wmask_q,  a_wmask_d ;
+  logic [TotalRamWidth-1:0]   a_wdata_q,  a_wdata_d ;
+  logic [TotalRamWidth-1:0]   a_wmask_q,  a_wmask_d ;
   logic                    a_rvalid_q, a_rvalid_d, a_rvalid_sram ;
-  logic [Width-1:0]        a_rdata_q,  a_rdata_d ;
-  logic [TotalWidth-1:0]   a_rdata_sram ;
+  logic [RamWidth-1:0]        a_rdata_q,  a_rdata_d ;
+  logic [TotalRamWidth-1:0]   a_rdata_sram ;
   logic [1:0]              a_rerror_q, a_rerror_d ;
 
   logic                    b_req_q,    b_req_d ;
   logic                    b_write_q,  b_write_d ;
   logic [Aw-1:0]           b_addr_q,   b_addr_d ;
-  logic [TotalWidth-1:0]   b_wdata_q,  b_wdata_d ;
-  logic [TotalWidth-1:0]   b_wmask_q,  b_wmask_d ;
+  logic [TotalRamWidth-1:0]   b_wdata_q,  b_wdata_d ;
+  logic [TotalRamWidth-1:0]   b_wmask_q,  b_wmask_d ;
   logic                    b_rvalid_q, b_rvalid_d, b_rvalid_sram ;
-  logic [Width-1:0]        b_rdata_q,  b_rdata_d ;
-  logic [TotalWidth-1:0]   b_rdata_sram ;
+  logic [RamWidth-1:0]        b_rdata_q,  b_rdata_d ;
+  logic [TotalRamWidth-1:0]   b_rdata_sram ;
   logic [1:0]              b_rerror_q, b_rerror_d ;
 
   prim_ram_2p #(
     .MemInitFile     (MemInitFile),
 
-    .Width           (TotalWidth),
-    .Depth           (Depth),
+    .Width           (TotalRamWidth),
+    .Depth           (RamDepth),
     .DataBitsPerMask (LocalDataBitsPerMask)
   ) u_mem (
     .clk_a_i    (clk_a_i),
@@ -161,29 +161,29 @@ module prim_ram_2p_async_adv #(
   if (EnableParity == 0 && EnableECC) begin : gen_secded
 
     // check supported widths
-    `ASSERT_INIT(SecDecWidth_A, Width inside {32})
+    `ASSERT_INIT(SecDecRamWidth_A, RamWidth inside {32})
 
     // the wmask is constantly set to 1 in this case
     `ASSERT(OnlyWordWritePossibleWithEccPortA_A, a_req_i |->
-        a_wmask_i == {TotalWidth{1'b1}}, clk_a_i, rst_a_ni)
+        a_wmask_i == {TotalRamWidth{1'b1}}, clk_a_i, rst_a_ni)
     `ASSERT(OnlyWordWritePossibleWithEccPortB_A, b_req_i |->
-        b_wmask_i == {TotalWidth{1'b1}}, clk_b_i, rst_b_ni)
+        b_wmask_i == {TotalRamWidth{1'b1}}, clk_b_i, rst_b_ni)
 
-    assign a_wmask_d = {TotalWidth{1'b1}};
-    assign b_wmask_d = {TotalWidth{1'b1}};
+    assign a_wmask_d = {TotalRamWidth{1'b1}};
+    assign b_wmask_d = {TotalRamWidth{1'b1}};
 
-    if (Width == 32) begin : gen_secded_39_32
+    if (RamWidth == 32) begin : gen_secded_39_32
       prim_secded_39_32_enc u_enc_a (.in(a_wdata_i), .out(a_wdata_d));
       prim_secded_39_32_dec u_dec_a (
         .in         (a_rdata_sram),
-        .d_o        (a_rdata_d[0+:Width]),
+        .d_o        (a_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (a_rerror_d)
       );
       prim_secded_39_32_enc u_enc_b (.in(b_wdata_i), .out(b_wdata_d));
       prim_secded_39_32_dec u_dec_b (
         .in         (b_rdata_sram),
-        .d_o        (b_rdata_d[0+:Width]),
+        .d_o        (b_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (b_rerror_d)
       );
@@ -191,40 +191,40 @@ module prim_ram_2p_async_adv #(
   end else if (EnableParity) begin : gen_byte_parity
 
     `ASSERT_INIT(ParityNeedsByteWriteMask_A, DataBitsPerMask == 8)
-    `ASSERT_INIT(WidthNeedsToBeByteAligned_A, Width % 8 == 0)
+    `ASSERT_INIT(RamWidthNeedsToBeByteAligned_A, RamWidth % 8 == 0)
 
     always_comb begin : p_parity
       a_rerror_d = '0;
       b_rerror_d = '0;
-      a_wmask_d[0+:Width] = a_wmask_i;
-      b_wmask_d[0+:Width] = b_wmask_i;
-      a_wdata_d[0+:Width] = a_wdata_i;
-      b_wdata_d[0+:Width] = b_wdata_i;
+      a_wmask_d[0+:RamWidth] = a_wmask_i;
+      b_wmask_d[0+:RamWidth] = b_wmask_i;
+      a_wdata_d[0+:RamWidth] = a_wdata_i;
+      b_wdata_d[0+:RamWidth] = b_wdata_i;
 
-      for (int i = 0; i < Width/8; i ++) begin
+      for (int i = 0; i < RamWidth/8; i ++) begin
         // parity generation (odd parity)
-        a_wdata_d[Width + i] = ~(^a_wdata_i[i*8 +: 8]);
-        b_wdata_d[Width + i] = ~(^b_wdata_i[i*8 +: 8]);
-        a_wmask_d[Width + i] = &a_wmask_i[i*8 +: 8];
-        b_wmask_d[Width + i] = &b_wmask_i[i*8 +: 8];
+        a_wdata_d[RamWidth + i] = ~(^a_wdata_i[i*8 +: 8]);
+        b_wdata_d[RamWidth + i] = ~(^b_wdata_i[i*8 +: 8]);
+        a_wmask_d[RamWidth + i] = &a_wmask_i[i*8 +: 8];
+        b_wmask_d[RamWidth + i] = &b_wmask_i[i*8 +: 8];
         // parity decoding (errors are always uncorrectable)
-        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[Width + i]});
-        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[Width + i]});
+        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[RamWidth + i]});
+        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[RamWidth + i]});
       end
       // tie to zero if the read data is not valid
       a_rerror_d &= {2{a_rvalid_sram}};
       b_rerror_d &= {2{b_rvalid_sram}};
     end
 
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
   end else begin : gen_nosecded_noparity
     assign a_wmask_d  = a_wmask_i;
     assign b_wmask_d  = b_wmask_i;
     assign a_wdata_d  = a_wdata_i;
     assign b_wdata_d  = b_wdata_i;
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
     assign a_rerror_d = '0;
     assign b_rerror_d = '0;
   end
diff --git a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
index 962d3b559..d6430bc5a 100644
--- a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
+++ b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
@@ -70,10 +70,10 @@ module prim_generic_pad_wrapper #(
     assign oe       = oe_i & ((od & ~out) | ~od);
 
   // driving strength attributes are not supported by verilator
-`ifdef VERILATOR
-    assign inout_io = (oe)   ? out : 1'bz;
+`ifdef SYNTHESIS
+    assign inout_io = out;
     // received data driver
-    assign in_o     = (ie_i) ? in  : 1'bz;
+    assign in_o     = in;
 `else
     // different driver types
     assign (strong0, strong1) inout_io = (oe && drv != DRIVE_00) ? out : 1'bz;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
index c4ccd9b2d..5229b6a82 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
@@ -54,6 +54,8 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
 
 );
 
+  import pwrmgr_pkg::*;
+
   ////////////////////////////////
   // Sync from clk_i to clk_slow_i
   ////////////////////////////////
@@ -137,11 +139,11 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
   // only register configurations can be sync'd using slow_cdc_sync
   always_ff @(posedge clk_slow_i or negedge rst_slow_ni) begin
     if (!rst_slow_ni) begin
-      slow_wakeup_en_o <= '0;
-      slow_reset_en_o <= '0;
-      slow_main_pd_no <= '0;
-      slow_io_clk_en_o <= '0;
-      slow_core_clk_en_o <= '0;
+      slow_wakeup_en_o <= 16'h0000;
+      slow_reset_en_o <= 2'b00;
+      slow_main_pd_no <= 1'b0;
+      slow_io_clk_en_o <= 1'b0;
+      slow_core_clk_en_o <= 1'b0;
     end else if (slow_cdc_sync) begin
       slow_wakeup_en_o <= wakeup_en_i;
       slow_reset_en_o <= reset_en_i;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
index ef4712bf5..336e2ff7d 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
@@ -131,7 +131,7 @@ module pwrmgr_fsm import pwrmgr_pkg::*; (
     end
   end
 
-  always_comb begin
+  always begin
     otp_init = 1'b0;
     lc_init = 1'b0;
     wkup_o = 1'b0;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
index a5669d597..4f39a8b53 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
@@ -35,19 +35,9 @@ package pwrmgr_pkg;
   } pwr_ast_rsp_t;
 
   // default value of pwr_ast_rsp (for dangling ports)
-  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = '{
-    slow_clk_val: 2'b10,
-    core_clk_val: 2'b10,
-    io_clk_val: 2'b10,
-    main_pok: 1'b1
-  };
-
-  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = '{
-    slow_clk_val: 2'b01,
-    core_clk_val: 2'b01,
-    io_clk_val: 2'b10,
-    main_pok: 1'b0
-  };
+  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = 7'b1010101;
+
+  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = 7'b0101100;
 
   // reasons for pwrmgr reset reset
   typedef enum logic [1:0] {
@@ -71,10 +61,7 @@ package pwrmgr_pkg;
   } pwr_rst_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = '{
-    rst_lc_src_n: {PowerDomains{1'b1}},
-    rst_sys_src_n: {PowerDomains{1'b1}}
-  };
+  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = 4'b1111;
 
   // pwrmgr to clkmgr
   typedef struct packed {
@@ -98,10 +85,7 @@ package pwrmgr_pkg;
   } pwr_otp_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = '{
-    otp_done: 1'b1,
-    otp_idle: 1'b1
-  };
+  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = 2'b11;
 
   // pwrmgr to lifecycle
   typedef struct packed {
@@ -115,10 +99,7 @@ package pwrmgr_pkg;
   } pwr_lc_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = '{
-    lc_done: 1'b1,
-    lc_idle: 1'b1
-  };
+  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = 2'b11;
 
   // flash to pwrmgr
   typedef struct packed {
@@ -126,9 +107,7 @@ package pwrmgr_pkg;
   } pwr_flash_t;
 
   // default value (for dangling ports)
-  parameter pwr_flash_t PWR_FLASH_DEFAULT = '{
-    flash_idle: 1'b1
-  };
+  parameter pwr_flash_t PWR_FLASH_DEFAULT = 1'b1;
 
   // processor to pwrmgr
   typedef struct packed {
@@ -136,13 +115,11 @@ package pwrmgr_pkg;
   } pwr_cpu_t;
 
   // default value (for dangling ports)
-  parameter pwr_cpu_t PWR_CPU_DEFAULT = '{
-    core_sleeping: 1'b0
-  };
+  parameter pwr_cpu_t PWR_CPU_DEFAULT = 1'b0;
 
   // default value (for dangling ports)
-  parameter int WAKEUPS_DEFAULT = '0;
-  parameter int RSTREQS_DEFAULT = '0;
+  parameter int WAKEUPS_DEFAULT = 0;
+  parameter int RSTREQS_DEFAULT = 0;
 
   // peripherals to pwrmgr
   typedef struct packed {
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
index 4a6a9d709..3c755c66f 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
@@ -116,7 +116,7 @@ package pwrmgr_reg_pkg;
     pwrmgr_reg2hw_intr_test_reg_t intr_test; // [47:46]
     pwrmgr_reg2hw_control_reg_t control; // [45:42]
     pwrmgr_reg2hw_cfg_cdc_sync_reg_t cfg_cdc_sync; // [41:40]
-    pwrmgr_reg2hw_wakeup_en_mreg_t [15:0] wakeup_en; // [39:24]
+    logic [15:0] wakeup_en; // [39:24]
     pwrmgr_reg2hw_reset_en_reg_t reset_en; // [23:22]
     pwrmgr_reg2hw_wake_info_capture_dis_reg_t wake_info_capture_dis; // [21:21]
     pwrmgr_reg2hw_wake_info_reg_t wake_info; // [20:0]
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
index 6080cf464..31418f345 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
@@ -456,7 +456,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[0].q ),
+    .q      (reg2hw.wakeup_en[0] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en0_qs)
@@ -482,7 +482,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[1].q ),
+    .q      (reg2hw.wakeup_en[1] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en1_qs)
@@ -508,7 +508,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[2].q ),
+    .q      (reg2hw.wakeup_en[2] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en2_qs)
@@ -534,7 +534,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[3].q ),
+    .q      (reg2hw.wakeup_en[3] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en3_qs)
@@ -560,7 +560,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[4].q ),
+    .q      (reg2hw.wakeup_en[4] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en4_qs)
@@ -586,7 +586,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[5].q ),
+    .q      (reg2hw.wakeup_en[5] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en5_qs)
@@ -612,7 +612,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[6].q ),
+    .q      (reg2hw.wakeup_en[6] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en6_qs)
@@ -638,7 +638,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[7].q ),
+    .q      (reg2hw.wakeup_en[7] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en7_qs)
@@ -664,7 +664,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[8].q ),
+    .q      (reg2hw.wakeup_en[8] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en8_qs)
@@ -690,7 +690,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[9].q ),
+    .q      (reg2hw.wakeup_en[9] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en9_qs)
@@ -716,7 +716,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[10].q ),
+    .q      (reg2hw.wakeup_en[10] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en10_qs)
@@ -742,7 +742,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[11].q ),
+    .q      (reg2hw.wakeup_en[11] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en11_qs)
@@ -768,7 +768,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[12].q ),
+    .q      (reg2hw.wakeup_en[12] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en12_qs)
@@ -794,7 +794,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[13].q ),
+    .q      (reg2hw.wakeup_en[13] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en13_qs)
@@ -820,7 +820,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[14].q ),
+    .q      (reg2hw.wakeup_en[14] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en14_qs)
@@ -846,7 +846,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[15].q ),
+    .q      (reg2hw.wakeup_en[15] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en15_qs)
diff --git a/hw/ip/spi_device/rtl/spi_device.sv b/hw/ip/spi_device/rtl/spi_device.sv
index f7f9ed1bf..0b0fd2f7e 100644
--- a/hw/ip/spi_device/rtl/spi_device.sv
+++ b/hw/ip/spi_device/rtl/spi_device.sv
@@ -519,8 +519,8 @@ module spi_device #(
 
   // SRAM Wrapper
   prim_ram_2p_adv #(
-    .Depth (512),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (512),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .DataBitsPerMask (1),
     .CfgW  (8),
 
diff --git a/hw/ip/tlul/rtl/tlul_adapter_reg.sv b/hw/ip/tlul/rtl/tlul_adapter_reg.sv
index c451308bd..a0dd153b8 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_reg.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_reg.sv
@@ -30,8 +30,8 @@ module tlul_adapter_reg import tlul_pkg::*; #(
   input                    error_i
 );
 
-  localparam int IW  = $bits(tl_i.a_source);
-  localparam int SZW = $bits(tl_i.a_size);
+  localparam int IW  = 8;
+  localparam int SZW = 2;
 
   logic outstanding;    // Indicates current request is pending
   logic a_ack, d_ack;
@@ -69,8 +69,8 @@ module tlul_adapter_reg import tlul_pkg::*; #(
 
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      reqid <= '0;
-      reqsz <= '0;
+      reqid <= {IW{1'b0}};
+      reqsz <= {SZW{1'b0}};
       rspop <= AccessAck;
     end else if (a_ack) begin
       reqid <= tl_i.a_source;
@@ -82,10 +82,10 @@ module tlul_adapter_reg import tlul_pkg::*; #(
 
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      rdata  <= '0;
+      rdata  <= {RegDw{1'b0}};
       error <= 1'b0;
     end else if (a_ack) begin
-      rdata <= (err_internal) ? '1 : rdata_i;
+      rdata <= (err_internal) ? {RegDw{1'b1}} : rdata_i;
       error <= error_i | err_internal;
     end
   end
@@ -94,12 +94,12 @@ module tlul_adapter_reg import tlul_pkg::*; #(
     a_ready:  ~outstanding,
     d_valid:  outstanding,
     d_opcode: rspop,
-    d_param:  '0,
+    d_param:  3'b000,
     d_size:   reqsz,
     d_source: reqid,
-    d_sink:   '0,
+    d_sink:   1'b0,
     d_data:   rdata,
-    d_user:  '0,
+    d_user:  16'b0000000000000000,
     d_error: error
   };
 
diff --git a/hw/ip/tlul/rtl/tlul_adapter_sram.sv b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
index 6e2f33191..cb3e9088c 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_sram.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
@@ -174,7 +174,7 @@ module tlul_adapter_sram #(
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wmask_int;
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wdata_int;
 
-  always_comb begin
+  always begin
     wmask_int = '0;
     wdata_int = '0;
 
diff --git a/hw/ip/tlul/rtl/tlul_err.sv b/hw/ip/tlul/rtl/tlul_err.sv
index add8477ba..4ab895782 100644
--- a/hw/ip/tlul/rtl/tlul_err.sv
+++ b/hw/ip/tlul/rtl/tlul_err.sv
@@ -14,11 +14,11 @@ module tlul_err import tlul_pkg::*; (
   output logic err_o
 );
 
-  localparam int IW  = $bits(tl_i.a_source);
-  localparam int SZW = $bits(tl_i.a_size);
-  localparam int DW  = $bits(tl_i.a_data);
-  localparam int MW  = $bits(tl_i.a_mask);
-  localparam int SubAW = $clog2(DW/8);
+  localparam int IW  = 8;
+  localparam int SZW = 2;
+  localparam int DW  = 32;
+  localparam int MW  = 4;
+  localparam int SubAW = 2;
 
   logic opcode_allowed, a_config_allowed;
 
@@ -42,7 +42,7 @@ module tlul_err import tlul_pkg::*; (
 
   logic [MW-1:0] mask;
 
-  assign mask = (1 << tl_i.a_address[SubAW-1:0]);
+  assign mask = (1 << $unsigned(tl_i.a_address[SubAW-1:0]));
 
   always_comb begin
     addr_sz_chk  = 1'b0;
@@ -51,13 +51,13 @@ module tlul_err import tlul_pkg::*; (
 
     if (tl_i.a_valid) begin
       unique case (tl_i.a_size)
-        'h0: begin // 1 Byte
+        64'h0: begin // 1 Byte
           addr_sz_chk  = 1'b1;
           mask_chk     = ~|(tl_i.a_mask & ~mask);
           fulldata_chk = |(tl_i.a_mask & mask);
         end
 
-        'h1: begin // 2 Byte
+        64'h1: begin // 2 Byte
           addr_sz_chk  = ~tl_i.a_address[0];
           // check inactive lanes if lower 2B, check a_mask[3:2], if uppwer 2B, a_mask[1:0]
           mask_chk     = (tl_i.a_address[1]) ? ~|(tl_i.a_mask & 4'b0011)
@@ -65,7 +65,7 @@ module tlul_err import tlul_pkg::*; (
           fulldata_chk = (tl_i.a_address[1]) ? &tl_i.a_mask[3:2] : &tl_i.a_mask[1:0] ;
         end
 
-        'h2: begin // 4 Byte
+        64'h2: begin // 4 Byte
           addr_sz_chk  = ~|tl_i.a_address[SubAW-1:0];
           mask_chk     = 1'b1;
           fulldata_chk = &tl_i.a_mask[3:0];
diff --git a/hw/ip/tlul/rtl/tlul_fifo_sync.sv b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
index 59fe3ffd4..071a30b94 100644
--- a/hw/ip/tlul/rtl/tlul_fifo_sync.sv
+++ b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
@@ -7,8 +7,8 @@
 // and one for the response side.
 
 module tlul_fifo_sync #(
-  parameter int unsigned ReqPass  = 1'b1,
-  parameter int unsigned RspPass  = 1'b1,
+  parameter int unsigned ReqPass  = 0,
+  parameter int unsigned RspPass  = 0,
   parameter int unsigned ReqDepth = 2,
   parameter int unsigned RspDepth = 2,
   parameter int unsigned SpareReqW = 1,
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1.sv b/hw/ip/tlul/rtl/tlul_socket_m1.sv
index 8637ad221..fe7aa9858 100644
--- a/hw/ip/tlul/rtl/tlul_socket_m1.sv
+++ b/hw/ip/tlul/rtl/tlul_socket_m1.sv
@@ -92,9 +92,11 @@ module tlul_socket_m1 #(
     // ID Shifting
     logic [STIDW-1:0] reqid_sub;
     logic [IDW-1:0] shifted_id;
+    logic [7:0] tmp;
+    assign tmp = tl_h_i[i].a_source;
     assign reqid_sub = i;   // can cause conversion error?
     assign shifted_id = {
-      tl_h_i[i].a_source[0+:(IDW-STIDW)],
+      tmp[0+:(IDW-STIDW)],
       reqid_sub
     };
 
@@ -102,21 +104,19 @@ module tlul_socket_m1 #(
 
     // assign not connected bits to nc_* signal to make lint happy
     logic [IDW-1 : IDW-STIDW] unused_tl_h_source;
-    assign unused_tl_h_source = tl_h_i[i].a_source[IDW-1 -: STIDW];
+    assign unused_tl_h_source = tmp[IDW-1 -: STIDW];
 
     // Put shifted ID
-    assign hreq_fifo_i = '{
-      a_valid:    tl_h_i[i].a_valid,
-      a_opcode:   tl_h_i[i].a_opcode,
-      a_param:    tl_h_i[i].a_param,
-      a_size:     tl_h_i[i].a_size,
-      a_source:   shifted_id,
-      a_address:  tl_h_i[i].a_address,
-      a_mask:     tl_h_i[i].a_mask,
-      a_data:     tl_h_i[i].a_data,
-      a_user:     tl_h_i[i].a_user,
-      d_ready:    tl_h_i[i].d_ready
-    };
+    assign hreq_fifo_i.a_valid = tl_h_i[i].a_valid;
+    assign hreq_fifo_i.a_opcode = tl_h_i[i].a_opcode;
+    assign hreq_fifo_i.a_param = tl_h_i[i].a_param;
+    assign hreq_fifo_i.a_size = tl_h_i[i].a_size;
+    assign hreq_fifo_i.a_source = shifted_id;
+    assign hreq_fifo_i.a_address = tl_h_i[i].a_address;
+    assign hreq_fifo_i.a_mask = tl_h_i[i].a_mask;
+    assign hreq_fifo_i.a_data = tl_h_i[i].a_data;
+    assign hreq_fifo_i.a_user = tl_h_i[i].a_user;
+    assign hreq_fifo_i.d_ready = tl_h_i[i].d_ready;
 
     tlul_fifo_sync #(
       .ReqPass    (HReqPass[i]),
@@ -237,18 +237,16 @@ module tlul_socket_m1 #(
                                (drsp_fifo_o.d_source[0+:STIDW] == i) &
                               drsp_fifo_o.d_valid;
 
-    assign hrsp_fifo_i[i] = '{
-      d_valid:  hfifo_rspvalid[i],
-      d_opcode: drsp_fifo_o.d_opcode,
-      d_param:  drsp_fifo_o.d_param,
-      d_size:   drsp_fifo_o.d_size,
-      d_source: hfifo_rspid,
-      d_sink:   drsp_fifo_o.d_sink,
-      d_data:   drsp_fifo_o.d_data,
-      d_user:   drsp_fifo_o.d_user,
-      d_error:  drsp_fifo_o.d_error,
-      a_ready:  hgrant[i]
-    };
+    assign hrsp_fifo_i[i].d_valid = hfifo_rspvalid[i];
+    assign hrsp_fifo_i[i].d_opcode = drsp_fifo_o.d_opcode;
+    assign hrsp_fifo_i[i].d_param = drsp_fifo_o.d_param;
+    assign hrsp_fifo_i[i].d_size = drsp_fifo_o.d_size;
+    assign hrsp_fifo_i[i].d_source = hfifo_rspid;
+    assign hrsp_fifo_i[i].d_sink = drsp_fifo_o.d_sink;
+    assign hrsp_fifo_i[i].d_data = drsp_fifo_o.d_data;
+    assign hrsp_fifo_i[i].d_user = drsp_fifo_o.d_user;
+    assign hrsp_fifo_i[i].d_error = drsp_fifo_o.d_error;
+    assign hrsp_fifo_i[i].a_ready = hgrant[i];
   end
 
   // this assertion fails when rspid[0+:STIDW] not in [0..M-1]
diff --git a/hw/ip/uart/rtl/uart_reg_top.sv b/hw/ip/uart/rtl/uart_reg_top.sv
index f25d459ef..c5ea11cb2 100644
--- a/hw/ip/uart/rtl/uart_reg_top.sv
+++ b/hw/ip/uart/rtl/uart_reg_top.sv
@@ -949,7 +949,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (2'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -975,7 +975,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (16'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -1085,7 +1085,7 @@ module uart_reg_top (
   ) u_rdata (
     .re     (rdata_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (8'b0),
     .d      (hw2reg.rdata.d),
     .qre    (reg2hw.rdata.re),
     .qe     (),
@@ -1110,7 +1110,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (8'b0  ),
 
     // to internal hardware
     .qe     (reg2hw.wdata.qe),
@@ -1232,7 +1232,7 @@ module uart_reg_top (
   ) u_fifo_status_txlvl (
     .re     (fifo_status_txlvl_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (6'b0),
     .d      (hw2reg.fifo_status.txlvl.d),
     .qre    (),
     .qe     (),
@@ -1247,7 +1247,7 @@ module uart_reg_top (
   ) u_fifo_status_rxlvl (
     .re     (fifo_status_rxlvl_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (6'b0),
     .d      (hw2reg.fifo_status.rxlvl.d),
     .qre    (),
     .qe     (),
@@ -1317,7 +1317,7 @@ module uart_reg_top (
   ) u_val (
     .re     (val_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (16'b0),
     .d      (hw2reg.val.d),
     .qre    (),
     .qe     (),
@@ -1343,7 +1343,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (24'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -1384,7 +1384,7 @@ module uart_reg_top (
 
   logic [11:0] addr_hit;
   always_comb begin
-    addr_hit = '0;
+    addr_hit = 12'b000000000000;
     addr_hit[ 0] = (reg_addr == UART_INTR_STATE_OFFSET);
     addr_hit[ 1] = (reg_addr == UART_INTR_ENABLE_OFFSET);
     addr_hit[ 2] = (reg_addr == UART_INTR_TEST_OFFSET);
@@ -1566,7 +1566,7 @@ module uart_reg_top (
 
   // Read data return
   always_comb begin
-    reg_rdata_next = '0;
+    reg_rdata_next = {DW{1'b0}};
     unique case (1'b1)
       addr_hit[0]: begin
         reg_rdata_next[0] = intr_state_tx_watermark_qs;
@@ -1627,7 +1627,7 @@ module uart_reg_top (
       end
 
       addr_hit[6]: begin
-        reg_rdata_next[7:0] = '0;
+        reg_rdata_next[7:0] = {8{1'b0}};
       end
 
       addr_hit[7]: begin
@@ -1657,7 +1657,7 @@ module uart_reg_top (
       end
 
       default: begin
-        reg_rdata_next = '1;
+        reg_rdata_next = {DW{1'b1}};
       end
     endcase
   end
diff --git a/hw/ip/usbdev/rtl/usbdev.sv b/hw/ip/usbdev/rtl/usbdev.sv
index cbdadd624..42a4d1b7a 100644
--- a/hw/ip/usbdev/rtl/usbdev.sv
+++ b/hw/ip/usbdev/rtl/usbdev.sv
@@ -563,7 +563,7 @@ module usbdev (
 
   // CDC for event signals (arguably they are there for a long time so would be ok)
   // Just want a pulse to ensure only one interrupt for an event
-  usbdev_flop_2syncpulse #(.Width(5)) syncevent (
+  usbdev_flop_2syncpulse #(.UsbWidth(5)) syncevent (
     .clk_i  (clk_i),
     .rst_ni (rst_ni),
     .d_i    ({usb_event_disconnect, usb_event_link_reset, usb_event_link_suspend,
@@ -654,8 +654,8 @@ module usbdev (
 
   // SRAM Wrapper
   prim_ram_2p_async_adv #(
-    .Depth (SramDepth),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (SramDepth),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .CfgW  (8),
 
     .EnableECC           (0), // No Protection
diff --git a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
index 9889b0a1f..9b297e67f 100644
--- a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
+++ b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
@@ -5,17 +5,17 @@
 // Generic double-synchronizer flop followed by pulse generation
 
 module usbdev_flop_2syncpulse #(
-  parameter int unsigned Width = 16
+  parameter int unsigned UsbWidth = 16
 ) (
   input  logic             clk_i,    // receive clock
   input  logic             rst_ni,
-  input  logic [Width-1:0] d_i,
-  output logic [Width-1:0] q_o
+  input  logic [UsbWidth-1:0] d_i,
+  output logic [UsbWidth-1:0] q_o
 );
 
   // double-flop synchronizer cell
-  logic [Width-1:0] d_sync;
-  prim_flop_2sync #(.Width (Width)) prim_flop_2sync (
+  logic [UsbWidth-1:0] d_sync;
+  prim_flop_2sync #(.Width (UsbWidth)) prim_flop_2sync (
     .clk_i,
     .rst_ni,
     .d_i,
@@ -23,7 +23,7 @@ module usbdev_flop_2syncpulse #(
   );
 
   // delay d_sync by 1 cycle
-  logic [Width-1:0] d_sync_q;
+  logic [UsbWidth-1:0] d_sync_q;
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
       d_sync_q <= '0;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
index 61469937f..12f0a2bcd 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
@@ -133,8 +133,8 @@ module ibex_core #(
   logic [31:0] pc_if;                          // Program counter in IF stage
   logic [31:0] pc_id;                          // Program counter in ID stage
   logic [31:0] pc_wb;                          // Program counter in WB stage
-  logic [33:0] imd_val_d_ex[2];                // Intermediate register for multicycle Ops
-  logic [33:0] imd_val_q_ex[2];                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_d_ex;                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_q_ex;                // Intermediate register for multicycle Ops
   logic [1:0]  imd_val_we_ex;
 
   logic        data_ind_timing;
@@ -254,7 +254,7 @@ module ibex_core #(
   logic [31:0] csr_mepc, csr_depc;
 
   // PMP signals
-  logic [33:0] csr_pmp_addr [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0] csr_pmp_addr;
   pmp_cfg_t    csr_pmp_cfg  [PMPNumRegions];
   logic        pmp_req_err  [PMP_NUM_CHAN];
   logic        instr_req_out;
@@ -932,16 +932,16 @@ module ibex_core #(
   `ASSERT_KNOWN_IF(IbexCsrWdataIntKnown, cs_registers_i.csr_wdata_int, csr_op_en)
 
   if (PMPEnable) begin : g_pmp
-    logic [33:0] pmp_req_addr [PMP_NUM_CHAN];
-    pmp_req_e    pmp_req_type [PMP_NUM_CHAN];
-    priv_lvl_e   pmp_priv_lvl [PMP_NUM_CHAN];
-
-    assign pmp_req_addr[PMP_I] = {2'b00,instr_addr_o[31:0]};
-    assign pmp_req_type[PMP_I] = PMP_ACC_EXEC;
-    assign pmp_priv_lvl[PMP_I] = priv_mode_if;
-    assign pmp_req_addr[PMP_D] = {2'b00,data_addr_o[31:0]};
-    assign pmp_req_type[PMP_D] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
-    assign pmp_priv_lvl[PMP_D] = priv_mode_lsu;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_req_type;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_priv_lvl;
+    logic [PMP_NUM_CHAN-1:0][33:0] pmp_req_addr;
+
+    assign pmp_req_addr[PMP_D] = {2'b00,instr_addr_o[31:0]};
+    assign pmp_req_type[PMP_D] = PMP_ACC_EXEC;
+    assign pmp_priv_lvl[PMP_D] = priv_mode_if;
+    assign pmp_req_addr[PMP_I] = {2'b00,data_addr_o[31:0]};
+    assign pmp_req_type[PMP_I] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
+    assign pmp_priv_lvl[PMP_I] = priv_mode_lsu;
 
     ibex_pmp #(
         .PMPGranularity        ( PMPGranularity ),
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
index 6e5eaf4dc..d99e087d6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
@@ -64,7 +64,7 @@ module ibex_cs_registers #(
 
     // PMP
     output ibex_pkg::pmp_cfg_t   csr_pmp_cfg_o  [PMPNumRegions],
-    output logic [33:0]          csr_pmp_addr_o [PMPNumRegions],
+    output logic [PMPNumRegions-1:0][33:0]          csr_pmp_addr_o,
 
     // debug
     input  logic                 debug_mode_i,
@@ -196,8 +196,8 @@ module ibex_cs_registers #(
   logic  [5:0] mstack_cause_q, mstack_cause_d;
 
   // PMP Signals
-  logic [31:0]                 pmp_addr_rdata  [PMP_MAX_REGIONS];
-  logic [PMP_CFG_W-1:0]        pmp_cfg_rdata   [PMP_MAX_REGIONS];
+  logic [PMP_MAX_REGIONS-1:0][31:0]                 pmp_addr_rdata;
+  logic [PMP_MAX_REGIONS-1:0][PMP_CFG_W-1:0]        pmp_cfg_rdata;
 
   // Hardware performance monitor signals
   logic [31:0]                 mcountinhibit;
@@ -208,11 +208,11 @@ module ibex_cs_registers #(
   // mhpmcounter flops are elaborated below providing only the precise number that is required based
   // on MHPMCounterNum/MHPMCounterWidth. This signal connects to the Q output of these flops
   // where they exist and is otherwise 0.
-  logic [63:0] mhpmcounter [32];
+  logic [31:0][63:0] mhpmcounter;
   logic [31:0] mhpmcounter_we;
   logic [31:0] mhpmcounterh_we;
   logic [31:0] mhpmcounter_incr;
-  logic [31:0] mhpmevent [32];
+  logic [31:0][31:0] mhpmevent;
   logic  [4:0] mhpmcounter_idx;
 
   // Debug / trigger registers
@@ -736,12 +736,12 @@ module ibex_cs_registers #(
   // PMP registers
   // -----------------
 
+  pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
+  pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
+  logic [PMPNumRegions-1:0][31:0]                 pmp_addr;
+  logic [PMPNumRegions-1:0]    pmp_cfg_we;
+  logic [PMPNumRegions-1:0]    pmp_addr_we;
   if (PMPEnable) begin : g_pmp_registers
-    pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
-    pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
-    logic [31:0]                 pmp_addr        [PMPNumRegions];
-    logic [PMPNumRegions-1:0]    pmp_cfg_we;
-    logic [PMPNumRegions-1:0]    pmp_addr_we;
 
     // Expanded / qualified register read data
     for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
index eccc68e95..06a672e88 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
@@ -42,8 +42,8 @@ module ibex_ex_block #(
 
     // intermediate val reg
     output logic [1:0]            imd_val_we_o,
-    output logic [33:0]           imd_val_d_o[2],
-    input  logic [33:0]           imd_val_q_i[2],
+    output logic [1:0][33:0]           imd_val_d_o,
+    input  logic [1:0][33:0]           imd_val_q_i,
 
     // Outputs
     output logic [31:0]           alu_adder_result_ex_o, // to LSU
@@ -63,10 +63,10 @@ module ibex_ex_block #(
   logic        alu_cmp_result, alu_is_equal_result;
   logic        multdiv_valid;
   logic        multdiv_sel;
-  logic [31:0] alu_imd_val_q[2];
-  logic [31:0] alu_imd_val_d[2];
+  logic [1:0][31:0] alu_imd_val_q;
+  logic [1:0][31:0] alu_imd_val_d;
   logic [ 1:0] alu_imd_val_we;
-  logic [33:0] multdiv_imd_val_d[2];
+  logic [1:0][33:0] multdiv_imd_val_d;
   logic [ 1:0] multdiv_imd_val_we;
 
   /*
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
index bba4c2af8..a4fbb8da6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
@@ -21,9 +21,9 @@ module ibex_id_stage #(
     parameter bit               RV32M           = 1,
     parameter ibex_pkg::rv32b_e RV32B           = ibex_pkg::RV32BNone,
     parameter bit               DataIndTiming   = 1'b0,
-    parameter bit               BranchTargetALU = 0,
-    parameter bit               SpecBranch      = 0,
-    parameter bit               WritebackStage  = 0
+    parameter bit               BranchTargetALU = 1,
+    parameter bit               SpecBranch      = 1,
+    parameter bit               WritebackStage  = 1
 ) (
     input  logic                      clk_i,
     input  logic                      rst_ni,
@@ -69,8 +69,8 @@ module ibex_id_stage #(
 
     // Multicycle Operation Stage Register
     input  logic [1:0]                imd_val_we_ex_i,
-    input  logic [33:0]               imd_val_d_ex_i[2],
-    output logic [33:0]               imd_val_q_ex_o[2],
+    input  logic [1:0][33:0]               imd_val_d_ex_i,
+    output logic [1:0][33:0]               imd_val_q_ex_o,
 
     // Branch target ALU
     output logic [31:0]               bt_a_operand_o,
@@ -247,7 +247,7 @@ module ibex_id_stage #(
   logic        alu_multicycle_dec;
   logic        stall_alu;
 
-  logic [33:0] imd_val_q[2];
+  logic [1:0][33:0] imd_val_q;
 
   op_a_sel_e   bt_a_mux_sel;
   imm_b_sel_e  bt_b_mux_sel;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
index 617bb5162..e1890da38 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
@@ -35,8 +35,8 @@ module ibex_multdiv_fast #(
     output logic [32:0]      alu_operand_a_o,
     output logic [32:0]      alu_operand_b_o,
 
-    input  logic [33:0]      imd_val_q_i[2],
-    output logic [33:0]      imd_val_d_o[2],
+    input  logic [1:0][33:0]      imd_val_q_i,
+    output logic [1:0][33:0]      imd_val_d_o,
     output logic [1:0]       imd_val_we_o,
 
     input  logic             multdiv_ready_id_i,
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
index 1b48693a0..4621be034 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
@@ -30,8 +30,8 @@ module ibex_pmp #(
   import ibex_pkg::*;
 
   // Access Checking Signals
-  logic [33:0]                                region_start_addr [PMPNumRegions];
-  logic [33:PMPGranularity+2]                 region_addr_mask  [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0]                                region_start_addr;
+  logic [PMPNumRegions-1:0][33:0]                 region_addr_mask;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_gt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_lt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_eq;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
index 4dd429df8..8c95e2492 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
@@ -42,8 +42,8 @@ module ibex_register_file #(
   localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;
 
   logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg;
-  logic [NUM_WORDS-1:1][DataWidth-1:0] rf_reg_q;
-  logic [NUM_WORDS-1:1]                we_a_dec;
+  logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg_q;
+  logic [NUM_WORDS-1:0]                we_a_dec;
 
   always_comb begin : we_a_decoder
     for (int unsigned i = 1; i < NUM_WORDS; i++) begin
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
index ffe380ff4..6f518796f 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
@@ -51,7 +51,7 @@ module ibex_wb_stage #(
 
   // 0 == RF write from ID
   // 1 == RF write from LSU
-  logic [31:0] rf_wdata_wb_mux    [2];
+  logic [1:0][31:0] rf_wdata_wb_mux;
   logic [1:0]  rf_wdata_wb_mux_we;
 
   if(WritebackStage) begin : g_writeback_stage
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
index 550b7cc36..c65fe30c4 100755
--- a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
@@ -216,7 +216,7 @@ module dm_mem #(
   // read/write logic
   logic [63:0] data_bits;
   logic [7:0][7:0] rdata;
-  always_comb begin : p_rw_logic
+  always begin : p_rw_logic
 
     halted_d_aligned   = NrHartsAligned'(halted_q);
     resuming_d_aligned = NrHartsAligned'(resuming_q);
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
index c97f9565a..4aa3646f4 100644
--- a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
@@ -98,16 +98,16 @@ module dm_sba #(
         // generate byte enable mask
         unique case (sbaccess_i)
           3'b000: begin
-            be[be_idx] = '1;
+            be[be_idx] = 4'b1111;
           end
           3'b001: begin
-            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = '1;
+            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = 2'b11;
           end
           3'b010: begin
-            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = '1;
-            else                    be = '1;
+            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = 2'b11;
+            else                    be = 4'b1111;
           end
-          3'b011: be = '1;
+          3'b011: be = 4'b1111;
           default: ;
         endcase
         if (gnt) state_d = WaitWrite;
