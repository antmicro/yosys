diff --git a/hw/ip/aes/rtl/aes_cipher_core.sv b/hw/ip/aes/rtl/aes_cipher_core.sv
index ed35dc5ef..d1b6b560f 100644
--- a/hw/ip/aes/rtl/aes_cipher_core.sv
+++ b/hw/ip/aes/rtl/aes_cipher_core.sv
@@ -40,24 +40,24 @@ module aes_cipher_core #(
   input  logic          [63:0] prng_data_i,
 
   // I/O data & initial key
-  input  logic [3:0][3:0][7:0] state_init_i,
+  input  logic [127:0] state_init_i,
   input  logic     [7:0][31:0] key_init_i,
-  output logic [3:0][3:0][7:0] state_o
+  output logic [127:0] state_o
 );
 
   import aes_pkg::*;
 
   // Signals
-  logic [3:0][3:0][7:0] state_d;
-  logic [3:0][3:0][7:0] state_q;
+  logic [127:0] state_d;
+  logic [127:0] state_q;
   logic                 state_we;
   state_sel_e           state_sel;
 
-  logic [3:0][3:0][7:0] sub_bytes_out;
-  logic [3:0][3:0][7:0] shift_rows_out;
-  logic [3:0][3:0][7:0] mix_columns_out;
-  logic [3:0][3:0][7:0] add_round_key_in;
-  logic [3:0][3:0][7:0] add_round_key_out;
+  logic [127:0] sub_bytes_out;
+  logic [127:0] shift_rows_out;
+  logic [127:0] mix_columns_out;
+  logic [127:0] add_round_key_in;
+  logic [127:0] add_round_key_out;
   add_rk_sel_e          add_round_key_in_sel;
 
   logic     [7:0][31:0] key_full_d;
@@ -75,9 +75,9 @@ module aes_cipher_core #(
   logic           [3:0] key_expand_round;
   key_words_sel_e       key_words_sel;
   logic     [3:0][31:0] key_words;
-  logic [3:0][3:0][7:0] key_bytes;
-  logic [3:0][3:0][7:0] key_mix_columns_out;
-  logic [3:0][3:0][7:0] round_key;
+  logic [127:0] key_bytes;
+  logic [127:0] key_mix_columns_out;
+  logic [127:0] round_key;
   round_key_sel_e       round_key_sel;
 
   //////////
@@ -103,19 +103,19 @@ module aes_cipher_core #(
   // Cipher data path
   aes_sub_bytes #(
     .SBoxImpl ( SBoxImpl )
-  ) aes_sub_bytes (
+  ) u_aes_sub_bytes (
     .op_i   ( op_i          ),
     .data_i ( state_q       ),
     .data_o ( sub_bytes_out )
   );
 
-  aes_shift_rows aes_shift_rows (
+  aes_shift_rows u_aes_shift_rows (
     .op_i   ( op_i           ),
     .data_i ( sub_bytes_out  ),
     .data_o ( shift_rows_out )
   );
 
-  aes_mix_columns aes_mix_columns (
+  aes_mix_columns u_aes_mix_columns (
     .op_i   ( op_i            ),
     .data_i ( shift_rows_out  ),
     .data_o ( mix_columns_out )
@@ -172,7 +172,7 @@ module aes_cipher_core #(
   aes_key_expand #(
     .AES192Enable ( AES192Enable ),
     .SBoxImpl     ( SBoxImpl     )
-  ) aes_key_expand (
+  ) u_aes_key_expand (
     .clk_i     ( clk_i            ),
     .rst_ni    ( rst_ni           ),
     .op_i      ( key_expand_op    ),
@@ -197,7 +197,7 @@ module aes_cipher_core #(
   // Convert words to bytes (every key word contains one column)
   assign key_bytes = aes_transpose(key_words);
 
-  aes_mix_columns aes_key_mix_columns (
+  aes_mix_columns u_aes_key_mix_columns (
     .op_i   ( CIPH_INV            ),
     .data_i ( key_bytes           ),
     .data_o ( key_mix_columns_out )
@@ -216,7 +216,7 @@ module aes_cipher_core #(
   /////////////
 
   // Control
-  aes_cipher_control aes_cipher_control (
+  aes_cipher_control u_aes_cipher_control (
     .clk_i                  ( clk_i                ),
     .rst_ni                 ( rst_ni               ),
 
diff --git a/hw/ip/aes/rtl/aes_key_expand.sv b/hw/ip/aes/rtl/aes_key_expand.sv
index c030089b7..65f0bdc94 100644
--- a/hw/ip/aes/rtl/aes_key_expand.sv
+++ b/hw/ip/aes/rtl/aes_key_expand.sv
@@ -191,7 +191,7 @@ module aes_key_expand #(
 
   // To reduce muxing resources, we re-use existing
   // connections for unused words and default cases.
-  always_comb begin : drive_regular
+  always begin : drive_regular
     unique case (key_len_i)
 
       /////////////
diff --git a/hw/ip/aes/rtl/aes_mix_columns.sv b/hw/ip/aes/rtl/aes_mix_columns.sv
index 3aee014a2..222464474 100644
--- a/hw/ip/aes/rtl/aes_mix_columns.sv
+++ b/hw/ip/aes/rtl/aes_mix_columns.sv
@@ -6,15 +6,15 @@
 
 module aes_mix_columns (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Transpose to operate on columns
-  logic [3:0][3:0][7:0] data_i_transposed;
-  logic [3:0][3:0][7:0] data_o_transposed;
+  logic [127:0] data_i_transposed;
+  logic [127:0] data_o_transposed;
 
   assign data_i_transposed = aes_transpose(data_i);
 
diff --git a/hw/ip/aes/rtl/aes_pkg.sv b/hw/ip/aes/rtl/aes_pkg.sv
index ddc3b7992..6d4e2a759 100644
--- a/hw/ip/aes/rtl/aes_pkg.sv
+++ b/hw/ip/aes/rtl/aes_pkg.sv
@@ -165,12 +165,12 @@ function automatic logic [31:0] aes_circ_byte_shift(logic [31:0] in, logic [1:0]
 endfunction
 
 // Transpose state matrix
-function automatic logic [3:0][3:0][7:0] aes_transpose(logic [3:0][3:0][7:0] in);
-  logic [3:0][3:0][7:0] transpose;
+function automatic logic [127:0] aes_transpose(logic [127:0] in);
+  logic [127:0] transpose;
   transpose = '0;
   for (int j=0; j<4; j++) begin
     for (int i=0; i<4; i++) begin
-      transpose[i][j] = in[j][i];
+      transpose[((i * 4) + j) * 8+:8] = in[((j * 4) + i) * 8+:8];
     end
   end
   return transpose;
diff --git a/hw/ip/aes/rtl/aes_prng.sv b/hw/ip/aes/rtl/aes_prng.sv
index 08e2a94e6..a94dbdd43 100644
--- a/hw/ip/aes/rtl/aes_prng.sv
+++ b/hw/ip/aes/rtl/aes_prng.sv
@@ -23,7 +23,7 @@ module aes_prng (
   input  logic        entropy_ack_i,
   input  logic [63:0] entropy_i
 );
-
+  import prim_cipher_pkg::*;
   localparam int unsigned DATA_WIDTH = 64;
 
   logic                  seed_en;
@@ -58,7 +58,7 @@ module aes_prng (
   );
 
   // "Scramble" the LFSR state.
-  assign scrambled = prim_cipher_pkg::sbox4_64bit(lfsr_state, prim_cipher_pkg::PRINCE_SBOX4);
-  assign data_o    = prim_cipher_pkg::perm_64bit(scrambled, prim_cipher_pkg::PRESENT_PERM64);
+  assign scrambled = sbox4_64bit(lfsr_state, PRINCE_SBOX4);
+  assign data_o    = perm_64bit(scrambled, PRESENT_PERM64);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_shift_rows.sv b/hw/ip/aes/rtl/aes_shift_rows.sv
index b33b570a0..ef9eea32b 100644
--- a/hw/ip/aes/rtl/aes_shift_rows.sv
+++ b/hw/ip/aes/rtl/aes_shift_rows.sv
@@ -6,24 +6,24 @@
 
 module aes_shift_rows (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   import aes_pkg::*;
 
   // Row 0 is left untouched
-  assign data_o[0] = data_i[0];
+  assign data_o[0] = data_i[0+:32];
 
   // Row 2 does not depend on op_i
-  assign data_o[2] = aes_circ_byte_shift(data_i[2], 2'h2);
+  assign data_o[2] = aes_circ_byte_shift(data_i[64+:32], 2'h2);
 
   // Row 1
-  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[1], 2'h3)
-                                        : aes_circ_byte_shift(data_i[1], 2'h1);
+  assign data_o[1] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[32+:32], 2'h3)
+                                        : aes_circ_byte_shift(data_i[32+:32], 2'h1);
 
   // Row 3
-  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[3], 2'h1)
-                                        : aes_circ_byte_shift(data_i[3], 2'h3);
+  assign data_o[3] = (op_i == CIPH_FWD) ? aes_circ_byte_shift(data_i[96+:32], 2'h1)
+                                        : aes_circ_byte_shift(data_i[96+:32], 2'h3);
 
 endmodule
diff --git a/hw/ip/aes/rtl/aes_sub_bytes.sv b/hw/ip/aes/rtl/aes_sub_bytes.sv
index 1d3e5c3a9..081c718f9 100644
--- a/hw/ip/aes/rtl/aes_sub_bytes.sv
+++ b/hw/ip/aes/rtl/aes_sub_bytes.sv
@@ -8,8 +8,8 @@ module aes_sub_bytes #(
   parameter SBoxImpl = "lut"
 ) (
   input  aes_pkg::ciph_op_e    op_i,
-  input  logic [3:0][3:0][7:0] data_i,
-  output logic [3:0][3:0][7:0] data_o
+  input  logic [127:0] data_i,
+  output logic [127:0] data_o
 );
 
   // Individually substitute bytes
@@ -19,8 +19,8 @@ module aes_sub_bytes #(
         .SBoxImpl ( SBoxImpl )
       ) aes_sbox_ij (
         .op_i   ( op_i         ),
-        .data_i ( data_i[i][j] ),
-        .data_o ( data_o[i][j] )
+        .data_i ( data_i[((i * 4) + j) * 8+:8] ),
+        .data_o ( data_o[((i * 4) + j) * 8+:8] )
       );
     end
   end
diff --git a/hw/ip/alert_handler/rtl/alert_pkg.sv b/hw/ip/alert_handler/rtl/alert_pkg.sv
index 5324b4978..fb9e8de6c 100644
--- a/hw/ip/alert_handler/rtl/alert_pkg.sv
+++ b/hw/ip/alert_handler/rtl/alert_pkg.sv
@@ -5,24 +5,20 @@
 
 package alert_pkg;
 
-  // these localparams are generated based on the system top-level configuration
-  localparam int unsigned      NAlerts   = alert_handler_reg_pkg::NAlerts;   // maximum 252
-  localparam int unsigned      EscCntDw  = alert_handler_reg_pkg::EscCntDw;  // maximum 32
-  localparam int unsigned      AccuCntDw = alert_handler_reg_pkg::AccuCntDw; // maximum 32
-  // seed for the ping timer (must be nonzero!)
-  localparam logic [31:0]      LfsrSeed  = alert_handler_reg_pkg::LfsrSeed;
-  // enable async transitions for specific RX/TX pairs
-  localparam bit [NAlerts-1:0] AsyncOn   = alert_handler_reg_pkg::AsyncOn;
-
-  // common constants, do not change
-  localparam int unsigned N_CLASSES   = alert_handler_reg_pkg::N_CLASSES;
-  localparam int unsigned N_ESC_SEV   = alert_handler_reg_pkg::N_ESC_SEV;
-  localparam int unsigned N_PHASES    = alert_handler_reg_pkg::N_PHASES;
-  localparam int unsigned N_LOC_ALERT = alert_handler_reg_pkg::N_LOC_ALERT;
-
-  localparam int unsigned PING_CNT_DW = alert_handler_reg_pkg::PING_CNT_DW;
-  localparam int unsigned PHASE_DW    = alert_handler_reg_pkg::PHASE_DW;
-  localparam int unsigned CLASS_DW    = alert_handler_reg_pkg::CLASS_DW;
+  // copied from alert_handler_reg_pkg as it is currently unparsable by
+  // yosys/surelog
+  parameter int NAlerts = 5;
+  parameter int EscCntDw = 32;
+  parameter int AccuCntDw = 16;
+  parameter int LfsrSeed = 2147483647;
+  parameter logic [NAlerts-1:0] AsyncOn = 5'b00000;
+  parameter int N_CLASSES = 4;
+  parameter int N_ESC_SEV = 4;
+  parameter int N_PHASES = 4;
+  parameter int N_LOC_ALERT = 4;
+  parameter int PING_CNT_DW = 24;
+  parameter int PHASE_DW = 2;
+  parameter int CLASS_DW = 2;
 
   // do not change the phase encoding
   typedef enum logic [2:0] {Idle = 3'b000, Timeout = 3'b001, Terminal = 3'b011,
@@ -68,9 +64,9 @@ package alert_pkg;
     logic [N_CLASSES-1:0]                              class_clr;          // clears esc/accu
     logic [N_CLASSES-1:0][AccuCntDw-1:0]               class_accum_thresh; // accum esc threshold
     logic [N_CLASSES-1:0][EscCntDw-1:0]                class_timeout_cyc;  // interrupt timeout
-    logic [N_CLASSES-1:0][N_PHASES-1:0][EscCntDw-1:0]  class_phase_cyc;    // length of phases 0..3
+    logic [511:0]  class_phase_cyc;    // length of phases 0..3
     logic [N_CLASSES-1:0][N_ESC_SEV-1:0]               class_esc_en;       // esc signal enables
-    logic [N_CLASSES-1:0][N_ESC_SEV-1:0][PHASE_DW-1:0] class_esc_map;      // esc signal/phase map
+    logic [31:0] class_esc_map;      // esc signal/phase map
   } reg2hw_wrap_t;
 
 endpackage : alert_pkg
diff --git a/hw/ip/flash_ctrl/rtl/flash_phy.sv b/hw/ip/flash_ctrl/rtl/flash_phy.sv
index 28ad2a12a..af2b735dd 100644
--- a/hw/ip/flash_ctrl/rtl/flash_phy.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_phy.sv
@@ -21,7 +21,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   input flash_req_t flash_ctrl_i,
   output flash_rsp_t flash_ctrl_o
 );
-
+  import flash_phy_pkg::*;
   // Flash macro outstanding refers to how many reads we allow a macro to move ahead of an
   // in order blocking read. Since the data cannot be returned out of order, this simply
   // does the reads in advance and store them in a FIFO
@@ -46,7 +46,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  host_rsp_avail;
   logic [NumBanks-1:0]  host_rsp_vld;
   logic [NumBanks-1:0]  host_rsp_ack;
-  logic [BusWidth-1:0]  host_rsp_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0]  host_rsp_data;
   logic                 seq_fifo_rdy;
   logic                 seq_fifo_pending;
 
@@ -59,7 +59,7 @@ module flash_phy import flash_ctrl_pkg::*; (
   logic [NumBanks-1:0]  init_busy;
 
   // common interface
-  logic [BusWidth-1:0] rd_data [NumBanks];
+  logic [0:NumBanks-1][BusWidth-1:0] rd_data;
 
   // select which bank each is operating on
   assign host_bank_sel = host_req_i ? host_addr_i[BusAddrW-1 -: BankW] : '0;
diff --git a/hw/ip/hmac/rtl/sha2_pad.sv b/hw/ip/hmac/rtl/sha2_pad.sv
index 5ee90881c..2667008be 100644
--- a/hw/ip/hmac/rtl/sha2_pad.sv
+++ b/hw/ip/hmac/rtl/sha2_pad.sv
@@ -89,7 +89,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       Pad00: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
 
       LenHi: begin
@@ -101,7 +101,7 @@ module sha2_pad import hmac_pkg::*; (
       end
 
       default: begin
-        shaf_rdata = '0;
+        shaf_rdata = 32'h00000000;
       end
     endcase
   end
@@ -298,9 +298,9 @@ module sha2_pad import hmac_pkg::*; (
   // tx_count
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (hash_start) begin
-      tx_count <= '0;
+      tx_count <= 64'h0000000000000000;
     end else if (inc_txcount) begin
       tx_count[63:5] <= tx_count[63:5] + 1'b1;
     end
diff --git a/hw/ip/otbn/rtl/otbn_core.sv b/hw/ip/otbn/rtl/otbn_core.sv
index 8b13db4f5..312277b5f 100644
--- a/hw/ip/otbn/rtl/otbn_core.sv
+++ b/hw/ip/otbn/rtl/otbn_core.sv
@@ -10,7 +10,6 @@
  * This module is the top-level of the OTBN processing core.
  */
 module otbn_core
-  import otbn_pkg::*;
 #(
   // Size of the instruction memory, in bytes
   parameter int ImemSizeByte = 4096,
@@ -40,9 +39,9 @@ module otbn_core
   output logic                     dmem_req_o,
   output logic                     dmem_write_o,
   output logic [DmemAddrWidth-1:0] dmem_addr_o,
-  output logic [WLEN-1:0]          dmem_wdata_o,
-  output logic [WLEN-1:0]          dmem_wmask_o,
-  input  logic [WLEN-1:0]          dmem_rdata_i,
+  output logic [256-1:0]          dmem_wdata_o,
+  output logic [256-1:0]          dmem_wmask_o,
+  input  logic [256-1:0]          dmem_rdata_i,
   input  logic                     dmem_rvalid_i,
   input  logic [1:0]               dmem_rerror_i
 );
diff --git a/hw/ip/otbn/rtl/otbn_reg_top.sv b/hw/ip/otbn/rtl/otbn_reg_top.sv
index 052cb2f5a..b62227975 100644
--- a/hw/ip/otbn/rtl/otbn_reg_top.sv
+++ b/hw/ip/otbn/rtl/otbn_reg_top.sv
@@ -54,13 +54,13 @@ module otbn_reg_top (
   logic [1:0] reg_steer;
 
   // socket_1n connection
-  assign tl_reg_h2d = tl_socket_h2d[2];
-  assign tl_socket_d2h[2] = tl_reg_d2h;
+  assign tl_reg_h2d = tl_socket_h2d[0];
 
-  assign tl_win_o[0] = tl_socket_h2d[0];
-  assign tl_socket_d2h[0] = tl_win_i[0];
-  assign tl_win_o[1] = tl_socket_h2d[1];
-  assign tl_socket_d2h[1] = tl_win_i[1];
+  assign tl_win_o[0] = tl_socket_h2d[1];
+  assign tl_win_o[1] = tl_socket_h2d[2];
+  assign tl_socket_d2h[0] = tl_reg_d2h;
+  assign tl_socket_d2h[1] = tl_win_i[0];
+  assign tl_socket_d2h[2] = tl_win_i[1];
 
   // Create Socket_1n
   tlul_socket_1n #(
diff --git a/hw/ip/pinmux/rtl/pinmux.sv b/hw/ip/pinmux/rtl/pinmux.sv
index 92da2e81c..89b58a8f7 100644
--- a/hw/ip/pinmux/rtl/pinmux.sv
+++ b/hw/ip/pinmux/rtl/pinmux.sv
@@ -64,8 +64,10 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
   // Regfile Breakout and Mapping //
   //////////////////////////////////
 
-  pinmux_reg2hw_t reg2hw;
-  pinmux_hw2reg_t hw2reg;
+  //pinmux_reg2hw_t reg2hw;
+  //pinmux_hw2reg_t hw2reg;
+  wire [660:0] reg2hw;
+  wire [37:0] hw2reg;
 
   pinmux_reg_top u_reg (
     .clk_i  ,
@@ -95,13 +97,13 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
   // 2: high-z
   // 3: previous value
   for (genvar k = 0; k < NMioPads; k++) begin : gen_mio_sleep
-    assign mio_out_sleep_d[k] = (reg2hw.mio_out_sleep_val[k].q == 0) ? 1'b0 :
-                                (reg2hw.mio_out_sleep_val[k].q == 1) ? 1'b1 :
-                                (reg2hw.mio_out_sleep_val[k].q == 2) ? 1'b0 : mio_out_o[k];
+    assign mio_out_sleep_d[k] = (reg2hw[213 + ((k * 2) + 1)-:2] == 0) ? 1'b0 :
+                                (reg2hw[213 + ((k * 2) + 1)-:2] == 1) ? 1'b1 :
+                                (reg2hw[213 + ((k * 2) + 1)-:2] == 2) ? 1'b0 : mio_out_o[k];
 
-    assign mio_oe_sleep_d[k] = (reg2hw.mio_out_sleep_val[k].q == 0) ? 1'b1 :
-                               (reg2hw.mio_out_sleep_val[k].q == 1) ? 1'b1 :
-                               (reg2hw.mio_out_sleep_val[k].q == 2) ? 1'b0 : mio_oe_o[k];
+    assign mio_oe_sleep_d[k] = (reg2hw[213 + ((k * 2) + 1)-:2] == 0) ? 1'b1 :
+                               (reg2hw[213 + ((k * 2) + 1)-:2] == 1) ? 1'b1 :
+                               (reg2hw[213 + ((k * 2) + 1)-:2] == 2) ? 1'b0 : mio_oe_o[k];
   end
 
   // since DIO pads are permanently mapped to a specific peripheral,
@@ -109,10 +111,10 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
   // outputs / inouts.
   for (genvar k = 0; k < NDioPads; k++) begin : gen_dio_sleep
     if (DioPeriphHasSleepMode[k]) begin : gen_warl_connect
-      assign hw2reg.dio_out_sleep_val[k].d = dio_out_sleep_val_q[k];
+      assign hw2reg[8 + ((k * 2) + 1)-:2] = dio_out_sleep_val_q[k];
 
-      assign dio_out_sleep_val_d[k] = (reg2hw.dio_out_sleep_val[k].qe) ?
-                                      reg2hw.dio_out_sleep_val[k].q :
+      assign dio_out_sleep_val_d[k] = (reg2hw[168 + (k * 3)]) ?
+                                      reg2hw[168 + ((k * 3) + 2)-:2] :
                                       dio_out_sleep_val_q[k];
 
       assign dio_out_sleep_d[k] = (dio_out_sleep_val_q[k] == 0) ? 1'b0 :
@@ -124,7 +126,7 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
                                  (dio_out_sleep_val_q[k] == 2) ? 1'b0 : dio_oe_o[k];
     end else begin : gen_warl_tie0
       // these signals will be unused
-      assign hw2reg.dio_out_sleep_val[k].d = 2'b10; // default value defined in hjson
+      assign hw2reg[8 + ((k * 2) + 1)-:2] = 2'b10; // default value defined in hjson
       assign dio_out_sleep_val_d[k] = 2'b10; // default value defined in hjson
       assign dio_out_sleep_d[k]     = '0;
       assign dio_oe_sleep_d[k]      = '0;
@@ -135,10 +137,10 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
     if (!rst_ni) begin
       sleep_en_q          <= 1'b0;
       dio_out_sleep_val_q <= {NDioPads{2'b10}}; // default value defined in hjson
-      mio_out_sleep_q     <= '0;
-      mio_oe_sleep_q      <= '0;
-      dio_out_sleep_q     <= '0;
-      dio_oe_sleep_q      <= '0;
+      mio_out_sleep_q <= {32 {1'b0}};
+      mio_oe_sleep_q <= {32 {1'b0}};
+      dio_out_sleep_q <= {15 {1'b0}};
+      dio_oe_sleep_q <= {15 {1'b0}};
     end else begin
       sleep_en_q          <= sleep_en_i;
       dio_out_sleep_val_q <= dio_out_sleep_val_d;
@@ -163,11 +165,11 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
   // 1. make sure mux is aligned to a power of 2 to avoid Xes.
   logic [AlignedMuxSize-1:0] mio_data_mux;
   // TODO: need a way to select which IO POK signal to use por pin
-  assign mio_data_mux = AlignedMuxSize'({(&io_pok_i) ? mio_in_i : '0, 1'b1, 1'b0});
+  assign mio_data_mux = AlignedMuxSize'({(&io_pok_i) ? mio_in_i : {32 {1'b0}}, 1'b1, 1'b0});
 
   for (genvar k = 0; k < NMioPeriphIn; k++) begin : gen_mio_periph_in
     // index using configured insel
-    assign mio_to_periph_o[k] = mio_data_mux[reg2hw.periph_insel[k].q];
+    assign mio_to_periph_o[k] = mio_data_mux[reg2hw[469 + ((k * 6) + 5)-:6]];
   end
 
   ////////////////
@@ -184,10 +186,10 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
   for (genvar k = 0; k < NMioPads; k++) begin : gen_mio_out
     logic sleep_en;
     // check whether this peripheral can actually go to sleep
-    assign sleep_en = periph_sleep_mux[reg2hw.mio_outsel[k].q] & sleep_en_q;
+    assign sleep_en = periph_sleep_mux[reg2hw[277 + ((k * 6) + 5)-:6]] & sleep_en_q;
     // index using configured outsel
-    assign mio_out_o[k] = (sleep_en) ? mio_out_sleep_q[k] : periph_data_mux[reg2hw.mio_outsel[k].q];
-    assign mio_oe_o[k]  = (sleep_en) ? mio_oe_sleep_q[k]  : periph_oe_mux[reg2hw.mio_outsel[k].q];
+    assign mio_out_o[k] = (sleep_en) ? mio_out_sleep_q[k] : periph_data_mux[reg2hw[277 + ((k * 6) + 5)-:6]];
+    assign mio_oe_o[k]  = (sleep_en) ? mio_oe_sleep_q[k]  : periph_oe_mux[reg2hw[277 + ((k * 6) + 5)-:6]];
   end
 
   /////////////////////
@@ -231,9 +233,9 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
 
   for (genvar k = 0; k < NWkupDetect; k++) begin : gen_wkup_detect
     logic pin_value;
-    assign pin_value = (reg2hw.wkup_detector[k].miodio.q)           ?
-                       dio_data_mux[reg2hw.wkup_detector_padsel[k]] :
-                       mio_data_mux[reg2hw.wkup_detector_padsel[k]];
+    assign pin_value = (reg2hw[120 + (k * 5)])           ?
+                       dio_data_mux[reg2hw[16 + (k * 5)+:5]] :
+                       mio_data_mux[reg2hw[16 + (k * 5)+:5]];
 
     pinmux_wkup i_pinmux_wkup (
       .clk_i,
@@ -241,15 +243,15 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
       .clk_aon_i,
       .rst_aon_ni,
       // config signals. these are synched to clk_aon internally
-      .wkup_en_i          ( reg2hw.wkup_detector_en[k].q                ),
-      .filter_en_i        ( reg2hw.wkup_detector[k].filter.q            ),
-      .wkup_mode_i        ( wkup_mode_e'(reg2hw.wkup_detector[k].mode.q)),
-      .wkup_cnt_th_i      ( reg2hw.wkup_detector_cnt_th[k].q            ),
+      .wkup_en_i          ( reg2hw[160 + k]                ),
+      .filter_en_i        ( reg2hw[120 + ((k * 5) + 1)]            ),
+      .wkup_mode_i        ( wkup_mode_e'(reg2hw[120 + ((k * 5) + 4)-:3])),
+      .wkup_cnt_th_i      ( reg2hw[56 + ((k * 8) + 7)-:8]            ),
       .pin_value_i        ( pin_value                                   ),
       // cause reg signals. these are synched from/to clk_aon internally
-      .wkup_cause_valid_i ( reg2hw.wkup_cause[k].qe                     ),
-      .wkup_cause_data_i  ( reg2hw.wkup_cause[k].q                      ),
-      .wkup_cause_data_o  ( hw2reg.wkup_cause[k].d                      ),
+      .wkup_cause_valid_i ( reg2hw[k * 2]                     ),
+      .wkup_cause_data_i  ( reg2hw[(k * 2) + 1]                      ),
+      .wkup_cause_data_o  ( hw2reg[k]                      ),
       // wakeup request signals on clk_aon (level encoded)
       .aon_wkup_req_o     ( aon_wkup_req[k]                             )
     );
@@ -288,8 +290,8 @@ module pinmux import pinmux_pkg::*; import pinmux_reg_pkg::*; (
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : p_strap_sample
     if (!rst_ni) begin
-      lc_strap_q       <= '0;
-      dft_strap_test_q <= '0;
+      lc_strap_q       <= {3{1'b0}};
+      dft_strap_test_q <= {3{1'b0}};
     end else begin
       lc_strap_q       <= lc_strap_d;
       dft_strap_test_q <= dft_strap_test_d;
diff --git a/hw/ip/pinmux/rtl/pinmux_wkup.sv b/hw/ip/pinmux/rtl/pinmux_wkup.sv
index 101062346..2eb8496b3 100644
--- a/hw/ip/pinmux/rtl/pinmux_wkup.sv
+++ b/hw/ip/pinmux/rtl/pinmux_wkup.sv
@@ -2,7 +2,7 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 //
-module pinmux_wkup import pinmux_pkg::*; import pinmux_reg_pkg::*; #(
+module pinmux_wkup import pinmux_pkg::*; #(
   parameter int Cycles = 4
 ) (
   input                    clk_i,
@@ -16,7 +16,7 @@ module pinmux_wkup import pinmux_pkg::*; import pinmux_reg_pkg::*; #(
   input                    wkup_en_i,
   input                    filter_en_i,
   input wkup_mode_e        wkup_mode_i,
-  input [WkupCntWidth-1:0] wkup_cnt_th_i,
+  input [7:0] wkup_cnt_th_i,
   input                    pin_value_i,
   // Signals to/from cause register.
   // They are synched to/from the AON clock internally
@@ -37,7 +37,7 @@ module pinmux_wkup import pinmux_pkg::*; import pinmux_reg_pkg::*; #(
   wkup_mode_e aon_wkup_mode_q;
   logic aon_filter_en_q;
   logic aon_wkup_en_d, aon_wkup_en_q;
-  logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;
+  logic [7:0] aon_wkup_cnt_th_q;
 
   prim_flop_2sync #(
     .Width(1)
@@ -106,7 +106,7 @@ module pinmux_wkup import pinmux_pkg::*; import pinmux_reg_pkg::*; #(
   assign aon_rising  =  aon_filter_out_d & ~aon_filter_out_q;
 
   logic aon_cnt_en, aon_cnt_eq_th;
-  logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
+  logic [7:0] aon_cnt_d, aon_cnt_q;
   assign aon_cnt_d = (aon_cnt_eq_th) ? '0                :
                      (aon_cnt_en)    ?  aon_cnt_q + 1'b1 : '0;
 
diff --git a/hw/ip/prim/rtl/prim_arbiter_ppc.sv b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
index 9ec473f85..86bef1e9d 100644
--- a/hw/ip/prim/rtl/prim_arbiter_ppc.sv
+++ b/hw/ip/prim/rtl/prim_arbiter_ppc.sv
@@ -113,12 +113,14 @@ module prim_arbiter_ppc #(
       end
     end else begin: gen_nodatapath
       assign data_o = '1;
-      // TODO: waive data_i from NOT_READ error
+      // The following signal is used to avoid possible lint errors.
+      logic [DW-1:0] unused_data [N];
+      assign unused_data = data_i;
     end
 
     always_comb begin
       idx_o = '0;
-      for (int i = 0 ; i < N ; i++) begin
+      for (int unsigned i = 0 ; i < N ; i++) begin
         if (winner[i]) begin
           idx_o = i[IdxW-1:0];
         end
@@ -222,4 +224,3 @@ end
 `endif
 
 endmodule : prim_arbiter_ppc
-
diff --git a/hw/ip/prim/rtl/prim_diff_decode.sv b/hw/ip/prim/rtl/prim_diff_decode.sv
index c06a77d77..8c9db0c61 100644
--- a/hw/ip/prim/rtl/prim_diff_decode.sv
+++ b/hw/ip/prim/rtl/prim_diff_decode.sv
@@ -42,9 +42,9 @@ module prim_diff_decode #(
   ///////////////////////////////////////////////////////////////
   // synchronization regs for incoming diff pair (if required) //
   ///////////////////////////////////////////////////////////////
+  typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
   if (AsyncOn) begin : gen_async
 
-    typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
     state_e state_d, state_q;
     logic diff_p_edge, diff_n_edge, diff_check_ok, level;
 
diff --git a/hw/ip/prim/rtl/prim_prince.sv b/hw/ip/prim/rtl/prim_prince.sv
index 423a7ca21..cb790a861 100644
--- a/hw/ip/prim/rtl/prim_prince.sv
+++ b/hw/ip/prim/rtl/prim_prince.sv
@@ -48,7 +48,7 @@ module prim_prince #(
   output logic                 valid_o,
   output logic [DataWidth-1:0] data_o
 );
-
+  import prim_cipher_pkg::*;
   ///////////////////
   // key expansion //
   ///////////////////
@@ -63,7 +63,7 @@ module prim_prince #(
     if (dec_i) begin
       k0          = k0_prime_d;
       k0_prime_d  = key_i[DataWidth-1:0];
-      k1_d       ^= prim_cipher_pkg::PRINCE_ALPHA_CONST[DataWidth-1:0];
+      k1_d       ^= PRINCE_ALPHA_CONST[DataWidth-1:0];
     end
   end
 
@@ -106,7 +106,7 @@ module prim_prince #(
   always_comb begin : p_pre_round_xor
     data_state[0] = data_i ^ k0;
     data_state[0] ^= k1_d;
-    data_state[0] ^= prim_cipher_pkg::PRINCE_ROUND_CONST[0][DataWidth-1:0];
+    data_state[0] ^= PRINCE_ROUND_CONST[0][DataWidth-1:0];
   end
 
   // forward pass
@@ -114,24 +114,24 @@ module prim_prince #(
     logic [DataWidth-1:0] data_state_round;
     if (DataWidth == 64) begin : gen_fwd_d64
       always_comb begin : p_fwd_d64
-        data_state_round = prim_cipher_pkg::sbox4_64bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_64bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_64bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_64bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_64bit(data_state_round);
+        data_state_round = prince_shiftrows_64bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end else begin : gen_fwd_d32
       always_comb begin : p_fwd_d32
-        data_state_round = prim_cipher_pkg::sbox4_32bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_32bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_32bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
+        data_state_round = sbox4_32bit(data_state[k-1],
+            PRINCE_SBOX4);
+        data_state_round = prince_mult_prime_32bit(data_state_round);
+        data_state_round = prince_shiftrows_32bit(data_state_round,
+            PRINCE_SHIFT_ROWS64);
       end
     end
     logic [DataWidth-1:0] data_state_xor;
     assign data_state_xor = data_state_round ^
-                            prim_cipher_pkg::PRINCE_ROUND_CONST[k][DataWidth-1:0];
+                            PRINCE_ROUND_CONST[k][DataWidth-1:0];
     // improved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
     if (k % 2 == 1) assign data_state[k]  = data_state_xor ^ k0_new_d;
     else            assign data_state[k]  = data_state_xor ^ k1_d;
@@ -141,19 +141,19 @@ module prim_prince #(
   logic [DataWidth-1:0] data_state_middle_d, data_state_middle_q, data_state_middle;
   if (DataWidth == 64) begin : gen_middle_d64
     always_comb begin : p_middle_d64
-      data_state_middle_d = prim_cipher_pkg::sbox4_64bit(data_state[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_64bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_64bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_64bit(data_state[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_64bit(data_state_middle_q);
+      data_state_middle = sbox4_64bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end else begin : gen_middle_d32
     always_comb begin : p_middle_d32
-      data_state_middle_d = prim_cipher_pkg::sbox4_32bit(data_state_middle[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_32bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_32bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
+      data_state_middle_d = sbox4_32bit(data_state_middle[NumRoundsHalf],
+          PRINCE_SBOX4);
+      data_state_middle = prince_mult_prime_32bit(data_state_middle_q);
+      data_state_middle = sbox4_32bit(data_state_middle,
+          PRINCE_SBOX4_INV);
     end
   end
 
@@ -187,24 +187,24 @@ module prim_prince #(
     else            assign data_state_xor0 = data_state[NumRoundsHalf+k] ^ k1_q;
     // the construction is reflective, hence the subtraction with NumRoundsHalf
     assign data_state_xor1 = data_state_xor0 ^
-                             prim_cipher_pkg::PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
+                             PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
 
     logic [DataWidth-1:0] data_state_bwd;
     if (DataWidth == 64) begin : gen_bwd_d64
       always_comb begin : p_bwd_d64
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_64bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_64bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_64bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_64bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_64bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_64bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end else begin : gen_bwd_d32
       always_comb begin : p_bwd_d32
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_32bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_32bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_32bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
+        data_state_bwd = prince_shiftrows_32bit(data_state_xor1,
+            PRINCE_SHIFT_ROWS64_INV);
+        data_state_bwd = prince_mult_prime_32bit(data_state_bwd);
+        data_state[NumRoundsHalf+k+1] = sbox4_32bit(data_state_bwd,
+            PRINCE_SBOX4_INV);
       end
     end
   end
@@ -212,7 +212,7 @@ module prim_prince #(
   // post-rounds
   always_comb begin : p_post_round_xor
     data_o  = data_state[2*NumRoundsHalf+1] ^
-              prim_cipher_pkg::PRINCE_ROUND_CONST[11][DataWidth-1:0];
+              PRINCE_ROUND_CONST[11][DataWidth-1:0];
     data_o ^= k1_q;
     data_o ^= k0_prime_q;
   end
diff --git a/hw/ip/prim/rtl/prim_ram_2p_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
index c6b466982..d34b942cd 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input                    clk_i,
   input                    rst_ni,
@@ -36,18 +36,18 @@ module prim_ram_2p_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -55,8 +55,8 @@ module prim_ram_2p_adv #(
 );
 
   prim_ram_2p_async_adv #(
-    .Depth               (Depth),
-    .Width               (Width),
+    .RamDepth               (RamDepth),
+    .RamWidth               (RamWidth),
     .DataBitsPerMask     (DataBitsPerMask),
     .CfgW                (CfgW),
     .MemInitFile         (MemInitFile),
diff --git a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
index 8436345d7..06efc7aca 100644
--- a/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
+++ b/hw/ip/prim/rtl/prim_ram_2p_async_adv.sv
@@ -6,18 +6,18 @@
 //
 // Supported configurations:
 // - ECC for 32b wide memories with no write mask
-//   (Width == 32 && DataBitsPerMask == 32).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
+//   (RamWidth == 32 && DataBitsPerMask == 32).
+// - Byte parity if RamWidth is a multiple of 8 bit and write masks have Byte
 //   granularity (DataBitsPerMask == 8).
 //
 // Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
+// mask cannot be used and has to be tied to {RamWidth{1'b1}}.
 
 `include "prim_assert.sv"
 
 module prim_ram_2p_async_adv #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
+  parameter  int RamDepth                = 512,
+  parameter  int RamWidth                = 32,
   parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
   parameter  int CfgW                 = 8,  // WTC, RTC, etc
   parameter      MemInitFile          = "", // VMEM file to initialize the memory with
@@ -28,7 +28,7 @@ module prim_ram_2p_async_adv #(
   parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
   parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
 
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
+  localparam int Aw                   = prim_util_pkg::vbits(RamDepth)
 ) (
   input clk_a_i,
   input clk_b_i,
@@ -38,18 +38,18 @@ module prim_ram_2p_async_adv #(
   input                    a_req_i,
   input                    a_write_i,
   input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
+  input        [RamWidth-1:0] a_wdata_i,
+  input        [RamWidth-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] a_rdata_o,
   output logic             a_rvalid_o, // read response (a_rdata_o) is valid
   output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
   input                    b_req_i,
   input                    b_write_i,
   input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
+  input        [RamWidth-1:0] b_wdata_i,
+  input        [RamWidth-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
+  output logic [RamWidth-1:0] b_rdata_o,
   output logic             b_rvalid_o, // read response (b_rdata_o) is valid
   output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
 
@@ -67,14 +67,14 @@ module prim_ram_2p_async_adv #(
   localparam int LocalDataBitsPerMask = (EnableParity) ? 1 : DataBitsPerMask;
 
   // Calculate ECC width
-  localparam int ParWidth  = (EnableParity) ? Width/8 :
+  localparam int ParRamWidth  = (EnableParity) ? RamWidth/8 :
                              (!EnableECC)   ? 0 :
-                             (Width <=   4) ? 4 :
-                             (Width <=  11) ? 5 :
-                             (Width <=  26) ? 6 :
-                             (Width <=  57) ? 7 :
-                             (Width <= 120) ? 8 : 8 ;
-  localparam int TotalWidth = Width + ParWidth;
+                             (RamWidth <=   4) ? 4 :
+                             (RamWidth <=  11) ? 5 :
+                             (RamWidth <=  26) ? 6 :
+                             (RamWidth <=  57) ? 7 :
+                             (RamWidth <= 120) ? 8 : 8 ;
+  localparam int TotalRamWidth = RamWidth + ParRamWidth;
 
   ////////////////////////////
   // RAM Primitive Instance //
@@ -83,28 +83,28 @@ module prim_ram_2p_async_adv #(
   logic                    a_req_q,    a_req_d ;
   logic                    a_write_q,  a_write_d ;
   logic [Aw-1:0]           a_addr_q,   a_addr_d ;
-  logic [TotalWidth-1:0]   a_wdata_q,  a_wdata_d ;
-  logic [TotalWidth-1:0]   a_wmask_q,  a_wmask_d ;
+  logic [TotalRamWidth-1:0]   a_wdata_q,  a_wdata_d ;
+  logic [TotalRamWidth-1:0]   a_wmask_q,  a_wmask_d ;
   logic                    a_rvalid_q, a_rvalid_d, a_rvalid_sram ;
-  logic [Width-1:0]        a_rdata_q,  a_rdata_d ;
-  logic [TotalWidth-1:0]   a_rdata_sram ;
+  logic [RamWidth-1:0]        a_rdata_q,  a_rdata_d ;
+  logic [TotalRamWidth-1:0]   a_rdata_sram ;
   logic [1:0]              a_rerror_q, a_rerror_d ;
 
   logic                    b_req_q,    b_req_d ;
   logic                    b_write_q,  b_write_d ;
   logic [Aw-1:0]           b_addr_q,   b_addr_d ;
-  logic [TotalWidth-1:0]   b_wdata_q,  b_wdata_d ;
-  logic [TotalWidth-1:0]   b_wmask_q,  b_wmask_d ;
+  logic [TotalRamWidth-1:0]   b_wdata_q,  b_wdata_d ;
+  logic [TotalRamWidth-1:0]   b_wmask_q,  b_wmask_d ;
   logic                    b_rvalid_q, b_rvalid_d, b_rvalid_sram ;
-  logic [Width-1:0]        b_rdata_q,  b_rdata_d ;
-  logic [TotalWidth-1:0]   b_rdata_sram ;
+  logic [RamWidth-1:0]        b_rdata_q,  b_rdata_d ;
+  logic [TotalRamWidth-1:0]   b_rdata_sram ;
   logic [1:0]              b_rerror_q, b_rerror_d ;
 
   prim_ram_2p #(
     .MemInitFile     (MemInitFile),
 
-    .Width           (TotalWidth),
-    .Depth           (Depth),
+    .Width           (TotalRamWidth),
+    .Depth           (RamDepth),
     .DataBitsPerMask (LocalDataBitsPerMask)
   ) u_mem (
     .clk_a_i    (clk_a_i),
@@ -161,29 +161,29 @@ module prim_ram_2p_async_adv #(
   if (EnableParity == 0 && EnableECC) begin : gen_secded
 
     // check supported widths
-    `ASSERT_INIT(SecDecWidth_A, Width inside {32})
+    `ASSERT_INIT(SecDecRamWidth_A, RamWidth inside {32})
 
     // the wmask is constantly set to 1 in this case
     `ASSERT(OnlyWordWritePossibleWithEccPortA_A, a_req_i |->
-        a_wmask_i == {TotalWidth{1'b1}}, clk_a_i, rst_a_ni)
+        a_wmask_i == {TotalRamWidth{1'b1}}, clk_a_i, rst_a_ni)
     `ASSERT(OnlyWordWritePossibleWithEccPortB_A, b_req_i |->
-        b_wmask_i == {TotalWidth{1'b1}}, clk_b_i, rst_b_ni)
+        b_wmask_i == {TotalRamWidth{1'b1}}, clk_b_i, rst_b_ni)
 
-    assign a_wmask_d = {TotalWidth{1'b1}};
-    assign b_wmask_d = {TotalWidth{1'b1}};
+    assign a_wmask_d = {TotalRamWidth{1'b1}};
+    assign b_wmask_d = {TotalRamWidth{1'b1}};
 
-    if (Width == 32) begin : gen_secded_39_32
+    if (RamWidth == 32) begin : gen_secded_39_32
       prim_secded_39_32_enc u_enc_a (.in(a_wdata_i), .out(a_wdata_d));
       prim_secded_39_32_dec u_dec_a (
         .in         (a_rdata_sram),
-        .d_o        (a_rdata_d[0+:Width]),
+        .d_o        (a_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (a_rerror_d)
       );
       prim_secded_39_32_enc u_enc_b (.in(b_wdata_i), .out(b_wdata_d));
       prim_secded_39_32_dec u_dec_b (
         .in         (b_rdata_sram),
-        .d_o        (b_rdata_d[0+:Width]),
+        .d_o        (b_rdata_d[0+:RamWidth]),
         .syndrome_o ( ),
         .err_o      (b_rerror_d)
       );
@@ -191,40 +191,40 @@ module prim_ram_2p_async_adv #(
   end else if (EnableParity) begin : gen_byte_parity
 
     `ASSERT_INIT(ParityNeedsByteWriteMask_A, DataBitsPerMask == 8)
-    `ASSERT_INIT(WidthNeedsToBeByteAligned_A, Width % 8 == 0)
+    `ASSERT_INIT(RamWidthNeedsToBeByteAligned_A, RamWidth % 8 == 0)
 
     always_comb begin : p_parity
       a_rerror_d = '0;
       b_rerror_d = '0;
-      a_wmask_d[0+:Width] = a_wmask_i;
-      b_wmask_d[0+:Width] = b_wmask_i;
-      a_wdata_d[0+:Width] = a_wdata_i;
-      b_wdata_d[0+:Width] = b_wdata_i;
+      a_wmask_d[0+:RamWidth] = a_wmask_i;
+      b_wmask_d[0+:RamWidth] = b_wmask_i;
+      a_wdata_d[0+:RamWidth] = a_wdata_i;
+      b_wdata_d[0+:RamWidth] = b_wdata_i;
 
-      for (int i = 0; i < Width/8; i ++) begin
+      for (int i = 0; i < RamWidth/8; i ++) begin
         // parity generation (odd parity)
-        a_wdata_d[Width + i] = ~(^a_wdata_i[i*8 +: 8]);
-        b_wdata_d[Width + i] = ~(^b_wdata_i[i*8 +: 8]);
-        a_wmask_d[Width + i] = &a_wmask_i[i*8 +: 8];
-        b_wmask_d[Width + i] = &b_wmask_i[i*8 +: 8];
+        a_wdata_d[RamWidth + i] = ~(^a_wdata_i[i*8 +: 8]);
+        b_wdata_d[RamWidth + i] = ~(^b_wdata_i[i*8 +: 8]);
+        a_wmask_d[RamWidth + i] = &a_wmask_i[i*8 +: 8];
+        b_wmask_d[RamWidth + i] = &b_wmask_i[i*8 +: 8];
         // parity decoding (errors are always uncorrectable)
-        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[Width + i]});
-        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[Width + i]});
+        a_rerror_d[1] |= ~(^{a_rdata_sram[i*8 +: 8], a_rdata_sram[RamWidth + i]});
+        b_rerror_d[1] |= ~(^{b_rdata_sram[i*8 +: 8], b_rdata_sram[RamWidth + i]});
       end
       // tie to zero if the read data is not valid
       a_rerror_d &= {2{a_rvalid_sram}};
       b_rerror_d &= {2{b_rvalid_sram}};
     end
 
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
   end else begin : gen_nosecded_noparity
     assign a_wmask_d  = a_wmask_i;
     assign b_wmask_d  = b_wmask_i;
     assign a_wdata_d  = a_wdata_i;
     assign b_wdata_d  = b_wdata_i;
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
+    assign a_rdata_d  = a_rdata_sram[0+:RamWidth];
+    assign b_rdata_d  = b_rdata_sram[0+:RamWidth];
     assign a_rerror_d = '0;
     assign b_rerror_d = '0;
   end
diff --git a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
index 962d3b559..d6430bc5a 100644
--- a/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
+++ b/hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv
@@ -70,10 +70,10 @@ module prim_generic_pad_wrapper #(
     assign oe       = oe_i & ((od & ~out) | ~od);
 
   // driving strength attributes are not supported by verilator
-`ifdef VERILATOR
-    assign inout_io = (oe)   ? out : 1'bz;
+`ifdef SYNTHESIS
+    assign inout_io = out;
     // received data driver
-    assign in_o     = (ie_i) ? in  : 1'bz;
+    assign in_o     = in;
 `else
     // different driver types
     assign (strong0, strong1) inout_io = (oe && drv != DRIVE_00) ? out : 1'bz;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
index c4ccd9b2d..5229b6a82 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv
@@ -54,6 +54,8 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
 
 );
 
+  import pwrmgr_pkg::*;
+
   ////////////////////////////////
   // Sync from clk_i to clk_slow_i
   ////////////////////////////////
@@ -137,11 +139,11 @@ module pwrmgr_cdc import pwrmgr_pkg::*; import pwrmgr_reg_pkg::*;
   // only register configurations can be sync'd using slow_cdc_sync
   always_ff @(posedge clk_slow_i or negedge rst_slow_ni) begin
     if (!rst_slow_ni) begin
-      slow_wakeup_en_o <= '0;
-      slow_reset_en_o <= '0;
-      slow_main_pd_no <= '0;
-      slow_io_clk_en_o <= '0;
-      slow_core_clk_en_o <= '0;
+      slow_wakeup_en_o <= 16'h0000;
+      slow_reset_en_o <= 2'b00;
+      slow_main_pd_no <= 1'b0;
+      slow_io_clk_en_o <= 1'b0;
+      slow_core_clk_en_o <= 1'b0;
     end else if (slow_cdc_sync) begin
       slow_wakeup_en_o <= wakeup_en_i;
       slow_reset_en_o <= reset_en_i;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
index ef4712bf5..336e2ff7d 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv
@@ -131,7 +131,7 @@ module pwrmgr_fsm import pwrmgr_pkg::*; (
     end
   end
 
-  always_comb begin
+  always begin
     otp_init = 1'b0;
     lc_init = 1'b0;
     wkup_o = 1'b0;
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
index a5669d597..4f39a8b53 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv
@@ -35,19 +35,9 @@ package pwrmgr_pkg;
   } pwr_ast_rsp_t;
 
   // default value of pwr_ast_rsp (for dangling ports)
-  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = '{
-    slow_clk_val: 2'b10,
-    core_clk_val: 2'b10,
-    io_clk_val: 2'b10,
-    main_pok: 1'b1
-  };
-
-  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = '{
-    slow_clk_val: 2'b01,
-    core_clk_val: 2'b01,
-    io_clk_val: 2'b10,
-    main_pok: 1'b0
-  };
+  parameter pwr_ast_rsp_t PWR_AST_RSP_DEFAULT = 7'b1010101;
+
+  parameter pwr_ast_rsp_t PWR_AST_RSP_SYNC_DEFAULT = 7'b0101100;
 
   // reasons for pwrmgr reset reset
   typedef enum logic [1:0] {
@@ -71,10 +61,7 @@ package pwrmgr_pkg;
   } pwr_rst_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = '{
-    rst_lc_src_n: {PowerDomains{1'b1}},
-    rst_sys_src_n: {PowerDomains{1'b1}}
-  };
+  parameter pwr_rst_rsp_t PWR_RST_RSP_DEFAULT = 4'b1111;
 
   // pwrmgr to clkmgr
   typedef struct packed {
@@ -98,10 +85,7 @@ package pwrmgr_pkg;
   } pwr_otp_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = '{
-    otp_done: 1'b1,
-    otp_idle: 1'b1
-  };
+  parameter pwr_otp_rsp_t PWR_OTP_RSP_DEFAULT = 2'b11;
 
   // pwrmgr to lifecycle
   typedef struct packed {
@@ -115,10 +99,7 @@ package pwrmgr_pkg;
   } pwr_lc_rsp_t;
 
   // default value (for dangling ports)
-  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = '{
-    lc_done: 1'b1,
-    lc_idle: 1'b1
-  };
+  parameter pwr_lc_rsp_t PWR_LC_RSP_DEFAULT = 2'b11;
 
   // flash to pwrmgr
   typedef struct packed {
@@ -126,9 +107,7 @@ package pwrmgr_pkg;
   } pwr_flash_t;
 
   // default value (for dangling ports)
-  parameter pwr_flash_t PWR_FLASH_DEFAULT = '{
-    flash_idle: 1'b1
-  };
+  parameter pwr_flash_t PWR_FLASH_DEFAULT = 1'b1;
 
   // processor to pwrmgr
   typedef struct packed {
@@ -136,13 +115,11 @@ package pwrmgr_pkg;
   } pwr_cpu_t;
 
   // default value (for dangling ports)
-  parameter pwr_cpu_t PWR_CPU_DEFAULT = '{
-    core_sleeping: 1'b0
-  };
+  parameter pwr_cpu_t PWR_CPU_DEFAULT = 1'b0;
 
   // default value (for dangling ports)
-  parameter int WAKEUPS_DEFAULT = '0;
-  parameter int RSTREQS_DEFAULT = '0;
+  parameter int WAKEUPS_DEFAULT = 0;
+  parameter int RSTREQS_DEFAULT = 0;
 
   // peripherals to pwrmgr
   typedef struct packed {
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
index 4a6a9d709..3c755c66f 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv
@@ -116,7 +116,7 @@ package pwrmgr_reg_pkg;
     pwrmgr_reg2hw_intr_test_reg_t intr_test; // [47:46]
     pwrmgr_reg2hw_control_reg_t control; // [45:42]
     pwrmgr_reg2hw_cfg_cdc_sync_reg_t cfg_cdc_sync; // [41:40]
-    pwrmgr_reg2hw_wakeup_en_mreg_t [15:0] wakeup_en; // [39:24]
+    logic [15:0] wakeup_en; // [39:24]
     pwrmgr_reg2hw_reset_en_reg_t reset_en; // [23:22]
     pwrmgr_reg2hw_wake_info_capture_dis_reg_t wake_info_capture_dis; // [21:21]
     pwrmgr_reg2hw_wake_info_reg_t wake_info; // [20:0]
diff --git a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
index 6080cf464..31418f345 100644
--- a/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
+++ b/hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv
@@ -456,7 +456,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[0].q ),
+    .q      (reg2hw.wakeup_en[0] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en0_qs)
@@ -482,7 +482,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[1].q ),
+    .q      (reg2hw.wakeup_en[1] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en1_qs)
@@ -508,7 +508,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[2].q ),
+    .q      (reg2hw.wakeup_en[2] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en2_qs)
@@ -534,7 +534,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[3].q ),
+    .q      (reg2hw.wakeup_en[3] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en3_qs)
@@ -560,7 +560,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[4].q ),
+    .q      (reg2hw.wakeup_en[4] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en4_qs)
@@ -586,7 +586,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[5].q ),
+    .q      (reg2hw.wakeup_en[5] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en5_qs)
@@ -612,7 +612,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[6].q ),
+    .q      (reg2hw.wakeup_en[6] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en6_qs)
@@ -638,7 +638,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[7].q ),
+    .q      (reg2hw.wakeup_en[7] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en7_qs)
@@ -664,7 +664,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[8].q ),
+    .q      (reg2hw.wakeup_en[8] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en8_qs)
@@ -690,7 +690,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[9].q ),
+    .q      (reg2hw.wakeup_en[9] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en9_qs)
@@ -716,7 +716,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[10].q ),
+    .q      (reg2hw.wakeup_en[10] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en10_qs)
@@ -742,7 +742,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[11].q ),
+    .q      (reg2hw.wakeup_en[11] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en11_qs)
@@ -768,7 +768,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[12].q ),
+    .q      (reg2hw.wakeup_en[12] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en12_qs)
@@ -794,7 +794,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[13].q ),
+    .q      (reg2hw.wakeup_en[13] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en13_qs)
@@ -820,7 +820,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[14].q ),
+    .q      (reg2hw.wakeup_en[14] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en14_qs)
@@ -846,7 +846,7 @@ module pwrmgr_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.wakeup_en[15].q ),
+    .q      (reg2hw.wakeup_en[15] ),
 
     // to register interface (read)
     .qs     (wakeup_en_en15_qs)
diff --git a/hw/ip/spi_device/rtl/spi_device.sv b/hw/ip/spi_device/rtl/spi_device.sv
index f7f9ed1bf..0b0fd2f7e 100644
--- a/hw/ip/spi_device/rtl/spi_device.sv
+++ b/hw/ip/spi_device/rtl/spi_device.sv
@@ -519,8 +519,8 @@ module spi_device #(
 
   // SRAM Wrapper
   prim_ram_2p_adv #(
-    .Depth (512),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (512),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .DataBitsPerMask (1),
     .CfgW  (8),
 
diff --git a/hw/ip/tlul/rtl/tlul_adapter_reg.sv b/hw/ip/tlul/rtl/tlul_adapter_reg.sv
index c451308bd..a0dd153b8 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_reg.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_reg.sv
@@ -30,8 +30,8 @@ module tlul_adapter_reg import tlul_pkg::*; #(
   input                    error_i
 );
 
-  localparam int IW  = $bits(tl_i.a_source);
-  localparam int SZW = $bits(tl_i.a_size);
+  localparam int IW  = 8;
+  localparam int SZW = 2;
 
   logic outstanding;    // Indicates current request is pending
   logic a_ack, d_ack;
@@ -69,8 +69,8 @@ module tlul_adapter_reg import tlul_pkg::*; #(
 
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      reqid <= '0;
-      reqsz <= '0;
+      reqid <= {IW{1'b0}};
+      reqsz <= {SZW{1'b0}};
       rspop <= AccessAck;
     end else if (a_ack) begin
       reqid <= tl_i.a_source;
@@ -82,10 +82,10 @@ module tlul_adapter_reg import tlul_pkg::*; #(
 
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
-      rdata  <= '0;
+      rdata  <= {RegDw{1'b0}};
       error <= 1'b0;
     end else if (a_ack) begin
-      rdata <= (err_internal) ? '1 : rdata_i;
+      rdata <= (err_internal) ? {RegDw{1'b1}} : rdata_i;
       error <= error_i | err_internal;
     end
   end
@@ -94,12 +94,12 @@ module tlul_adapter_reg import tlul_pkg::*; #(
     a_ready:  ~outstanding,
     d_valid:  outstanding,
     d_opcode: rspop,
-    d_param:  '0,
+    d_param:  3'b000,
     d_size:   reqsz,
     d_source: reqid,
-    d_sink:   '0,
+    d_sink:   1'b0,
     d_data:   rdata,
-    d_user:  '0,
+    d_user:  16'b0000000000000000,
     d_error: error
   };
 
diff --git a/hw/ip/tlul/rtl/tlul_adapter_sram.sv b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
index 6e2f33191..cb3e9088c 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_sram.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
@@ -174,7 +174,7 @@ module tlul_adapter_sram #(
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wmask_int;
   logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wdata_int;
 
-  always_comb begin
+  always begin
     wmask_int = '0;
     wdata_int = '0;
 
diff --git a/hw/ip/tlul/rtl/tlul_err.sv b/hw/ip/tlul/rtl/tlul_err.sv
index add8477ba..4ab895782 100644
--- a/hw/ip/tlul/rtl/tlul_err.sv
+++ b/hw/ip/tlul/rtl/tlul_err.sv
@@ -14,11 +14,11 @@ module tlul_err import tlul_pkg::*; (
   output logic err_o
 );
 
-  localparam int IW  = $bits(tl_i.a_source);
-  localparam int SZW = $bits(tl_i.a_size);
-  localparam int DW  = $bits(tl_i.a_data);
-  localparam int MW  = $bits(tl_i.a_mask);
-  localparam int SubAW = $clog2(DW/8);
+  localparam int IW  = 8;
+  localparam int SZW = 2;
+  localparam int DW  = 32;
+  localparam int MW  = 4;
+  localparam int SubAW = 2;
 
   logic opcode_allowed, a_config_allowed;
 
@@ -42,7 +42,7 @@ module tlul_err import tlul_pkg::*; (
 
   logic [MW-1:0] mask;
 
-  assign mask = (1 << tl_i.a_address[SubAW-1:0]);
+  assign mask = (1 << $unsigned(tl_i.a_address[SubAW-1:0]));
 
   always_comb begin
     addr_sz_chk  = 1'b0;
@@ -51,13 +51,13 @@ module tlul_err import tlul_pkg::*; (
 
     if (tl_i.a_valid) begin
       unique case (tl_i.a_size)
-        'h0: begin // 1 Byte
+        64'h0: begin // 1 Byte
           addr_sz_chk  = 1'b1;
           mask_chk     = ~|(tl_i.a_mask & ~mask);
           fulldata_chk = |(tl_i.a_mask & mask);
         end
 
-        'h1: begin // 2 Byte
+        64'h1: begin // 2 Byte
           addr_sz_chk  = ~tl_i.a_address[0];
           // check inactive lanes if lower 2B, check a_mask[3:2], if uppwer 2B, a_mask[1:0]
           mask_chk     = (tl_i.a_address[1]) ? ~|(tl_i.a_mask & 4'b0011)
@@ -65,7 +65,7 @@ module tlul_err import tlul_pkg::*; (
           fulldata_chk = (tl_i.a_address[1]) ? &tl_i.a_mask[3:2] : &tl_i.a_mask[1:0] ;
         end
 
-        'h2: begin // 4 Byte
+        64'h2: begin // 4 Byte
           addr_sz_chk  = ~|tl_i.a_address[SubAW-1:0];
           mask_chk     = 1'b1;
           fulldata_chk = &tl_i.a_mask[3:0];
diff --git a/hw/ip/tlul/rtl/tlul_fifo_sync.sv b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
index 59fe3ffd4..071a30b94 100644
--- a/hw/ip/tlul/rtl/tlul_fifo_sync.sv
+++ b/hw/ip/tlul/rtl/tlul_fifo_sync.sv
@@ -7,8 +7,8 @@
 // and one for the response side.
 
 module tlul_fifo_sync #(
-  parameter int unsigned ReqPass  = 1'b1,
-  parameter int unsigned RspPass  = 1'b1,
+  parameter int unsigned ReqPass  = 0,
+  parameter int unsigned RspPass  = 0,
   parameter int unsigned ReqDepth = 2,
   parameter int unsigned RspDepth = 2,
   parameter int unsigned SpareReqW = 1,
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1.sv b/hw/ip/tlul/rtl/tlul_socket_m1.sv
index 8637ad221..fe7aa9858 100644
--- a/hw/ip/tlul/rtl/tlul_socket_m1.sv
+++ b/hw/ip/tlul/rtl/tlul_socket_m1.sv
@@ -92,9 +92,11 @@ module tlul_socket_m1 #(
     // ID Shifting
     logic [STIDW-1:0] reqid_sub;
     logic [IDW-1:0] shifted_id;
+    logic [7:0] tmp;
+    assign tmp = tl_h_i[i].a_source;
     assign reqid_sub = i;   // can cause conversion error?
     assign shifted_id = {
-      tl_h_i[i].a_source[0+:(IDW-STIDW)],
+      tmp[0+:(IDW-STIDW)],
       reqid_sub
     };
 
@@ -102,21 +104,19 @@ module tlul_socket_m1 #(
 
     // assign not connected bits to nc_* signal to make lint happy
     logic [IDW-1 : IDW-STIDW] unused_tl_h_source;
-    assign unused_tl_h_source = tl_h_i[i].a_source[IDW-1 -: STIDW];
+    assign unused_tl_h_source = tmp[IDW-1 -: STIDW];
 
     // Put shifted ID
-    assign hreq_fifo_i = '{
-      a_valid:    tl_h_i[i].a_valid,
-      a_opcode:   tl_h_i[i].a_opcode,
-      a_param:    tl_h_i[i].a_param,
-      a_size:     tl_h_i[i].a_size,
-      a_source:   shifted_id,
-      a_address:  tl_h_i[i].a_address,
-      a_mask:     tl_h_i[i].a_mask,
-      a_data:     tl_h_i[i].a_data,
-      a_user:     tl_h_i[i].a_user,
-      d_ready:    tl_h_i[i].d_ready
-    };
+    assign hreq_fifo_i.a_valid = tl_h_i[i].a_valid;
+    assign hreq_fifo_i.a_opcode = tl_h_i[i].a_opcode;
+    assign hreq_fifo_i.a_param = tl_h_i[i].a_param;
+    assign hreq_fifo_i.a_size = tl_h_i[i].a_size;
+    assign hreq_fifo_i.a_source = shifted_id;
+    assign hreq_fifo_i.a_address = tl_h_i[i].a_address;
+    assign hreq_fifo_i.a_mask = tl_h_i[i].a_mask;
+    assign hreq_fifo_i.a_data = tl_h_i[i].a_data;
+    assign hreq_fifo_i.a_user = tl_h_i[i].a_user;
+    assign hreq_fifo_i.d_ready = tl_h_i[i].d_ready;
 
     tlul_fifo_sync #(
       .ReqPass    (HReqPass[i]),
@@ -237,18 +237,16 @@ module tlul_socket_m1 #(
                                (drsp_fifo_o.d_source[0+:STIDW] == i) &
                               drsp_fifo_o.d_valid;
 
-    assign hrsp_fifo_i[i] = '{
-      d_valid:  hfifo_rspvalid[i],
-      d_opcode: drsp_fifo_o.d_opcode,
-      d_param:  drsp_fifo_o.d_param,
-      d_size:   drsp_fifo_o.d_size,
-      d_source: hfifo_rspid,
-      d_sink:   drsp_fifo_o.d_sink,
-      d_data:   drsp_fifo_o.d_data,
-      d_user:   drsp_fifo_o.d_user,
-      d_error:  drsp_fifo_o.d_error,
-      a_ready:  hgrant[i]
-    };
+    assign hrsp_fifo_i[i].d_valid = hfifo_rspvalid[i];
+    assign hrsp_fifo_i[i].d_opcode = drsp_fifo_o.d_opcode;
+    assign hrsp_fifo_i[i].d_param = drsp_fifo_o.d_param;
+    assign hrsp_fifo_i[i].d_size = drsp_fifo_o.d_size;
+    assign hrsp_fifo_i[i].d_source = hfifo_rspid;
+    assign hrsp_fifo_i[i].d_sink = drsp_fifo_o.d_sink;
+    assign hrsp_fifo_i[i].d_data = drsp_fifo_o.d_data;
+    assign hrsp_fifo_i[i].d_user = drsp_fifo_o.d_user;
+    assign hrsp_fifo_i[i].d_error = drsp_fifo_o.d_error;
+    assign hrsp_fifo_i[i].a_ready = hgrant[i];
   end
 
   // this assertion fails when rspid[0+:STIDW] not in [0..M-1]
diff --git a/hw/ip/uart/rtl/uart_reg_top.sv b/hw/ip/uart/rtl/uart_reg_top.sv
index f25d459ef..c5ea11cb2 100644
--- a/hw/ip/uart/rtl/uart_reg_top.sv
+++ b/hw/ip/uart/rtl/uart_reg_top.sv
@@ -949,7 +949,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (2'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -975,7 +975,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (16'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -1085,7 +1085,7 @@ module uart_reg_top (
   ) u_rdata (
     .re     (rdata_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (8'b0),
     .d      (hw2reg.rdata.d),
     .qre    (reg2hw.rdata.re),
     .qe     (),
@@ -1110,7 +1110,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (8'b0  ),
 
     // to internal hardware
     .qe     (reg2hw.wdata.qe),
@@ -1232,7 +1232,7 @@ module uart_reg_top (
   ) u_fifo_status_txlvl (
     .re     (fifo_status_txlvl_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (6'b0),
     .d      (hw2reg.fifo_status.txlvl.d),
     .qre    (),
     .qe     (),
@@ -1247,7 +1247,7 @@ module uart_reg_top (
   ) u_fifo_status_rxlvl (
     .re     (fifo_status_rxlvl_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (6'b0),
     .d      (hw2reg.fifo_status.rxlvl.d),
     .qre    (),
     .qe     (),
@@ -1317,7 +1317,7 @@ module uart_reg_top (
   ) u_val (
     .re     (val_re),
     .we     (1'b0),
-    .wd     ('0),
+    .wd     (16'b0),
     .d      (hw2reg.val.d),
     .qre    (),
     .qe     (),
@@ -1343,7 +1343,7 @@ module uart_reg_top (
 
     // from internal hardware
     .de     (1'b0),
-    .d      ('0  ),
+    .d      (24'b0  ),
 
     // to internal hardware
     .qe     (),
@@ -1384,7 +1384,7 @@ module uart_reg_top (
 
   logic [11:0] addr_hit;
   always_comb begin
-    addr_hit = '0;
+    addr_hit = 12'b000000000000;
     addr_hit[ 0] = (reg_addr == UART_INTR_STATE_OFFSET);
     addr_hit[ 1] = (reg_addr == UART_INTR_ENABLE_OFFSET);
     addr_hit[ 2] = (reg_addr == UART_INTR_TEST_OFFSET);
@@ -1566,7 +1566,7 @@ module uart_reg_top (
 
   // Read data return
   always_comb begin
-    reg_rdata_next = '0;
+    reg_rdata_next = {DW{1'b0}};
     unique case (1'b1)
       addr_hit[0]: begin
         reg_rdata_next[0] = intr_state_tx_watermark_qs;
@@ -1627,7 +1627,7 @@ module uart_reg_top (
       end
 
       addr_hit[6]: begin
-        reg_rdata_next[7:0] = '0;
+        reg_rdata_next[7:0] = {8{1'b0}};
       end
 
       addr_hit[7]: begin
@@ -1657,7 +1657,7 @@ module uart_reg_top (
       end
 
       default: begin
-        reg_rdata_next = '1;
+        reg_rdata_next = {DW{1'b1}};
       end
     endcase
   end
diff --git a/hw/ip/usbdev/rtl/usbdev.sv b/hw/ip/usbdev/rtl/usbdev.sv
index cbdadd624..42a4d1b7a 100644
--- a/hw/ip/usbdev/rtl/usbdev.sv
+++ b/hw/ip/usbdev/rtl/usbdev.sv
@@ -563,7 +563,7 @@ module usbdev (
 
   // CDC for event signals (arguably they are there for a long time so would be ok)
   // Just want a pulse to ensure only one interrupt for an event
-  usbdev_flop_2syncpulse #(.Width(5)) syncevent (
+  usbdev_flop_2syncpulse #(.UsbWidth(5)) syncevent (
     .clk_i  (clk_i),
     .rst_ni (rst_ni),
     .d_i    ({usb_event_disconnect, usb_event_link_reset, usb_event_link_suspend,
@@ -654,8 +654,8 @@ module usbdev (
 
   // SRAM Wrapper
   prim_ram_2p_async_adv #(
-    .Depth (SramDepth),
-    .Width (SramDw),    // 32 x 512 --> 2kB
+    .RamDepth (SramDepth),
+    .RamWidth (SramDw),    // 32 x 512 --> 2kB
     .CfgW  (8),
 
     .EnableECC           (0), // No Protection
diff --git a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
index 9889b0a1f..9b297e67f 100644
--- a/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
+++ b/hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv
@@ -5,17 +5,17 @@
 // Generic double-synchronizer flop followed by pulse generation
 
 module usbdev_flop_2syncpulse #(
-  parameter int unsigned Width = 16
+  parameter int unsigned UsbWidth = 16
 ) (
   input  logic             clk_i,    // receive clock
   input  logic             rst_ni,
-  input  logic [Width-1:0] d_i,
-  output logic [Width-1:0] q_o
+  input  logic [UsbWidth-1:0] d_i,
+  output logic [UsbWidth-1:0] q_o
 );
 
   // double-flop synchronizer cell
-  logic [Width-1:0] d_sync;
-  prim_flop_2sync #(.Width (Width)) prim_flop_2sync (
+  logic [UsbWidth-1:0] d_sync;
+  prim_flop_2sync #(.Width (UsbWidth)) prim_flop_2sync (
     .clk_i,
     .rst_ni,
     .d_i,
@@ -23,7 +23,7 @@ module usbdev_flop_2syncpulse #(
   );
 
   // delay d_sync by 1 cycle
-  logic [Width-1:0] d_sync_q;
+  logic [UsbWidth-1:0] d_sync_q;
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
       d_sync_q <= '0;
diff --git a/hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv b/hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv
index bf3bc9fc3..88828411c 100644
--- a/hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv
+++ b/hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv
@@ -14,8 +14,10 @@ module pinmux_reg_top (
   input  tlul_pkg::tl_h2d_t tl_i,
   output tlul_pkg::tl_d2h_t tl_o,
   // To HW
-  output pinmux_reg_pkg::pinmux_reg2hw_t reg2hw, // Write
-  input  pinmux_reg_pkg::pinmux_hw2reg_t hw2reg, // Read
+  //output pinmux_reg_pkg::pinmux_reg2hw_t reg2hw, // Write
+  //input  pinmux_reg_pkg::pinmux_hw2reg_t hw2reg, // Read
+  output wire [660:0] reg2hw,
+  input wire [37:0] hw2reg,
 
   // Config
   input devmode_i // If 1, explicit error return for unmapped register access
@@ -598,4263 +600,2417 @@ module pinmux_reg_top (
   logic wkup_cause_cause7_wd;
   logic wkup_cause_cause7_we;
   logic wkup_cause_cause7_re;
-
-  // Register instances
-  // R[regen]: V(False)
-
   prim_subreg #(
-    .DW      (1),
+    .DW(1),
     .SWACCESS("W0C"),
-    .RESVAL  (1'h1)
-  ) u_regen (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface
-    .we     (regen_we),
-    .wd     (regen_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (),
-
-    // to register interface (read)
-    .qs     (regen_qs)
-  );
-
-
-
-  // Subregister 0 of Multireg periph_insel
-  // R[periph_insel0]: V(False)
-
-  // F[in0]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel0_in0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel0_in0_we & regen_qs),
-    .wd     (periph_insel0_in0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[0].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel0_in0_qs)
-  );
-
-
-  // F[in1]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel0_in1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel0_in1_we & regen_qs),
-    .wd     (periph_insel0_in1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[1].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel0_in1_qs)
-  );
-
-
-  // F[in2]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel0_in2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel0_in2_we & regen_qs),
-    .wd     (periph_insel0_in2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[2].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel0_in2_qs)
-  );
-
-
-  // F[in3]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel0_in3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel0_in3_we & regen_qs),
-    .wd     (periph_insel0_in3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[3].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel0_in3_qs)
-  );
-
-
-  // F[in4]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel0_in4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel0_in4_we & regen_qs),
-    .wd     (periph_insel0_in4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[4].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel0_in4_qs)
-  );
-
-
-  // Subregister 5 of Multireg periph_insel
-  // R[periph_insel1]: V(False)
-
-  // F[in5]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel1_in5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel1_in5_we & regen_qs),
-    .wd     (periph_insel1_in5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[5].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel1_in5_qs)
-  );
-
-
-  // F[in6]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel1_in6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel1_in6_we & regen_qs),
-    .wd     (periph_insel1_in6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[6].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel1_in6_qs)
-  );
-
-
-  // F[in7]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel1_in7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel1_in7_we & regen_qs),
-    .wd     (periph_insel1_in7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[7].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel1_in7_qs)
-  );
-
-
-  // F[in8]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel1_in8 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel1_in8_we & regen_qs),
-    .wd     (periph_insel1_in8_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[8].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel1_in8_qs)
-  );
-
-
-  // F[in9]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel1_in9 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel1_in9_we & regen_qs),
-    .wd     (periph_insel1_in9_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[9].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel1_in9_qs)
-  );
-
-
-  // Subregister 10 of Multireg periph_insel
-  // R[periph_insel2]: V(False)
-
-  // F[in10]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel2_in10 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel2_in10_we & regen_qs),
-    .wd     (periph_insel2_in10_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[10].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel2_in10_qs)
-  );
-
-
-  // F[in11]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel2_in11 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel2_in11_we & regen_qs),
-    .wd     (periph_insel2_in11_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[11].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel2_in11_qs)
-  );
-
-
-  // F[in12]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel2_in12 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel2_in12_we & regen_qs),
-    .wd     (periph_insel2_in12_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[12].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel2_in12_qs)
-  );
-
-
-  // F[in13]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel2_in13 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel2_in13_we & regen_qs),
-    .wd     (periph_insel2_in13_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[13].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel2_in13_qs)
-  );
-
-
-  // F[in14]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel2_in14 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel2_in14_we & regen_qs),
-    .wd     (periph_insel2_in14_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[14].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel2_in14_qs)
-  );
-
-
-  // Subregister 15 of Multireg periph_insel
-  // R[periph_insel3]: V(False)
-
-  // F[in15]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel3_in15 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel3_in15_we & regen_qs),
-    .wd     (periph_insel3_in15_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[15].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel3_in15_qs)
-  );
-
-
-  // F[in16]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel3_in16 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel3_in16_we & regen_qs),
-    .wd     (periph_insel3_in16_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[16].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel3_in16_qs)
-  );
-
-
-  // F[in17]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel3_in17 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel3_in17_we & regen_qs),
-    .wd     (periph_insel3_in17_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[17].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel3_in17_qs)
-  );
-
-
-  // F[in18]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel3_in18 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel3_in18_we & regen_qs),
-    .wd     (periph_insel3_in18_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[18].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel3_in18_qs)
-  );
-
-
-  // F[in19]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel3_in19 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel3_in19_we & regen_qs),
-    .wd     (periph_insel3_in19_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[19].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel3_in19_qs)
-  );
-
-
-  // Subregister 20 of Multireg periph_insel
-  // R[periph_insel4]: V(False)
-
-  // F[in20]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel4_in20 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel4_in20_we & regen_qs),
-    .wd     (periph_insel4_in20_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[20].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel4_in20_qs)
-  );
-
-
-  // F[in21]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel4_in21 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel4_in21_we & regen_qs),
-    .wd     (periph_insel4_in21_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[21].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel4_in21_qs)
-  );
-
-
-  // F[in22]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel4_in22 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel4_in22_we & regen_qs),
-    .wd     (periph_insel4_in22_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[22].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel4_in22_qs)
-  );
-
-
-  // F[in23]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel4_in23 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel4_in23_we & regen_qs),
-    .wd     (periph_insel4_in23_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[23].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel4_in23_qs)
-  );
-
-
-  // F[in24]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel4_in24 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel4_in24_we & regen_qs),
-    .wd     (periph_insel4_in24_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[24].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel4_in24_qs)
-  );
-
-
-  // Subregister 25 of Multireg periph_insel
-  // R[periph_insel5]: V(False)
-
-  // F[in25]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel5_in25 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel5_in25_we & regen_qs),
-    .wd     (periph_insel5_in25_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[25].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel5_in25_qs)
+    .RESVAL(1'h1)
+  ) u_regen(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(regen_we),
+    .wd(regen_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(),
+    .qs(regen_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel0_in0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel0_in0_we & regen_qs),
+    .wd(periph_insel0_in0_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[474-:6]),
+    .qs(periph_insel0_in0_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel0_in1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel0_in1_we & regen_qs),
+    .wd(periph_insel0_in1_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[480-:6]),
+    .qs(periph_insel0_in1_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel0_in2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel0_in2_we & regen_qs),
+    .wd(periph_insel0_in2_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[486-:6]),
+    .qs(periph_insel0_in2_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel0_in3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel0_in3_we & regen_qs),
+    .wd(periph_insel0_in3_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[492-:6]),
+    .qs(periph_insel0_in3_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel0_in4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel0_in4_we & regen_qs),
+    .wd(periph_insel0_in4_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[498-:6]),
+    .qs(periph_insel0_in4_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel1_in5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel1_in5_we & regen_qs),
+    .wd(periph_insel1_in5_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[504-:6]),
+    .qs(periph_insel1_in5_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel1_in6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel1_in6_we & regen_qs),
+    .wd(periph_insel1_in6_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[510-:6]),
+    .qs(periph_insel1_in6_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel1_in7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel1_in7_we & regen_qs),
+    .wd(periph_insel1_in7_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[516-:6]),
+    .qs(periph_insel1_in7_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel1_in8(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel1_in8_we & regen_qs),
+    .wd(periph_insel1_in8_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[522-:6]),
+    .qs(periph_insel1_in8_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel1_in9(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel1_in9_we & regen_qs),
+    .wd(periph_insel1_in9_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[528-:6]),
+    .qs(periph_insel1_in9_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel2_in10(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel2_in10_we & regen_qs),
+    .wd(periph_insel2_in10_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[534-:6]),
+    .qs(periph_insel2_in10_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel2_in11(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel2_in11_we & regen_qs),
+    .wd(periph_insel2_in11_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[540-:6]),
+    .qs(periph_insel2_in11_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel2_in12(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel2_in12_we & regen_qs),
+    .wd(periph_insel2_in12_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[546-:6]),
+    .qs(periph_insel2_in12_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel2_in13(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel2_in13_we & regen_qs),
+    .wd(periph_insel2_in13_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[552-:6]),
+    .qs(periph_insel2_in13_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel2_in14(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel2_in14_we & regen_qs),
+    .wd(periph_insel2_in14_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[558-:6]),
+    .qs(periph_insel2_in14_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel3_in15(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel3_in15_we & regen_qs),
+    .wd(periph_insel3_in15_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[564-:6]),
+    .qs(periph_insel3_in15_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel3_in16(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel3_in16_we & regen_qs),
+    .wd(periph_insel3_in16_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[570-:6]),
+    .qs(periph_insel3_in16_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel3_in17(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel3_in17_we & regen_qs),
+    .wd(periph_insel3_in17_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[576-:6]),
+    .qs(periph_insel3_in17_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel3_in18(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel3_in18_we & regen_qs),
+    .wd(periph_insel3_in18_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[582-:6]),
+    .qs(periph_insel3_in18_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel3_in19(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel3_in19_we & regen_qs),
+    .wd(periph_insel3_in19_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[588-:6]),
+    .qs(periph_insel3_in19_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel4_in20(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel4_in20_we & regen_qs),
+    .wd(periph_insel4_in20_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[594-:6]),
+    .qs(periph_insel4_in20_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel4_in21(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel4_in21_we & regen_qs),
+    .wd(periph_insel4_in21_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[600-:6]),
+    .qs(periph_insel4_in21_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel4_in22(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel4_in22_we & regen_qs),
+    .wd(periph_insel4_in22_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[606-:6]),
+    .qs(periph_insel4_in22_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel4_in23(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel4_in23_we & regen_qs),
+    .wd(periph_insel4_in23_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[612-:6]),
+    .qs(periph_insel4_in23_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel4_in24(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel4_in24_we & regen_qs),
+    .wd(periph_insel4_in24_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[618-:6]),
+    .qs(periph_insel4_in24_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel5_in25(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel5_in25_we & regen_qs),
+    .wd(periph_insel5_in25_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[624-:6]),
+    .qs(periph_insel5_in25_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel5_in26(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel5_in26_we & regen_qs),
+    .wd(periph_insel5_in26_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[630-:6]),
+    .qs(periph_insel5_in26_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel5_in27(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel5_in27_we & regen_qs),
+    .wd(periph_insel5_in27_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[636-:6]),
+    .qs(periph_insel5_in27_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel5_in28(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel5_in28_we & regen_qs),
+    .wd(periph_insel5_in28_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[642-:6]),
+    .qs(periph_insel5_in28_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel5_in29(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel5_in29_we & regen_qs),
+    .wd(periph_insel5_in29_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[648-:6]),
+    .qs(periph_insel5_in29_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel6_in30(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel6_in30_we & regen_qs),
+    .wd(periph_insel6_in30_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[654-:6]),
+    .qs(periph_insel6_in30_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h00)
+  ) u_periph_insel6_in31(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(periph_insel6_in31_we & regen_qs),
+    .wd(periph_insel6_in31_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[660-:6]),
+    .qs(periph_insel6_in31_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel0_out0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel0_out0_we & regen_qs),
+    .wd(mio_outsel0_out0_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[282-:6]),
+    .qs(mio_outsel0_out0_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel0_out1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel0_out1_we & regen_qs),
+    .wd(mio_outsel0_out1_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[288-:6]),
+    .qs(mio_outsel0_out1_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel0_out2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel0_out2_we & regen_qs),
+    .wd(mio_outsel0_out2_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[294-:6]),
+    .qs(mio_outsel0_out2_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel0_out3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel0_out3_we & regen_qs),
+    .wd(mio_outsel0_out3_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[300-:6]),
+    .qs(mio_outsel0_out3_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel0_out4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel0_out4_we & regen_qs),
+    .wd(mio_outsel0_out4_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[306-:6]),
+    .qs(mio_outsel0_out4_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel1_out5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel1_out5_we & regen_qs),
+    .wd(mio_outsel1_out5_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[312-:6]),
+    .qs(mio_outsel1_out5_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel1_out6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel1_out6_we & regen_qs),
+    .wd(mio_outsel1_out6_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[318-:6]),
+    .qs(mio_outsel1_out6_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel1_out7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel1_out7_we & regen_qs),
+    .wd(mio_outsel1_out7_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[324-:6]),
+    .qs(mio_outsel1_out7_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel1_out8(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel1_out8_we & regen_qs),
+    .wd(mio_outsel1_out8_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[330-:6]),
+    .qs(mio_outsel1_out8_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel1_out9(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel1_out9_we & regen_qs),
+    .wd(mio_outsel1_out9_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[336-:6]),
+    .qs(mio_outsel1_out9_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel2_out10(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel2_out10_we & regen_qs),
+    .wd(mio_outsel2_out10_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[342-:6]),
+    .qs(mio_outsel2_out10_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel2_out11(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel2_out11_we & regen_qs),
+    .wd(mio_outsel2_out11_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[348-:6]),
+    .qs(mio_outsel2_out11_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel2_out12(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel2_out12_we & regen_qs),
+    .wd(mio_outsel2_out12_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[354-:6]),
+    .qs(mio_outsel2_out12_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel2_out13(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel2_out13_we & regen_qs),
+    .wd(mio_outsel2_out13_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[360-:6]),
+    .qs(mio_outsel2_out13_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel2_out14(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel2_out14_we & regen_qs),
+    .wd(mio_outsel2_out14_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[366-:6]),
+    .qs(mio_outsel2_out14_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel3_out15(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel3_out15_we & regen_qs),
+    .wd(mio_outsel3_out15_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[372-:6]),
+    .qs(mio_outsel3_out15_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel3_out16(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel3_out16_we & regen_qs),
+    .wd(mio_outsel3_out16_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[378-:6]),
+    .qs(mio_outsel3_out16_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel3_out17(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel3_out17_we & regen_qs),
+    .wd(mio_outsel3_out17_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[384-:6]),
+    .qs(mio_outsel3_out17_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel3_out18(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel3_out18_we & regen_qs),
+    .wd(mio_outsel3_out18_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[390-:6]),
+    .qs(mio_outsel3_out18_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel3_out19(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel3_out19_we & regen_qs),
+    .wd(mio_outsel3_out19_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[396-:6]),
+    .qs(mio_outsel3_out19_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel4_out20(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel4_out20_we & regen_qs),
+    .wd(mio_outsel4_out20_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[402-:6]),
+    .qs(mio_outsel4_out20_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel4_out21(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel4_out21_we & regen_qs),
+    .wd(mio_outsel4_out21_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[408-:6]),
+    .qs(mio_outsel4_out21_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel4_out22(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel4_out22_we & regen_qs),
+    .wd(mio_outsel4_out22_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[414-:6]),
+    .qs(mio_outsel4_out22_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel4_out23(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel4_out23_we & regen_qs),
+    .wd(mio_outsel4_out23_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[420-:6]),
+    .qs(mio_outsel4_out23_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel4_out24(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel4_out24_we & regen_qs),
+    .wd(mio_outsel4_out24_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[426-:6]),
+    .qs(mio_outsel4_out24_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel5_out25(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel5_out25_we & regen_qs),
+    .wd(mio_outsel5_out25_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[432-:6]),
+    .qs(mio_outsel5_out25_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel5_out26(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel5_out26_we & regen_qs),
+    .wd(mio_outsel5_out26_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[438-:6]),
+    .qs(mio_outsel5_out26_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel5_out27(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel5_out27_we & regen_qs),
+    .wd(mio_outsel5_out27_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[444-:6]),
+    .qs(mio_outsel5_out27_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel5_out28(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel5_out28_we & regen_qs),
+    .wd(mio_outsel5_out28_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[450-:6]),
+    .qs(mio_outsel5_out28_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel5_out29(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel5_out29_we & regen_qs),
+    .wd(mio_outsel5_out29_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[456-:6]),
+    .qs(mio_outsel5_out29_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel6_out30(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel6_out30_we & regen_qs),
+    .wd(mio_outsel6_out30_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[462-:6]),
+    .qs(mio_outsel6_out30_qs)
+  );
+  prim_subreg #(
+    .DW(6),
+    .SWACCESS("RW"),
+    .RESVAL(6'h02)
+  ) u_mio_outsel6_out31(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_outsel6_out31_we & regen_qs),
+    .wd(mio_outsel6_out31_wd),
+    .de(1'b0),
+    .d({6 {1'b0}}),
+    .qe(),
+    .q(reg2hw[468-:6]),
+    .qs(mio_outsel6_out31_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out0_we & regen_qs),
+    .wd(mio_out_sleep_val0_out0_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[214-:2]),
+    .qs(mio_out_sleep_val0_out0_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out1_we & regen_qs),
+    .wd(mio_out_sleep_val0_out1_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[216-:2]),
+    .qs(mio_out_sleep_val0_out1_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out2_we & regen_qs),
+    .wd(mio_out_sleep_val0_out2_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[218-:2]),
+    .qs(mio_out_sleep_val0_out2_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out3_we & regen_qs),
+    .wd(mio_out_sleep_val0_out3_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[220-:2]),
+    .qs(mio_out_sleep_val0_out3_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out4_we & regen_qs),
+    .wd(mio_out_sleep_val0_out4_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[222-:2]),
+    .qs(mio_out_sleep_val0_out4_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out5_we & regen_qs),
+    .wd(mio_out_sleep_val0_out5_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[224-:2]),
+    .qs(mio_out_sleep_val0_out5_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out6_we & regen_qs),
+    .wd(mio_out_sleep_val0_out6_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[226-:2]),
+    .qs(mio_out_sleep_val0_out6_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out7_we & regen_qs),
+    .wd(mio_out_sleep_val0_out7_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[228-:2]),
+    .qs(mio_out_sleep_val0_out7_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out8(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out8_we & regen_qs),
+    .wd(mio_out_sleep_val0_out8_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[230-:2]),
+    .qs(mio_out_sleep_val0_out8_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out9(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out9_we & regen_qs),
+    .wd(mio_out_sleep_val0_out9_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[232-:2]),
+    .qs(mio_out_sleep_val0_out9_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out10(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out10_we & regen_qs),
+    .wd(mio_out_sleep_val0_out10_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[234-:2]),
+    .qs(mio_out_sleep_val0_out10_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out11(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out11_we & regen_qs),
+    .wd(mio_out_sleep_val0_out11_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[236-:2]),
+    .qs(mio_out_sleep_val0_out11_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out12(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out12_we & regen_qs),
+    .wd(mio_out_sleep_val0_out12_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[238-:2]),
+    .qs(mio_out_sleep_val0_out12_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out13(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out13_we & regen_qs),
+    .wd(mio_out_sleep_val0_out13_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[240-:2]),
+    .qs(mio_out_sleep_val0_out13_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out14(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out14_we & regen_qs),
+    .wd(mio_out_sleep_val0_out14_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[242-:2]),
+    .qs(mio_out_sleep_val0_out14_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val0_out15(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val0_out15_we & regen_qs),
+    .wd(mio_out_sleep_val0_out15_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[244-:2]),
+    .qs(mio_out_sleep_val0_out15_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out16(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out16_we & regen_qs),
+    .wd(mio_out_sleep_val1_out16_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[246-:2]),
+    .qs(mio_out_sleep_val1_out16_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out17(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out17_we & regen_qs),
+    .wd(mio_out_sleep_val1_out17_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[248-:2]),
+    .qs(mio_out_sleep_val1_out17_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out18(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out18_we & regen_qs),
+    .wd(mio_out_sleep_val1_out18_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[250-:2]),
+    .qs(mio_out_sleep_val1_out18_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out19(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out19_we & regen_qs),
+    .wd(mio_out_sleep_val1_out19_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[252-:2]),
+    .qs(mio_out_sleep_val1_out19_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out20(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out20_we & regen_qs),
+    .wd(mio_out_sleep_val1_out20_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[254-:2]),
+    .qs(mio_out_sleep_val1_out20_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out21(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out21_we & regen_qs),
+    .wd(mio_out_sleep_val1_out21_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[256-:2]),
+    .qs(mio_out_sleep_val1_out21_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out22(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out22_we & regen_qs),
+    .wd(mio_out_sleep_val1_out22_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[258-:2]),
+    .qs(mio_out_sleep_val1_out22_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out23(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out23_we & regen_qs),
+    .wd(mio_out_sleep_val1_out23_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[260-:2]),
+    .qs(mio_out_sleep_val1_out23_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out24(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out24_we & regen_qs),
+    .wd(mio_out_sleep_val1_out24_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[262-:2]),
+    .qs(mio_out_sleep_val1_out24_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out25(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out25_we & regen_qs),
+    .wd(mio_out_sleep_val1_out25_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[264-:2]),
+    .qs(mio_out_sleep_val1_out25_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out26(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out26_we & regen_qs),
+    .wd(mio_out_sleep_val1_out26_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[266-:2]),
+    .qs(mio_out_sleep_val1_out26_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out27(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out27_we & regen_qs),
+    .wd(mio_out_sleep_val1_out27_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[268-:2]),
+    .qs(mio_out_sleep_val1_out27_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out28(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out28_we & regen_qs),
+    .wd(mio_out_sleep_val1_out28_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[270-:2]),
+    .qs(mio_out_sleep_val1_out28_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out29(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out29_we & regen_qs),
+    .wd(mio_out_sleep_val1_out29_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[272-:2]),
+    .qs(mio_out_sleep_val1_out29_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out30(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out30_we & regen_qs),
+    .wd(mio_out_sleep_val1_out30_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[274-:2]),
+    .qs(mio_out_sleep_val1_out30_qs)
+  );
+  prim_subreg #(
+    .DW(2),
+    .SWACCESS("RW"),
+    .RESVAL(2'h2)
+  ) u_mio_out_sleep_val1_out31(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(mio_out_sleep_val1_out31_we & regen_qs),
+    .wd(mio_out_sleep_val1_out31_wd),
+    .de(1'b0),
+    .d({2 {1'b0}}),
+    .qe(),
+    .q(reg2hw[276-:2]),
+    .qs(mio_out_sleep_val1_out31_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out0(
+    .re(dio_out_sleep_val_out0_re),
+    .we(dio_out_sleep_val_out0_we & regen_qs),
+    .wd(dio_out_sleep_val_out0_wd),
+    .d(hw2reg[9-:2]),
+    .qre(),
+    .qe(reg2hw[168]),
+    .q(reg2hw[170-:2]),
+    .qs(dio_out_sleep_val_out0_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out1(
+    .re(dio_out_sleep_val_out1_re),
+    .we(dio_out_sleep_val_out1_we & regen_qs),
+    .wd(dio_out_sleep_val_out1_wd),
+    .d(hw2reg[11-:2]),
+    .qre(),
+    .qe(reg2hw[171]),
+    .q(reg2hw[173-:2]),
+    .qs(dio_out_sleep_val_out1_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out2(
+    .re(dio_out_sleep_val_out2_re),
+    .we(dio_out_sleep_val_out2_we & regen_qs),
+    .wd(dio_out_sleep_val_out2_wd),
+    .d(hw2reg[13-:2]),
+    .qre(),
+    .qe(reg2hw[174]),
+    .q(reg2hw[176-:2]),
+    .qs(dio_out_sleep_val_out2_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out3(
+    .re(dio_out_sleep_val_out3_re),
+    .we(dio_out_sleep_val_out3_we & regen_qs),
+    .wd(dio_out_sleep_val_out3_wd),
+    .d(hw2reg[15-:2]),
+    .qre(),
+    .qe(reg2hw[177]),
+    .q(reg2hw[179-:2]),
+    .qs(dio_out_sleep_val_out3_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out4(
+    .re(dio_out_sleep_val_out4_re),
+    .we(dio_out_sleep_val_out4_we & regen_qs),
+    .wd(dio_out_sleep_val_out4_wd),
+    .d(hw2reg[17-:2]),
+    .qre(),
+    .qe(reg2hw[180]),
+    .q(reg2hw[182-:2]),
+    .qs(dio_out_sleep_val_out4_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out5(
+    .re(dio_out_sleep_val_out5_re),
+    .we(dio_out_sleep_val_out5_we & regen_qs),
+    .wd(dio_out_sleep_val_out5_wd),
+    .d(hw2reg[19-:2]),
+    .qre(),
+    .qe(reg2hw[183]),
+    .q(reg2hw[185-:2]),
+    .qs(dio_out_sleep_val_out5_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out6(
+    .re(dio_out_sleep_val_out6_re),
+    .we(dio_out_sleep_val_out6_we & regen_qs),
+    .wd(dio_out_sleep_val_out6_wd),
+    .d(hw2reg[21-:2]),
+    .qre(),
+    .qe(reg2hw[186]),
+    .q(reg2hw[188-:2]),
+    .qs(dio_out_sleep_val_out6_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out7(
+    .re(dio_out_sleep_val_out7_re),
+    .we(dio_out_sleep_val_out7_we & regen_qs),
+    .wd(dio_out_sleep_val_out7_wd),
+    .d(hw2reg[23-:2]),
+    .qre(),
+    .qe(reg2hw[189]),
+    .q(reg2hw[191-:2]),
+    .qs(dio_out_sleep_val_out7_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out8(
+    .re(dio_out_sleep_val_out8_re),
+    .we(dio_out_sleep_val_out8_we & regen_qs),
+    .wd(dio_out_sleep_val_out8_wd),
+    .d(hw2reg[25-:2]),
+    .qre(),
+    .qe(reg2hw[192]),
+    .q(reg2hw[194-:2]),
+    .qs(dio_out_sleep_val_out8_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out9(
+    .re(dio_out_sleep_val_out9_re),
+    .we(dio_out_sleep_val_out9_we & regen_qs),
+    .wd(dio_out_sleep_val_out9_wd),
+    .d(hw2reg[27-:2]),
+    .qre(),
+    .qe(reg2hw[195]),
+    .q(reg2hw[197-:2]),
+    .qs(dio_out_sleep_val_out9_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out10(
+    .re(dio_out_sleep_val_out10_re),
+    .we(dio_out_sleep_val_out10_we & regen_qs),
+    .wd(dio_out_sleep_val_out10_wd),
+    .d(hw2reg[29-:2]),
+    .qre(),
+    .qe(reg2hw[198]),
+    .q(reg2hw[200-:2]),
+    .qs(dio_out_sleep_val_out10_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out11(
+    .re(dio_out_sleep_val_out11_re),
+    .we(dio_out_sleep_val_out11_we & regen_qs),
+    .wd(dio_out_sleep_val_out11_wd),
+    .d(hw2reg[31-:2]),
+    .qre(),
+    .qe(reg2hw[201]),
+    .q(reg2hw[203-:2]),
+    .qs(dio_out_sleep_val_out11_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out12(
+    .re(dio_out_sleep_val_out12_re),
+    .we(dio_out_sleep_val_out12_we & regen_qs),
+    .wd(dio_out_sleep_val_out12_wd),
+    .d(hw2reg[33-:2]),
+    .qre(),
+    .qe(reg2hw[204]),
+    .q(reg2hw[206-:2]),
+    .qs(dio_out_sleep_val_out12_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out13(
+    .re(dio_out_sleep_val_out13_re),
+    .we(dio_out_sleep_val_out13_we & regen_qs),
+    .wd(dio_out_sleep_val_out13_wd),
+    .d(hw2reg[35-:2]),
+    .qre(),
+    .qe(reg2hw[207]),
+    .q(reg2hw[209-:2]),
+    .qs(dio_out_sleep_val_out13_qs)
+  );
+  prim_subreg_ext #(.DW(2)) u_dio_out_sleep_val_out14(
+    .re(dio_out_sleep_val_out14_re),
+    .we(dio_out_sleep_val_out14_we & regen_qs),
+    .wd(dio_out_sleep_val_out14_wd),
+    .d(hw2reg[37-:2]),
+    .qre(),
+    .qe(reg2hw[210]),
+    .q(reg2hw[212-:2]),
+    .qs(dio_out_sleep_val_out14_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en0_we & regen_qs),
+    .wd(wkup_detector_en_en0_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[160]),
+    .qs(wkup_detector_en_en0_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en1_we & regen_qs),
+    .wd(wkup_detector_en_en1_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[161]),
+    .qs(wkup_detector_en_en1_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en2_we & regen_qs),
+    .wd(wkup_detector_en_en2_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[162]),
+    .qs(wkup_detector_en_en2_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en3_we & regen_qs),
+    .wd(wkup_detector_en_en3_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[163]),
+    .qs(wkup_detector_en_en3_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en4_we & regen_qs),
+    .wd(wkup_detector_en_en4_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[164]),
+    .qs(wkup_detector_en_en4_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en5_we & regen_qs),
+    .wd(wkup_detector_en_en5_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[165]),
+    .qs(wkup_detector_en_en5_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en6_we & regen_qs),
+    .wd(wkup_detector_en_en6_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[166]),
+    .qs(wkup_detector_en_en6_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector_en_en7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_en_en7_we & regen_qs),
+    .wd(wkup_detector_en_en7_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[167]),
+    .qs(wkup_detector_en_en7_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector0_mode0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector0_mode0_we & regen_qs),
+    .wd(wkup_detector0_mode0_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[124-:3]),
+    .qs(wkup_detector0_mode0_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector0_filter0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector0_filter0_we & regen_qs),
+    .wd(wkup_detector0_filter0_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[121]),
+    .qs(wkup_detector0_filter0_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector0_miodio0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector0_miodio0_we & regen_qs),
+    .wd(wkup_detector0_miodio0_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[120]),
+    .qs(wkup_detector0_miodio0_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector1_mode1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector1_mode1_we & regen_qs),
+    .wd(wkup_detector1_mode1_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[129-:3]),
+    .qs(wkup_detector1_mode1_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector1_filter1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector1_filter1_we & regen_qs),
+    .wd(wkup_detector1_filter1_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[126]),
+    .qs(wkup_detector1_filter1_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector1_miodio1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector1_miodio1_we & regen_qs),
+    .wd(wkup_detector1_miodio1_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[125]),
+    .qs(wkup_detector1_miodio1_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector2_mode2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector2_mode2_we & regen_qs),
+    .wd(wkup_detector2_mode2_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[134-:3]),
+    .qs(wkup_detector2_mode2_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector2_filter2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector2_filter2_we & regen_qs),
+    .wd(wkup_detector2_filter2_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[131]),
+    .qs(wkup_detector2_filter2_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector2_miodio2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector2_miodio2_we & regen_qs),
+    .wd(wkup_detector2_miodio2_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[130]),
+    .qs(wkup_detector2_miodio2_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector3_mode3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector3_mode3_we & regen_qs),
+    .wd(wkup_detector3_mode3_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[139-:3]),
+    .qs(wkup_detector3_mode3_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector3_filter3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector3_filter3_we & regen_qs),
+    .wd(wkup_detector3_filter3_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[136]),
+    .qs(wkup_detector3_filter3_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector3_miodio3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector3_miodio3_we & regen_qs),
+    .wd(wkup_detector3_miodio3_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[135]),
+    .qs(wkup_detector3_miodio3_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector4_mode4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector4_mode4_we & regen_qs),
+    .wd(wkup_detector4_mode4_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[144-:3]),
+    .qs(wkup_detector4_mode4_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector4_filter4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector4_filter4_we & regen_qs),
+    .wd(wkup_detector4_filter4_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[141]),
+    .qs(wkup_detector4_filter4_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector4_miodio4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector4_miodio4_we & regen_qs),
+    .wd(wkup_detector4_miodio4_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[140]),
+    .qs(wkup_detector4_miodio4_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector5_mode5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector5_mode5_we & regen_qs),
+    .wd(wkup_detector5_mode5_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[149-:3]),
+    .qs(wkup_detector5_mode5_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector5_filter5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector5_filter5_we & regen_qs),
+    .wd(wkup_detector5_filter5_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[146]),
+    .qs(wkup_detector5_filter5_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector5_miodio5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector5_miodio5_we & regen_qs),
+    .wd(wkup_detector5_miodio5_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[145]),
+    .qs(wkup_detector5_miodio5_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector6_mode6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector6_mode6_we & regen_qs),
+    .wd(wkup_detector6_mode6_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[154-:3]),
+    .qs(wkup_detector6_mode6_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector6_filter6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector6_filter6_we & regen_qs),
+    .wd(wkup_detector6_filter6_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[151]),
+    .qs(wkup_detector6_filter6_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector6_miodio6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector6_miodio6_we & regen_qs),
+    .wd(wkup_detector6_miodio6_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[150]),
+    .qs(wkup_detector6_miodio6_qs)
+  );
+  prim_subreg #(
+    .DW(3),
+    .SWACCESS("RW"),
+    .RESVAL(3'h0)
+  ) u_wkup_detector7_mode7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector7_mode7_we & regen_qs),
+    .wd(wkup_detector7_mode7_wd),
+    .de(1'b0),
+    .d({3 {1'b0}}),
+    .qe(),
+    .q(reg2hw[159-:3]),
+    .qs(wkup_detector7_mode7_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector7_filter7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector7_filter7_we & regen_qs),
+    .wd(wkup_detector7_filter7_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[156]),
+    .qs(wkup_detector7_filter7_qs)
+  );
+  prim_subreg #(
+    .DW(1),
+    .SWACCESS("RW"),
+    .RESVAL(1'h0)
+  ) u_wkup_detector7_miodio7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector7_miodio7_we & regen_qs),
+    .wd(wkup_detector7_miodio7_wd),
+    .de(1'b0),
+    .d(1'b0),
+    .qe(),
+    .q(reg2hw[155]),
+    .qs(wkup_detector7_miodio7_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th0_th0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th0_th0_we & regen_qs),
+    .wd(wkup_detector_cnt_th0_th0_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[63-:8]),
+    .qs(wkup_detector_cnt_th0_th0_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th0_th1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th0_th1_we & regen_qs),
+    .wd(wkup_detector_cnt_th0_th1_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[71-:8]),
+    .qs(wkup_detector_cnt_th0_th1_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th0_th2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th0_th2_we & regen_qs),
+    .wd(wkup_detector_cnt_th0_th2_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[79-:8]),
+    .qs(wkup_detector_cnt_th0_th2_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th0_th3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th0_th3_we & regen_qs),
+    .wd(wkup_detector_cnt_th0_th3_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[87-:8]),
+    .qs(wkup_detector_cnt_th0_th3_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th1_th4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th1_th4_we & regen_qs),
+    .wd(wkup_detector_cnt_th1_th4_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[95-:8]),
+    .qs(wkup_detector_cnt_th1_th4_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th1_th5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th1_th5_we & regen_qs),
+    .wd(wkup_detector_cnt_th1_th5_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[103-:8]),
+    .qs(wkup_detector_cnt_th1_th5_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th1_th6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th1_th6_we & regen_qs),
+    .wd(wkup_detector_cnt_th1_th6_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[111-:8]),
+    .qs(wkup_detector_cnt_th1_th6_qs)
+  );
+  prim_subreg #(
+    .DW(8),
+    .SWACCESS("RW"),
+    .RESVAL(8'h00)
+  ) u_wkup_detector_cnt_th1_th7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_cnt_th1_th7_we & regen_qs),
+    .wd(wkup_detector_cnt_th1_th7_wd),
+    .de(1'b0),
+    .d({8 {1'b0}}),
+    .qe(),
+    .q(reg2hw[119-:8]),
+    .qs(wkup_detector_cnt_th1_th7_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel0(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel0_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel0_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[20-:5]),
+    .qs(wkup_detector_padsel0_sel0_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel1(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel1_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel1_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[25-:5]),
+    .qs(wkup_detector_padsel0_sel1_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel2(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel2_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel2_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[30-:5]),
+    .qs(wkup_detector_padsel0_sel2_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel3(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel3_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel3_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[35-:5]),
+    .qs(wkup_detector_padsel0_sel3_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel4(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel4_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel4_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[40-:5]),
+    .qs(wkup_detector_padsel0_sel4_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel0_sel5(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel0_sel5_we & regen_qs),
+    .wd(wkup_detector_padsel0_sel5_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[45-:5]),
+    .qs(wkup_detector_padsel0_sel5_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel1_sel6(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel1_sel6_we & regen_qs),
+    .wd(wkup_detector_padsel1_sel6_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[50-:5]),
+    .qs(wkup_detector_padsel1_sel6_qs)
+  );
+  prim_subreg #(
+    .DW(5),
+    .SWACCESS("RW"),
+    .RESVAL(5'h00)
+  ) u_wkup_detector_padsel1_sel7(
+    .clk_i(clk_i),
+    .rst_ni(rst_ni),
+    .we(wkup_detector_padsel1_sel7_we & regen_qs),
+    .wd(wkup_detector_padsel1_sel7_wd),
+    .de(1'b0),
+    .d({5 {1'b0}}),
+    .qe(),
+    .q(reg2hw[55-:5]),
+    .qs(wkup_detector_padsel1_sel7_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause0(
+    .re(wkup_cause_cause0_re),
+    .we(wkup_cause_cause0_we & regen_qs),
+    .wd(wkup_cause_cause0_wd),
+    .d(hw2reg[0]),
+    .qre(),
+    .qe(reg2hw[0]),
+    .q(reg2hw[1]),
+    .qs(wkup_cause_cause0_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause1(
+    .re(wkup_cause_cause1_re),
+    .we(wkup_cause_cause1_we & regen_qs),
+    .wd(wkup_cause_cause1_wd),
+    .d(hw2reg[1]),
+    .qre(),
+    .qe(reg2hw[2]),
+    .q(reg2hw[3]),
+    .qs(wkup_cause_cause1_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause2(
+    .re(wkup_cause_cause2_re),
+    .we(wkup_cause_cause2_we & regen_qs),
+    .wd(wkup_cause_cause2_wd),
+    .d(hw2reg[2]),
+    .qre(),
+    .qe(reg2hw[4]),
+    .q(reg2hw[5]),
+    .qs(wkup_cause_cause2_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause3(
+    .re(wkup_cause_cause3_re),
+    .we(wkup_cause_cause3_we & regen_qs),
+    .wd(wkup_cause_cause3_wd),
+    .d(hw2reg[3]),
+    .qre(),
+    .qe(reg2hw[6]),
+    .q(reg2hw[7]),
+    .qs(wkup_cause_cause3_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause4(
+    .re(wkup_cause_cause4_re),
+    .we(wkup_cause_cause4_we & regen_qs),
+    .wd(wkup_cause_cause4_wd),
+    .d(hw2reg[4]),
+    .qre(),
+    .qe(reg2hw[8]),
+    .q(reg2hw[9]),
+    .qs(wkup_cause_cause4_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause5(
+    .re(wkup_cause_cause5_re),
+    .we(wkup_cause_cause5_we & regen_qs),
+    .wd(wkup_cause_cause5_wd),
+    .d(hw2reg[5]),
+    .qre(),
+    .qe(reg2hw[10]),
+    .q(reg2hw[11]),
+    .qs(wkup_cause_cause5_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause6(
+    .re(wkup_cause_cause6_re),
+    .we(wkup_cause_cause6_we & regen_qs),
+    .wd(wkup_cause_cause6_wd),
+    .d(hw2reg[6]),
+    .qre(),
+    .qe(reg2hw[12]),
+    .q(reg2hw[13]),
+    .qs(wkup_cause_cause6_qs)
+  );
+  prim_subreg_ext #(.DW(1)) u_wkup_cause_cause7(
+    .re(wkup_cause_cause7_re),
+    .we(wkup_cause_cause7_we & regen_qs),
+    .wd(wkup_cause_cause7_wd),
+    .d(hw2reg[7]),
+    .qre(),
+    .qe(reg2hw[14]),
+    .q(reg2hw[15]),
+    .qs(wkup_cause_cause7_qs)
   );
 
-
-  // F[in26]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel5_in26 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel5_in26_we & regen_qs),
-    .wd     (periph_insel5_in26_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[26].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel5_in26_qs)
-  );
-
-
-  // F[in27]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel5_in27 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel5_in27_we & regen_qs),
-    .wd     (periph_insel5_in27_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[27].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel5_in27_qs)
-  );
-
-
-  // F[in28]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel5_in28 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel5_in28_we & regen_qs),
-    .wd     (periph_insel5_in28_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[28].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel5_in28_qs)
-  );
-
-
-  // F[in29]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel5_in29 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel5_in29_we & regen_qs),
-    .wd     (periph_insel5_in29_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[29].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel5_in29_qs)
-  );
-
-
-  // Subregister 30 of Multireg periph_insel
-  // R[periph_insel6]: V(False)
-
-  // F[in30]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel6_in30 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel6_in30_we & regen_qs),
-    .wd     (periph_insel6_in30_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[30].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel6_in30_qs)
-  );
-
-
-  // F[in31]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h0)
-  ) u_periph_insel6_in31 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (periph_insel6_in31_we & regen_qs),
-    .wd     (periph_insel6_in31_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.periph_insel[31].q ),
-
-    // to register interface (read)
-    .qs     (periph_insel6_in31_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg mio_outsel
-  // R[mio_outsel0]: V(False)
-
-  // F[out0]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel0_out0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel0_out0_we & regen_qs),
-    .wd     (mio_outsel0_out0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[0].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel0_out0_qs)
-  );
-
-
-  // F[out1]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel0_out1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel0_out1_we & regen_qs),
-    .wd     (mio_outsel0_out1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[1].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel0_out1_qs)
-  );
-
-
-  // F[out2]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel0_out2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel0_out2_we & regen_qs),
-    .wd     (mio_outsel0_out2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[2].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel0_out2_qs)
-  );
-
-
-  // F[out3]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel0_out3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel0_out3_we & regen_qs),
-    .wd     (mio_outsel0_out3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[3].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel0_out3_qs)
-  );
-
-
-  // F[out4]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel0_out4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel0_out4_we & regen_qs),
-    .wd     (mio_outsel0_out4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[4].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel0_out4_qs)
-  );
-
-
-  // Subregister 5 of Multireg mio_outsel
-  // R[mio_outsel1]: V(False)
-
-  // F[out5]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel1_out5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel1_out5_we & regen_qs),
-    .wd     (mio_outsel1_out5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[5].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel1_out5_qs)
-  );
-
-
-  // F[out6]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel1_out6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel1_out6_we & regen_qs),
-    .wd     (mio_outsel1_out6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[6].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel1_out6_qs)
-  );
-
-
-  // F[out7]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel1_out7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel1_out7_we & regen_qs),
-    .wd     (mio_outsel1_out7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[7].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel1_out7_qs)
-  );
-
-
-  // F[out8]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel1_out8 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel1_out8_we & regen_qs),
-    .wd     (mio_outsel1_out8_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[8].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel1_out8_qs)
-  );
-
-
-  // F[out9]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel1_out9 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel1_out9_we & regen_qs),
-    .wd     (mio_outsel1_out9_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[9].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel1_out9_qs)
-  );
-
-
-  // Subregister 10 of Multireg mio_outsel
-  // R[mio_outsel2]: V(False)
-
-  // F[out10]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel2_out10 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel2_out10_we & regen_qs),
-    .wd     (mio_outsel2_out10_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[10].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel2_out10_qs)
-  );
-
-
-  // F[out11]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel2_out11 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel2_out11_we & regen_qs),
-    .wd     (mio_outsel2_out11_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[11].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel2_out11_qs)
-  );
-
-
-  // F[out12]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel2_out12 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel2_out12_we & regen_qs),
-    .wd     (mio_outsel2_out12_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[12].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel2_out12_qs)
-  );
-
-
-  // F[out13]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel2_out13 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel2_out13_we & regen_qs),
-    .wd     (mio_outsel2_out13_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[13].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel2_out13_qs)
-  );
-
-
-  // F[out14]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel2_out14 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel2_out14_we & regen_qs),
-    .wd     (mio_outsel2_out14_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[14].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel2_out14_qs)
-  );
-
-
-  // Subregister 15 of Multireg mio_outsel
-  // R[mio_outsel3]: V(False)
-
-  // F[out15]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel3_out15 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel3_out15_we & regen_qs),
-    .wd     (mio_outsel3_out15_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[15].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel3_out15_qs)
-  );
-
-
-  // F[out16]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel3_out16 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel3_out16_we & regen_qs),
-    .wd     (mio_outsel3_out16_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[16].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel3_out16_qs)
-  );
-
-
-  // F[out17]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel3_out17 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel3_out17_we & regen_qs),
-    .wd     (mio_outsel3_out17_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[17].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel3_out17_qs)
-  );
-
-
-  // F[out18]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel3_out18 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel3_out18_we & regen_qs),
-    .wd     (mio_outsel3_out18_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[18].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel3_out18_qs)
-  );
-
-
-  // F[out19]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel3_out19 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel3_out19_we & regen_qs),
-    .wd     (mio_outsel3_out19_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[19].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel3_out19_qs)
-  );
-
-
-  // Subregister 20 of Multireg mio_outsel
-  // R[mio_outsel4]: V(False)
-
-  // F[out20]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel4_out20 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel4_out20_we & regen_qs),
-    .wd     (mio_outsel4_out20_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[20].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel4_out20_qs)
-  );
-
-
-  // F[out21]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel4_out21 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel4_out21_we & regen_qs),
-    .wd     (mio_outsel4_out21_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[21].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel4_out21_qs)
-  );
-
-
-  // F[out22]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel4_out22 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel4_out22_we & regen_qs),
-    .wd     (mio_outsel4_out22_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[22].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel4_out22_qs)
-  );
-
-
-  // F[out23]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel4_out23 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel4_out23_we & regen_qs),
-    .wd     (mio_outsel4_out23_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[23].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel4_out23_qs)
-  );
-
-
-  // F[out24]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel4_out24 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel4_out24_we & regen_qs),
-    .wd     (mio_outsel4_out24_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[24].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel4_out24_qs)
-  );
-
-
-  // Subregister 25 of Multireg mio_outsel
-  // R[mio_outsel5]: V(False)
-
-  // F[out25]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel5_out25 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel5_out25_we & regen_qs),
-    .wd     (mio_outsel5_out25_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[25].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel5_out25_qs)
-  );
-
-
-  // F[out26]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel5_out26 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel5_out26_we & regen_qs),
-    .wd     (mio_outsel5_out26_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[26].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel5_out26_qs)
-  );
-
-
-  // F[out27]: 17:12
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel5_out27 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel5_out27_we & regen_qs),
-    .wd     (mio_outsel5_out27_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[27].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel5_out27_qs)
-  );
-
-
-  // F[out28]: 23:18
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel5_out28 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel5_out28_we & regen_qs),
-    .wd     (mio_outsel5_out28_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[28].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel5_out28_qs)
-  );
-
-
-  // F[out29]: 29:24
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel5_out29 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel5_out29_we & regen_qs),
-    .wd     (mio_outsel5_out29_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[29].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel5_out29_qs)
-  );
-
-
-  // Subregister 30 of Multireg mio_outsel
-  // R[mio_outsel6]: V(False)
-
-  // F[out30]: 5:0
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel6_out30 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel6_out30_we & regen_qs),
-    .wd     (mio_outsel6_out30_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[30].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel6_out30_qs)
-  );
-
-
-  // F[out31]: 11:6
-  prim_subreg #(
-    .DW      (6),
-    .SWACCESS("RW"),
-    .RESVAL  (6'h2)
-  ) u_mio_outsel6_out31 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_outsel6_out31_we & regen_qs),
-    .wd     (mio_outsel6_out31_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_outsel[31].q ),
-
-    // to register interface (read)
-    .qs     (mio_outsel6_out31_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg mio_out_sleep_val
-  // R[mio_out_sleep_val0]: V(False)
-
-  // F[out0]: 1:0
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out0_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[0].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out0_qs)
-  );
-
-
-  // F[out1]: 3:2
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out1_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[1].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out1_qs)
-  );
-
-
-  // F[out2]: 5:4
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out2_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[2].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out2_qs)
-  );
-
-
-  // F[out3]: 7:6
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out3_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[3].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out3_qs)
-  );
-
-
-  // F[out4]: 9:8
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out4_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[4].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out4_qs)
-  );
-
-
-  // F[out5]: 11:10
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out5_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[5].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out5_qs)
-  );
-
-
-  // F[out6]: 13:12
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out6_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[6].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out6_qs)
-  );
-
-
-  // F[out7]: 15:14
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out7_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[7].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out7_qs)
-  );
-
-
-  // F[out8]: 17:16
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out8 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out8_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out8_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[8].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out8_qs)
-  );
-
-
-  // F[out9]: 19:18
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out9 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out9_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out9_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[9].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out9_qs)
-  );
-
-
-  // F[out10]: 21:20
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out10 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out10_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out10_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[10].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out10_qs)
-  );
-
-
-  // F[out11]: 23:22
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out11 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out11_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out11_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[11].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out11_qs)
-  );
-
-
-  // F[out12]: 25:24
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out12 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out12_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out12_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[12].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out12_qs)
-  );
-
-
-  // F[out13]: 27:26
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out13 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out13_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out13_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[13].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out13_qs)
-  );
-
-
-  // F[out14]: 29:28
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out14 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out14_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out14_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[14].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out14_qs)
-  );
-
-
-  // F[out15]: 31:30
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val0_out15 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val0_out15_we & regen_qs),
-    .wd     (mio_out_sleep_val0_out15_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[15].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val0_out15_qs)
-  );
-
-
-  // Subregister 16 of Multireg mio_out_sleep_val
-  // R[mio_out_sleep_val1]: V(False)
-
-  // F[out16]: 1:0
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out16 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out16_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out16_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[16].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out16_qs)
-  );
-
-
-  // F[out17]: 3:2
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out17 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out17_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out17_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[17].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out17_qs)
-  );
-
-
-  // F[out18]: 5:4
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out18 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out18_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out18_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[18].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out18_qs)
-  );
-
-
-  // F[out19]: 7:6
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out19 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out19_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out19_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[19].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out19_qs)
-  );
-
-
-  // F[out20]: 9:8
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out20 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out20_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out20_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[20].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out20_qs)
-  );
-
-
-  // F[out21]: 11:10
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out21 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out21_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out21_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[21].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out21_qs)
-  );
-
-
-  // F[out22]: 13:12
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out22 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out22_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out22_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[22].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out22_qs)
-  );
-
-
-  // F[out23]: 15:14
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out23 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out23_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out23_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[23].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out23_qs)
-  );
-
-
-  // F[out24]: 17:16
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out24 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out24_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out24_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[24].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out24_qs)
-  );
-
-
-  // F[out25]: 19:18
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out25 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out25_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out25_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[25].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out25_qs)
-  );
-
-
-  // F[out26]: 21:20
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out26 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out26_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out26_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[26].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out26_qs)
-  );
-
-
-  // F[out27]: 23:22
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out27 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out27_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out27_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[27].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out27_qs)
-  );
-
-
-  // F[out28]: 25:24
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out28 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out28_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out28_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[28].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out28_qs)
-  );
-
-
-  // F[out29]: 27:26
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out29 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out29_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out29_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[29].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out29_qs)
-  );
-
-
-  // F[out30]: 29:28
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out30 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out30_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out30_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[30].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out30_qs)
-  );
-
-
-  // F[out31]: 31:30
-  prim_subreg #(
-    .DW      (2),
-    .SWACCESS("RW"),
-    .RESVAL  (2'h2)
-  ) u_mio_out_sleep_val1_out31 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (mio_out_sleep_val1_out31_we & regen_qs),
-    .wd     (mio_out_sleep_val1_out31_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.mio_out_sleep_val[31].q ),
-
-    // to register interface (read)
-    .qs     (mio_out_sleep_val1_out31_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg dio_out_sleep_val
-  // R[dio_out_sleep_val]: V(True)
-
-  // F[out0]: 1:0
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out0 (
-    .re     (dio_out_sleep_val_out0_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out0_we & regen_qs),
-    .wd     (dio_out_sleep_val_out0_wd),
-    .d      (hw2reg.dio_out_sleep_val[0].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[0].qe),
-    .q      (reg2hw.dio_out_sleep_val[0].q ),
-    .qs     (dio_out_sleep_val_out0_qs)
-  );
-
-
-  // F[out1]: 3:2
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out1 (
-    .re     (dio_out_sleep_val_out1_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out1_we & regen_qs),
-    .wd     (dio_out_sleep_val_out1_wd),
-    .d      (hw2reg.dio_out_sleep_val[1].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[1].qe),
-    .q      (reg2hw.dio_out_sleep_val[1].q ),
-    .qs     (dio_out_sleep_val_out1_qs)
-  );
-
-
-  // F[out2]: 5:4
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out2 (
-    .re     (dio_out_sleep_val_out2_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out2_we & regen_qs),
-    .wd     (dio_out_sleep_val_out2_wd),
-    .d      (hw2reg.dio_out_sleep_val[2].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[2].qe),
-    .q      (reg2hw.dio_out_sleep_val[2].q ),
-    .qs     (dio_out_sleep_val_out2_qs)
-  );
-
-
-  // F[out3]: 7:6
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out3 (
-    .re     (dio_out_sleep_val_out3_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out3_we & regen_qs),
-    .wd     (dio_out_sleep_val_out3_wd),
-    .d      (hw2reg.dio_out_sleep_val[3].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[3].qe),
-    .q      (reg2hw.dio_out_sleep_val[3].q ),
-    .qs     (dio_out_sleep_val_out3_qs)
-  );
-
-
-  // F[out4]: 9:8
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out4 (
-    .re     (dio_out_sleep_val_out4_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out4_we & regen_qs),
-    .wd     (dio_out_sleep_val_out4_wd),
-    .d      (hw2reg.dio_out_sleep_val[4].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[4].qe),
-    .q      (reg2hw.dio_out_sleep_val[4].q ),
-    .qs     (dio_out_sleep_val_out4_qs)
-  );
-
-
-  // F[out5]: 11:10
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out5 (
-    .re     (dio_out_sleep_val_out5_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out5_we & regen_qs),
-    .wd     (dio_out_sleep_val_out5_wd),
-    .d      (hw2reg.dio_out_sleep_val[5].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[5].qe),
-    .q      (reg2hw.dio_out_sleep_val[5].q ),
-    .qs     (dio_out_sleep_val_out5_qs)
-  );
-
-
-  // F[out6]: 13:12
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out6 (
-    .re     (dio_out_sleep_val_out6_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out6_we & regen_qs),
-    .wd     (dio_out_sleep_val_out6_wd),
-    .d      (hw2reg.dio_out_sleep_val[6].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[6].qe),
-    .q      (reg2hw.dio_out_sleep_val[6].q ),
-    .qs     (dio_out_sleep_val_out6_qs)
-  );
-
-
-  // F[out7]: 15:14
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out7 (
-    .re     (dio_out_sleep_val_out7_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out7_we & regen_qs),
-    .wd     (dio_out_sleep_val_out7_wd),
-    .d      (hw2reg.dio_out_sleep_val[7].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[7].qe),
-    .q      (reg2hw.dio_out_sleep_val[7].q ),
-    .qs     (dio_out_sleep_val_out7_qs)
-  );
-
-
-  // F[out8]: 17:16
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out8 (
-    .re     (dio_out_sleep_val_out8_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out8_we & regen_qs),
-    .wd     (dio_out_sleep_val_out8_wd),
-    .d      (hw2reg.dio_out_sleep_val[8].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[8].qe),
-    .q      (reg2hw.dio_out_sleep_val[8].q ),
-    .qs     (dio_out_sleep_val_out8_qs)
-  );
-
-
-  // F[out9]: 19:18
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out9 (
-    .re     (dio_out_sleep_val_out9_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out9_we & regen_qs),
-    .wd     (dio_out_sleep_val_out9_wd),
-    .d      (hw2reg.dio_out_sleep_val[9].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[9].qe),
-    .q      (reg2hw.dio_out_sleep_val[9].q ),
-    .qs     (dio_out_sleep_val_out9_qs)
-  );
-
-
-  // F[out10]: 21:20
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out10 (
-    .re     (dio_out_sleep_val_out10_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out10_we & regen_qs),
-    .wd     (dio_out_sleep_val_out10_wd),
-    .d      (hw2reg.dio_out_sleep_val[10].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[10].qe),
-    .q      (reg2hw.dio_out_sleep_val[10].q ),
-    .qs     (dio_out_sleep_val_out10_qs)
-  );
-
-
-  // F[out11]: 23:22
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out11 (
-    .re     (dio_out_sleep_val_out11_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out11_we & regen_qs),
-    .wd     (dio_out_sleep_val_out11_wd),
-    .d      (hw2reg.dio_out_sleep_val[11].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[11].qe),
-    .q      (reg2hw.dio_out_sleep_val[11].q ),
-    .qs     (dio_out_sleep_val_out11_qs)
-  );
-
-
-  // F[out12]: 25:24
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out12 (
-    .re     (dio_out_sleep_val_out12_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out12_we & regen_qs),
-    .wd     (dio_out_sleep_val_out12_wd),
-    .d      (hw2reg.dio_out_sleep_val[12].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[12].qe),
-    .q      (reg2hw.dio_out_sleep_val[12].q ),
-    .qs     (dio_out_sleep_val_out12_qs)
-  );
-
-
-  // F[out13]: 27:26
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out13 (
-    .re     (dio_out_sleep_val_out13_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out13_we & regen_qs),
-    .wd     (dio_out_sleep_val_out13_wd),
-    .d      (hw2reg.dio_out_sleep_val[13].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[13].qe),
-    .q      (reg2hw.dio_out_sleep_val[13].q ),
-    .qs     (dio_out_sleep_val_out13_qs)
-  );
-
-
-  // F[out14]: 29:28
-  prim_subreg_ext #(
-    .DW    (2)
-  ) u_dio_out_sleep_val_out14 (
-    .re     (dio_out_sleep_val_out14_re),
-    // qualified with register enable
-    .we     (dio_out_sleep_val_out14_we & regen_qs),
-    .wd     (dio_out_sleep_val_out14_wd),
-    .d      (hw2reg.dio_out_sleep_val[14].d),
-    .qre    (),
-    .qe     (reg2hw.dio_out_sleep_val[14].qe),
-    .q      (reg2hw.dio_out_sleep_val[14].q ),
-    .qs     (dio_out_sleep_val_out14_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg wkup_detector_en
-  // R[wkup_detector_en]: V(False)
-
-  // F[en0]: 0:0
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en0_we & regen_qs),
-    .wd     (wkup_detector_en_en0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[0].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en0_qs)
-  );
-
-
-  // F[en1]: 1:1
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en1_we & regen_qs),
-    .wd     (wkup_detector_en_en1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[1].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en1_qs)
-  );
-
-
-  // F[en2]: 2:2
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en2_we & regen_qs),
-    .wd     (wkup_detector_en_en2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[2].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en2_qs)
-  );
-
-
-  // F[en3]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en3_we & regen_qs),
-    .wd     (wkup_detector_en_en3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[3].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en3_qs)
-  );
-
-
-  // F[en4]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en4_we & regen_qs),
-    .wd     (wkup_detector_en_en4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[4].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en4_qs)
-  );
-
-
-  // F[en5]: 5:5
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en5_we & regen_qs),
-    .wd     (wkup_detector_en_en5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[5].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en5_qs)
-  );
-
-
-  // F[en6]: 6:6
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en6_we & regen_qs),
-    .wd     (wkup_detector_en_en6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[6].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en6_qs)
-  );
-
-
-  // F[en7]: 7:7
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector_en_en7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_en_en7_we & regen_qs),
-    .wd     (wkup_detector_en_en7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_en[7].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_en_en7_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg wkup_detector
-  // R[wkup_detector0]: V(False)
-
-  // F[mode0]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector0_mode0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector0_mode0_we & regen_qs),
-    .wd     (wkup_detector0_mode0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[0].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector0_mode0_qs)
-  );
-
-
-  // F[filter0]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector0_filter0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector0_filter0_we & regen_qs),
-    .wd     (wkup_detector0_filter0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[0].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector0_filter0_qs)
-  );
-
-
-  // F[miodio0]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector0_miodio0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector0_miodio0_we & regen_qs),
-    .wd     (wkup_detector0_miodio0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[0].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector0_miodio0_qs)
-  );
-
-
-  // Subregister 1 of Multireg wkup_detector
-  // R[wkup_detector1]: V(False)
-
-  // F[mode1]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector1_mode1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector1_mode1_we & regen_qs),
-    .wd     (wkup_detector1_mode1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[1].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector1_mode1_qs)
-  );
-
-
-  // F[filter1]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector1_filter1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector1_filter1_we & regen_qs),
-    .wd     (wkup_detector1_filter1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[1].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector1_filter1_qs)
-  );
-
-
-  // F[miodio1]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector1_miodio1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector1_miodio1_we & regen_qs),
-    .wd     (wkup_detector1_miodio1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[1].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector1_miodio1_qs)
-  );
-
-
-  // Subregister 2 of Multireg wkup_detector
-  // R[wkup_detector2]: V(False)
-
-  // F[mode2]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector2_mode2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector2_mode2_we & regen_qs),
-    .wd     (wkup_detector2_mode2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[2].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector2_mode2_qs)
-  );
-
-
-  // F[filter2]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector2_filter2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector2_filter2_we & regen_qs),
-    .wd     (wkup_detector2_filter2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[2].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector2_filter2_qs)
-  );
-
-
-  // F[miodio2]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector2_miodio2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector2_miodio2_we & regen_qs),
-    .wd     (wkup_detector2_miodio2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[2].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector2_miodio2_qs)
-  );
-
-
-  // Subregister 3 of Multireg wkup_detector
-  // R[wkup_detector3]: V(False)
-
-  // F[mode3]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector3_mode3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector3_mode3_we & regen_qs),
-    .wd     (wkup_detector3_mode3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[3].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector3_mode3_qs)
-  );
-
-
-  // F[filter3]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector3_filter3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector3_filter3_we & regen_qs),
-    .wd     (wkup_detector3_filter3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[3].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector3_filter3_qs)
-  );
-
-
-  // F[miodio3]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector3_miodio3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector3_miodio3_we & regen_qs),
-    .wd     (wkup_detector3_miodio3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[3].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector3_miodio3_qs)
-  );
-
-
-  // Subregister 4 of Multireg wkup_detector
-  // R[wkup_detector4]: V(False)
-
-  // F[mode4]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector4_mode4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector4_mode4_we & regen_qs),
-    .wd     (wkup_detector4_mode4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[4].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector4_mode4_qs)
-  );
-
-
-  // F[filter4]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector4_filter4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector4_filter4_we & regen_qs),
-    .wd     (wkup_detector4_filter4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[4].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector4_filter4_qs)
-  );
-
-
-  // F[miodio4]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector4_miodio4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector4_miodio4_we & regen_qs),
-    .wd     (wkup_detector4_miodio4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[4].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector4_miodio4_qs)
-  );
-
-
-  // Subregister 5 of Multireg wkup_detector
-  // R[wkup_detector5]: V(False)
-
-  // F[mode5]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector5_mode5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector5_mode5_we & regen_qs),
-    .wd     (wkup_detector5_mode5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[5].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector5_mode5_qs)
-  );
-
-
-  // F[filter5]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector5_filter5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector5_filter5_we & regen_qs),
-    .wd     (wkup_detector5_filter5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[5].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector5_filter5_qs)
-  );
-
-
-  // F[miodio5]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector5_miodio5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector5_miodio5_we & regen_qs),
-    .wd     (wkup_detector5_miodio5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[5].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector5_miodio5_qs)
-  );
-
-
-  // Subregister 6 of Multireg wkup_detector
-  // R[wkup_detector6]: V(False)
-
-  // F[mode6]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector6_mode6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector6_mode6_we & regen_qs),
-    .wd     (wkup_detector6_mode6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[6].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector6_mode6_qs)
-  );
-
-
-  // F[filter6]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector6_filter6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector6_filter6_we & regen_qs),
-    .wd     (wkup_detector6_filter6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[6].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector6_filter6_qs)
-  );
-
-
-  // F[miodio6]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector6_miodio6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector6_miodio6_we & regen_qs),
-    .wd     (wkup_detector6_miodio6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[6].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector6_miodio6_qs)
-  );
-
-
-  // Subregister 7 of Multireg wkup_detector
-  // R[wkup_detector7]: V(False)
-
-  // F[mode7]: 2:0
-  prim_subreg #(
-    .DW      (3),
-    .SWACCESS("RW"),
-    .RESVAL  (3'h0)
-  ) u_wkup_detector7_mode7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector7_mode7_we & regen_qs),
-    .wd     (wkup_detector7_mode7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[7].mode.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector7_mode7_qs)
-  );
-
-
-  // F[filter7]: 3:3
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector7_filter7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector7_filter7_we & regen_qs),
-    .wd     (wkup_detector7_filter7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[7].filter.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector7_filter7_qs)
-  );
-
-
-  // F[miodio7]: 4:4
-  prim_subreg #(
-    .DW      (1),
-    .SWACCESS("RW"),
-    .RESVAL  (1'h0)
-  ) u_wkup_detector7_miodio7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector7_miodio7_we & regen_qs),
-    .wd     (wkup_detector7_miodio7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector[7].miodio.q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector7_miodio7_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg wkup_detector_cnt_th
-  // R[wkup_detector_cnt_th0]: V(False)
-
-  // F[th0]: 7:0
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th0_th0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th0_th0_we & regen_qs),
-    .wd     (wkup_detector_cnt_th0_th0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[0].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th0_th0_qs)
-  );
-
-
-  // F[th1]: 15:8
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th0_th1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th0_th1_we & regen_qs),
-    .wd     (wkup_detector_cnt_th0_th1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[1].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th0_th1_qs)
-  );
-
-
-  // F[th2]: 23:16
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th0_th2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th0_th2_we & regen_qs),
-    .wd     (wkup_detector_cnt_th0_th2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[2].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th0_th2_qs)
-  );
-
-
-  // F[th3]: 31:24
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th0_th3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th0_th3_we & regen_qs),
-    .wd     (wkup_detector_cnt_th0_th3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[3].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th0_th3_qs)
-  );
-
-
-  // Subregister 4 of Multireg wkup_detector_cnt_th
-  // R[wkup_detector_cnt_th1]: V(False)
-
-  // F[th4]: 7:0
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th1_th4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th1_th4_we & regen_qs),
-    .wd     (wkup_detector_cnt_th1_th4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[4].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th1_th4_qs)
-  );
-
-
-  // F[th5]: 15:8
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th1_th5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th1_th5_we & regen_qs),
-    .wd     (wkup_detector_cnt_th1_th5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[5].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th1_th5_qs)
-  );
-
-
-  // F[th6]: 23:16
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th1_th6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th1_th6_we & regen_qs),
-    .wd     (wkup_detector_cnt_th1_th6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[6].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th1_th6_qs)
-  );
-
-
-  // F[th7]: 31:24
-  prim_subreg #(
-    .DW      (8),
-    .SWACCESS("RW"),
-    .RESVAL  (8'h0)
-  ) u_wkup_detector_cnt_th1_th7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_cnt_th1_th7_we & regen_qs),
-    .wd     (wkup_detector_cnt_th1_th7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_cnt_th[7].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_cnt_th1_th7_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg wkup_detector_padsel
-  // R[wkup_detector_padsel0]: V(False)
-
-  // F[sel0]: 4:0
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel0 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel0_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel0_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[0].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel0_qs)
-  );
-
-
-  // F[sel1]: 9:5
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel1 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel1_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel1_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[1].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel1_qs)
-  );
-
-
-  // F[sel2]: 14:10
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel2 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel2_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel2_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[2].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel2_qs)
-  );
-
-
-  // F[sel3]: 19:15
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel3 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel3_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel3_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[3].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel3_qs)
-  );
-
-
-  // F[sel4]: 24:20
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel4 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel4_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel4_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[4].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel4_qs)
-  );
-
-
-  // F[sel5]: 29:25
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel0_sel5 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel0_sel5_we & regen_qs),
-    .wd     (wkup_detector_padsel0_sel5_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[5].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel0_sel5_qs)
-  );
-
-
-  // Subregister 6 of Multireg wkup_detector_padsel
-  // R[wkup_detector_padsel1]: V(False)
-
-  // F[sel6]: 4:0
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel1_sel6 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel1_sel6_we & regen_qs),
-    .wd     (wkup_detector_padsel1_sel6_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[6].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel1_sel6_qs)
-  );
-
-
-  // F[sel7]: 9:5
-  prim_subreg #(
-    .DW      (5),
-    .SWACCESS("RW"),
-    .RESVAL  (5'h0)
-  ) u_wkup_detector_padsel1_sel7 (
-    .clk_i   (clk_i    ),
-    .rst_ni  (rst_ni  ),
-
-    // from register interface (qualified with register enable)
-    .we     (wkup_detector_padsel1_sel7_we & regen_qs),
-    .wd     (wkup_detector_padsel1_sel7_wd),
-
-    // from internal hardware
-    .de     (1'b0),
-    .d      ('0  ),
-
-    // to internal hardware
-    .qe     (),
-    .q      (reg2hw.wkup_detector_padsel[7].q ),
-
-    // to register interface (read)
-    .qs     (wkup_detector_padsel1_sel7_qs)
-  );
-
-
-
-
-  // Subregister 0 of Multireg wkup_cause
-  // R[wkup_cause]: V(True)
-
-  // F[cause0]: 0:0
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause0 (
-    .re     (wkup_cause_cause0_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause0_we & regen_qs),
-    .wd     (wkup_cause_cause0_wd),
-    .d      (hw2reg.wkup_cause[0].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[0].qe),
-    .q      (reg2hw.wkup_cause[0].q ),
-    .qs     (wkup_cause_cause0_qs)
-  );
-
-
-  // F[cause1]: 1:1
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause1 (
-    .re     (wkup_cause_cause1_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause1_we & regen_qs),
-    .wd     (wkup_cause_cause1_wd),
-    .d      (hw2reg.wkup_cause[1].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[1].qe),
-    .q      (reg2hw.wkup_cause[1].q ),
-    .qs     (wkup_cause_cause1_qs)
-  );
-
-
-  // F[cause2]: 2:2
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause2 (
-    .re     (wkup_cause_cause2_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause2_we & regen_qs),
-    .wd     (wkup_cause_cause2_wd),
-    .d      (hw2reg.wkup_cause[2].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[2].qe),
-    .q      (reg2hw.wkup_cause[2].q ),
-    .qs     (wkup_cause_cause2_qs)
-  );
-
-
-  // F[cause3]: 3:3
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause3 (
-    .re     (wkup_cause_cause3_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause3_we & regen_qs),
-    .wd     (wkup_cause_cause3_wd),
-    .d      (hw2reg.wkup_cause[3].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[3].qe),
-    .q      (reg2hw.wkup_cause[3].q ),
-    .qs     (wkup_cause_cause3_qs)
-  );
-
-
-  // F[cause4]: 4:4
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause4 (
-    .re     (wkup_cause_cause4_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause4_we & regen_qs),
-    .wd     (wkup_cause_cause4_wd),
-    .d      (hw2reg.wkup_cause[4].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[4].qe),
-    .q      (reg2hw.wkup_cause[4].q ),
-    .qs     (wkup_cause_cause4_qs)
-  );
-
-
-  // F[cause5]: 5:5
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause5 (
-    .re     (wkup_cause_cause5_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause5_we & regen_qs),
-    .wd     (wkup_cause_cause5_wd),
-    .d      (hw2reg.wkup_cause[5].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[5].qe),
-    .q      (reg2hw.wkup_cause[5].q ),
-    .qs     (wkup_cause_cause5_qs)
-  );
-
-
-  // F[cause6]: 6:6
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause6 (
-    .re     (wkup_cause_cause6_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause6_we & regen_qs),
-    .wd     (wkup_cause_cause6_wd),
-    .d      (hw2reg.wkup_cause[6].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[6].qe),
-    .q      (reg2hw.wkup_cause[6].q ),
-    .qs     (wkup_cause_cause6_qs)
-  );
-
-
-  // F[cause7]: 7:7
-  prim_subreg_ext #(
-    .DW    (1)
-  ) u_wkup_cause_cause7 (
-    .re     (wkup_cause_cause7_re),
-    // qualified with register enable
-    .we     (wkup_cause_cause7_we & regen_qs),
-    .wd     (wkup_cause_cause7_wd),
-    .d      (hw2reg.wkup_cause[7].d),
-    .qre    (),
-    .qe     (reg2hw.wkup_cause[7].qe),
-    .q      (reg2hw.wkup_cause[7].q ),
-    .qs     (wkup_cause_cause7_qs)
-  );
-
-
-
-
-
+  // Register instances
+  // R[regen]: V(False)
   logic [31:0] addr_hit;
   always_comb begin
-    addr_hit = '0;
+    addr_hit = {32 {1'b0}};
     addr_hit[ 0] = (reg_addr == PINMUX_REGEN_OFFSET);
     addr_hit[ 1] = (reg_addr == PINMUX_PERIPH_INSEL0_OFFSET);
     addr_hit[ 2] = (reg_addr == PINMUX_PERIPH_INSEL1_OFFSET);
@@ -5457,7 +3613,7 @@ module pinmux_reg_top (
 
   // Read data return
   always_comb begin
-    reg_rdata_next = '0;
+    reg_rdata_next = {32 {1'b0}};
     unique case (1'b1)
       addr_hit[0]: begin
         reg_rdata_next[0] = regen_qs;
@@ -5724,7 +3880,7 @@ module pinmux_reg_top (
       end
 
       default: begin
-        reg_rdata_next = '1;
+        reg_rdata_next = {32 {1'b1}};
       end
     endcase
   end
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
index 61469937f..12f0a2bcd 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_core.sv
@@ -133,8 +133,8 @@ module ibex_core #(
   logic [31:0] pc_if;                          // Program counter in IF stage
   logic [31:0] pc_id;                          // Program counter in ID stage
   logic [31:0] pc_wb;                          // Program counter in WB stage
-  logic [33:0] imd_val_d_ex[2];                // Intermediate register for multicycle Ops
-  logic [33:0] imd_val_q_ex[2];                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_d_ex;                // Intermediate register for multicycle Ops
+  logic [1:0][33:0] imd_val_q_ex;                // Intermediate register for multicycle Ops
   logic [1:0]  imd_val_we_ex;
 
   logic        data_ind_timing;
@@ -254,7 +254,7 @@ module ibex_core #(
   logic [31:0] csr_mepc, csr_depc;
 
   // PMP signals
-  logic [33:0] csr_pmp_addr [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0] csr_pmp_addr;
   pmp_cfg_t    csr_pmp_cfg  [PMPNumRegions];
   logic        pmp_req_err  [PMP_NUM_CHAN];
   logic        instr_req_out;
@@ -932,16 +932,16 @@ module ibex_core #(
   `ASSERT_KNOWN_IF(IbexCsrWdataIntKnown, cs_registers_i.csr_wdata_int, csr_op_en)
 
   if (PMPEnable) begin : g_pmp
-    logic [33:0] pmp_req_addr [PMP_NUM_CHAN];
-    pmp_req_e    pmp_req_type [PMP_NUM_CHAN];
-    priv_lvl_e   pmp_priv_lvl [PMP_NUM_CHAN];
-
-    assign pmp_req_addr[PMP_I] = {2'b00,instr_addr_o[31:0]};
-    assign pmp_req_type[PMP_I] = PMP_ACC_EXEC;
-    assign pmp_priv_lvl[PMP_I] = priv_mode_if;
-    assign pmp_req_addr[PMP_D] = {2'b00,data_addr_o[31:0]};
-    assign pmp_req_type[PMP_D] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
-    assign pmp_priv_lvl[PMP_D] = priv_mode_lsu;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_req_type;
+    logic [PMP_NUM_CHAN-1:0][1:0]    pmp_priv_lvl;
+    logic [PMP_NUM_CHAN-1:0][33:0] pmp_req_addr;
+
+    assign pmp_req_addr[PMP_D] = {2'b00,instr_addr_o[31:0]};
+    assign pmp_req_type[PMP_D] = PMP_ACC_EXEC;
+    assign pmp_priv_lvl[PMP_D] = priv_mode_if;
+    assign pmp_req_addr[PMP_I] = {2'b00,data_addr_o[31:0]};
+    assign pmp_req_type[PMP_I] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
+    assign pmp_priv_lvl[PMP_I] = priv_mode_lsu;
 
     ibex_pmp #(
         .PMPGranularity        ( PMPGranularity ),
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
index 6e5eaf4dc..d99e087d6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv
@@ -64,7 +64,7 @@ module ibex_cs_registers #(
 
     // PMP
     output ibex_pkg::pmp_cfg_t   csr_pmp_cfg_o  [PMPNumRegions],
-    output logic [33:0]          csr_pmp_addr_o [PMPNumRegions],
+    output logic [PMPNumRegions-1:0][33:0]          csr_pmp_addr_o,
 
     // debug
     input  logic                 debug_mode_i,
@@ -196,8 +196,8 @@ module ibex_cs_registers #(
   logic  [5:0] mstack_cause_q, mstack_cause_d;
 
   // PMP Signals
-  logic [31:0]                 pmp_addr_rdata  [PMP_MAX_REGIONS];
-  logic [PMP_CFG_W-1:0]        pmp_cfg_rdata   [PMP_MAX_REGIONS];
+  logic [PMP_MAX_REGIONS-1:0][31:0]                 pmp_addr_rdata;
+  logic [PMP_MAX_REGIONS-1:0][PMP_CFG_W-1:0]        pmp_cfg_rdata;
 
   // Hardware performance monitor signals
   logic [31:0]                 mcountinhibit;
@@ -208,11 +208,11 @@ module ibex_cs_registers #(
   // mhpmcounter flops are elaborated below providing only the precise number that is required based
   // on MHPMCounterNum/MHPMCounterWidth. This signal connects to the Q output of these flops
   // where they exist and is otherwise 0.
-  logic [63:0] mhpmcounter [32];
+  logic [31:0][63:0] mhpmcounter;
   logic [31:0] mhpmcounter_we;
   logic [31:0] mhpmcounterh_we;
   logic [31:0] mhpmcounter_incr;
-  logic [31:0] mhpmevent [32];
+  logic [31:0][31:0] mhpmevent;
   logic  [4:0] mhpmcounter_idx;
 
   // Debug / trigger registers
@@ -736,12 +736,12 @@ module ibex_cs_registers #(
   // PMP registers
   // -----------------
 
+  pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
+  pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
+  logic [PMPNumRegions-1:0][31:0]                 pmp_addr;
+  logic [PMPNumRegions-1:0]    pmp_cfg_we;
+  logic [PMPNumRegions-1:0]    pmp_addr_we;
   if (PMPEnable) begin : g_pmp_registers
-    pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
-    pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
-    logic [31:0]                 pmp_addr        [PMPNumRegions];
-    logic [PMPNumRegions-1:0]    pmp_cfg_we;
-    logic [PMPNumRegions-1:0]    pmp_addr_we;
 
     // Expanded / qualified register read data
     for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
index eccc68e95..06a672e88 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv
@@ -42,8 +42,8 @@ module ibex_ex_block #(
 
     // intermediate val reg
     output logic [1:0]            imd_val_we_o,
-    output logic [33:0]           imd_val_d_o[2],
-    input  logic [33:0]           imd_val_q_i[2],
+    output logic [1:0][33:0]           imd_val_d_o,
+    input  logic [1:0][33:0]           imd_val_q_i,
 
     // Outputs
     output logic [31:0]           alu_adder_result_ex_o, // to LSU
@@ -63,10 +63,10 @@ module ibex_ex_block #(
   logic        alu_cmp_result, alu_is_equal_result;
   logic        multdiv_valid;
   logic        multdiv_sel;
-  logic [31:0] alu_imd_val_q[2];
-  logic [31:0] alu_imd_val_d[2];
+  logic [1:0][31:0] alu_imd_val_q;
+  logic [1:0][31:0] alu_imd_val_d;
   logic [ 1:0] alu_imd_val_we;
-  logic [33:0] multdiv_imd_val_d[2];
+  logic [1:0][33:0] multdiv_imd_val_d;
   logic [ 1:0] multdiv_imd_val_we;
 
   /*
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
index bba4c2af8..a4fbb8da6 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv
@@ -21,9 +21,9 @@ module ibex_id_stage #(
     parameter bit               RV32M           = 1,
     parameter ibex_pkg::rv32b_e RV32B           = ibex_pkg::RV32BNone,
     parameter bit               DataIndTiming   = 1'b0,
-    parameter bit               BranchTargetALU = 0,
-    parameter bit               SpecBranch      = 0,
-    parameter bit               WritebackStage  = 0
+    parameter bit               BranchTargetALU = 1,
+    parameter bit               SpecBranch      = 1,
+    parameter bit               WritebackStage  = 1
 ) (
     input  logic                      clk_i,
     input  logic                      rst_ni,
@@ -69,8 +69,8 @@ module ibex_id_stage #(
 
     // Multicycle Operation Stage Register
     input  logic [1:0]                imd_val_we_ex_i,
-    input  logic [33:0]               imd_val_d_ex_i[2],
-    output logic [33:0]               imd_val_q_ex_o[2],
+    input  logic [1:0][33:0]               imd_val_d_ex_i,
+    output logic [1:0][33:0]               imd_val_q_ex_o,
 
     // Branch target ALU
     output logic [31:0]               bt_a_operand_o,
@@ -247,7 +247,7 @@ module ibex_id_stage #(
   logic        alu_multicycle_dec;
   logic        stall_alu;
 
-  logic [33:0] imd_val_q[2];
+  logic [1:0][33:0] imd_val_q;
 
   op_a_sel_e   bt_a_mux_sel;
   imm_b_sel_e  bt_b_mux_sel;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
index 617bb5162..e1890da38 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv
@@ -35,8 +35,8 @@ module ibex_multdiv_fast #(
     output logic [32:0]      alu_operand_a_o,
     output logic [32:0]      alu_operand_b_o,
 
-    input  logic [33:0]      imd_val_q_i[2],
-    output logic [33:0]      imd_val_d_o[2],
+    input  logic [1:0][33:0]      imd_val_q_i,
+    output logic [1:0][33:0]      imd_val_d_o,
     output logic [1:0]       imd_val_we_o,
 
     input  logic             multdiv_ready_id_i,
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
index 1b48693a0..4621be034 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv
@@ -30,8 +30,8 @@ module ibex_pmp #(
   import ibex_pkg::*;
 
   // Access Checking Signals
-  logic [33:0]                                region_start_addr [PMPNumRegions];
-  logic [33:PMPGranularity+2]                 region_addr_mask  [PMPNumRegions];
+  logic [PMPNumRegions-1:0][33:0]                                region_start_addr;
+  logic [PMPNumRegions-1:0][33:0]                 region_addr_mask;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_gt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_lt;
   logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_eq;
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
index 4dd429df8..8c95e2492 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv
@@ -42,8 +42,8 @@ module ibex_register_file #(
   localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;
 
   logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg;
-  logic [NUM_WORDS-1:1][DataWidth-1:0] rf_reg_q;
-  logic [NUM_WORDS-1:1]                we_a_dec;
+  logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg_q;
+  logic [NUM_WORDS-1:0]                we_a_dec;
 
   always_comb begin : we_a_decoder
     for (int unsigned i = 1; i < NUM_WORDS; i++) begin
diff --git a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
index ffe380ff4..6f518796f 100644
--- a/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
+++ b/hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv
@@ -51,7 +51,7 @@ module ibex_wb_stage #(
 
   // 0 == RF write from ID
   // 1 == RF write from LSU
-  logic [31:0] rf_wdata_wb_mux    [2];
+  logic [1:0][31:0] rf_wdata_wb_mux;
   logic [1:0]  rf_wdata_wb_mux_we;
 
   if(WritebackStage) begin : g_writeback_stage
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
index 550b7cc36..c65fe30c4 100755
--- a/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_mem.sv
@@ -216,7 +216,7 @@ module dm_mem #(
   // read/write logic
   logic [63:0] data_bits;
   logic [7:0][7:0] rdata;
-  always_comb begin : p_rw_logic
+  always begin : p_rw_logic
 
     halted_d_aligned   = NrHartsAligned'(halted_q);
     resuming_d_aligned = NrHartsAligned'(resuming_q);
diff --git a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
index c97f9565a..4aa3646f4 100644
--- a/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
+++ b/hw/vendor/pulp_riscv_dbg/src/dm_sba.sv
@@ -98,16 +98,16 @@ module dm_sba #(
         // generate byte enable mask
         unique case (sbaccess_i)
           3'b000: begin
-            be[be_idx] = '1;
+            be[be_idx] = 4'b1111;
           end
           3'b001: begin
-            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = '1;
+            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = 2'b11;
           end
           3'b010: begin
-            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = '1;
-            else                    be = '1;
+            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'h0}) +: 4] = 2'b11;
+            else                    be = 4'b1111;
           end
-          3'b011: be = '1;
+          3'b011: be = 4'b1111;
           default: ;
         endcase
         if (gnt) state_d = WaitWrite;
